{"version":3,"file":"vendor.a3d920ac.js","sources":["../../node_modules/sanctuary-show/index.js","../../node_modules/sanctuary-type-identifiers/index.js","../../node_modules/sanctuary-type-classes/index.js","../../node_modules/sanctuary-either/index.js","../../node_modules/sanctuary-def/index.js","../../node_modules/sanctuary-maybe/index.js","../../node_modules/sanctuary-pair/index.js","../../node_modules/sanctuary/index.js","../../node_modules/fluture/src/internal/const.js","../../node_modules/fluture/src/internal/list.js","../../node_modules/fluture/src/internal/debug.js","../../node_modules/fluture/src/internal/utils.js","../../node_modules/fluture/src/internal/error.js","../../node_modules/fluture/src/internal/predicates.js","../../node_modules/fluture/src/internal/iteration.js","../../node_modules/fluture/src/future.js","../../node_modules/fluture/src/after.js","../../node_modules/fluture/src/and.js","../../node_modules/fluture/src/encase-p.js","../../node_modules/fluture/src/encase.js","../../node_modules/fluture/src/bichain.js","../../node_modules/fluture/src/internal/parallel.js","../../node_modules/fluture/src/both.js","../../node_modules/fluture/src/cache.js","../../node_modules/fluture/src/chain-rej.js","../../node_modules/fluture/src/chain.js","../../node_modules/fluture/src/extract-left.js","../../node_modules/fluture/src/extract-right.js","../../node_modules/fluture/src/coalesce.js","../../node_modules/fluture/src/fork.js","../../node_modules/fluture/src/internal/timing.js","../../node_modules/fluture/src/go.js","../../node_modules/fluture/src/hook.js","../../node_modules/fluture/src/lastly.js","../../node_modules/fluture/src/map-rej.js","../../node_modules/fluture/src/node.js","../../node_modules/fluture/src/pap.js","../../node_modules/fluture/src/parallel.js","../../node_modules/fluture/src/race.js","../../node_modules/fluture/src/par.js","../../node_modules/fluture/src/reject-after.js","../../node_modules/fluture/src/seq.js","../../node_modules/fluture/src/swap.js","../../node_modules/fluture-sanctuary-types/index.js"],"sourcesContent":["//. # sanctuary-show\n//.\n//. Haskell has a `show` function which can be applied to a compatible value to\n//. produce a descriptive string representation of that value. The idea is that\n//. the string representation should, if possible, be an expression which would\n//. produce the original value if evaluated.\n//.\n//. This library provides a similar [`show`](#show) function.\n//.\n//. In general, this property should hold: `eval (show (x)) = x`. In some cases\n//. parens are necessary to ensure correct interpretation (`{}`, for example,\n//. is an empty block rather than an empty object in some contexts). Thus the\n//. property is more accurately stated `eval ('(' + show (x) + ')') = x`.\n//.\n//. One can make values of a custom type compatible with [`show`](#show) by\n//. defining a `@@show` method. For example:\n//.\n//. ```javascript\n//. //# Maybe#@@show :: Maybe a ~> () -> String\n//. //.\n//. //. ```javascript\n//. //. > show (Nothing)\n//. //. 'Nothing'\n//. //.\n//. //. > show (Just (['foo', 'bar', 'baz']))\n//. //. 'Just ([\"foo\", \"bar\", \"baz\"])'\n//. //. ```\n//. Maybe.prototype['@@show'] = function() {\n//.   return this.isNothing ? 'Nothing' : 'Just (' + show (this.value) + ')';\n//. };\n//. ```\n\n(f => {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f ();\n  } else if (typeof define === 'function' && define.amd != null) {\n    define ([], f);\n  } else {\n    self.sanctuaryShow = f ();\n  }\n\n}) (() => {\n\n  'use strict';\n\n  //  $$show :: String\n  const $$show = '@@show';\n\n  //  seen :: Array Any\n  const seen = [];\n\n  //  entry :: Object -> String -> String\n  const entry = o => k => show (k) + ': ' + show (o[k]);\n\n  //  sortedKeys :: Object -> Array String\n  const sortedKeys = o => (Object.keys (o)).sort ();\n\n  //# show :: Showable a => a -> String\n  //.\n  //. Returns a useful string representation of the given value.\n  //.\n  //. Dispatches to the value's `@@show` method if present.\n  //.\n  //. Where practical, `show (eval ('(' + show (x) + ')')) = show (x)`.\n  //.\n  //. ```javascript\n  //. > show (null)\n  //. 'null'\n  //.\n  //. > show (undefined)\n  //. 'undefined'\n  //.\n  //. > show (true)\n  //. 'true'\n  //.\n  //. > show (new Boolean (false))\n  //. 'new Boolean (false)'\n  //.\n  //. > show (-0)\n  //. '-0'\n  //.\n  //. > show (NaN)\n  //. 'NaN'\n  //.\n  //. > show (new Number (Infinity))\n  //. 'new Number (Infinity)'\n  //.\n  //. > show ('foo\\n\"bar\"\\nbaz\\n')\n  //. '\"foo\\\\n\\\\\"bar\\\\\"\\\\nbaz\\\\n\"'\n  //.\n  //. > show (new String (''))\n  //. 'new String (\"\")'\n  //.\n  //. > show (['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > show ([[[[[0]]]]])\n  //. '[[[[[0]]]]]'\n  //.\n  //. > show ({x: [1, 2], y: [3, 4], z: [5, 6]})\n  //. '{\"x\": [1, 2], \"y\": [3, 4], \"z\": [5, 6]}'\n  //. ```\n  const show = x => {\n    if (seen.indexOf (x) >= 0) return '<Circular>';\n\n    const repr = Object.prototype.toString.call (x);\n\n    switch (repr) {\n\n      case '[object Null]':\n        return 'null';\n\n      case '[object Undefined]':\n        return 'undefined';\n\n      case '[object Boolean]':\n        return typeof x === 'object' ?\n          'new Boolean (' + show (x.valueOf ()) + ')' :\n          x.toString ();\n\n      case '[object Number]':\n        return typeof x === 'object' ?\n          'new Number (' + show (x.valueOf ()) + ')' :\n          1 / x === -Infinity ? '-0' : x.toString (10);\n\n      case '[object String]':\n        return typeof x === 'object' ?\n          'new String (' + show (x.valueOf ()) + ')' :\n          JSON.stringify (x);\n\n      case '[object RegExp]':\n        return x.toString ();\n\n      case '[object Date]':\n        return 'new Date (' +\n               show (isNaN (x.valueOf ()) ? NaN : x.toISOString ()) +\n               ')';\n\n      case '[object Error]':\n        return 'new ' + x.name + ' (' + show (x.message) + ')';\n\n      case '[object Arguments]':\n        return 'function () { return arguments; } (' +\n               (Array.prototype.map.call (x, show)).join (', ') +\n               ')';\n\n      case '[object Array]':\n        seen.push (x);\n        try {\n          return '[' + ((x.map (show)).concat (\n            sortedKeys (x)\n            .filter (k => !(/^\\d+$/.test (k)))\n            .map (entry (x))\n          )).join (', ') + ']';\n        } finally {\n          seen.pop ();\n        }\n\n      case '[object Object]':\n        seen.push (x);\n        try {\n          return (\n            $$show in x &&\n            (x.constructor == null || x.constructor.prototype !== x) ?\n              x[$$show] () :\n              '{' + ((sortedKeys (x)).map (entry (x))).join (', ') + '}'\n          );\n        } finally {\n          seen.pop ();\n        }\n\n      case '[object Set]':\n        seen.push (x);\n        try {\n          return 'new Set (' + show (Array.from (x.values ())) + ')';\n        } finally {\n          seen.pop ();\n        }\n\n      case '[object Map]':\n        seen.push (x);\n        try {\n          return 'new Map (' + show (Array.from (x.entries ())) + ')';\n        } finally {\n          seen.pop ();\n        }\n\n      default:\n        return repr.replace (/^\\[(.*)\\]$/, '<$1>');\n\n    }\n  };\n\n  return show;\n\n});\n","/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. sanctuary-type-identifiers comprises:\n//.\n//.   - an npm and browser -compatible package for deriving the\n//.     _type identifier_ of a JavaScript value; and\n//.   - a specification which authors may follow to specify type\n//.     identifiers for their types.\n//.\n//. ### Specification\n//.\n//. For a type to be compatible with the algorithm:\n//.\n//.   - every member of the type MUST have a `@@type` property\n//.     (the _type identifier_); and\n//.\n//.   - the type identifier MUST be a string primitive and SHOULD have\n//.     format `'<namespace>/<name>[@<version>]'`, where:\n//.\n//.       - `<namespace>` MUST consist of one or more characters, and\n//.         SHOULD equal the name of the npm package which defines the\n//.         type (including [scope][3] where appropriate);\n//.\n//.       - `<name>` MUST consist of one or more characters, and SHOULD\n//.         be the unique name of the type; and\n//.\n//.       - `<version>` MUST consist of one or more digits, and SHOULD\n//.         represent the version of the type.\n//.\n//. If the type identifier does not conform to the format specified above,\n//. it is assumed that the entire string represents the _name_ of the type;\n//. _namespace_ will be `null` and _version_ will be `0`.\n//.\n//. If the _version_ is not given, it is assumed to be `0`.\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f ();\n  } else if (typeof define === 'function' && define.amd != null) {\n    define ([], f);\n  } else {\n    self.sanctuaryTypeIdentifiers = f ();\n  }\n\n} (function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  pattern :: RegExp\n  var pattern = new RegExp (\n    '^'\n  + '([\\\\s\\\\S]+)'   //  <namespace>\n  + '/'             //  SOLIDUS (U+002F)\n  + '([\\\\s\\\\S]+?)'  //  <name>\n  + '(?:'           //  optional non-capturing group {\n  +   '@'           //    COMMERCIAL AT (U+0040)\n  +   '([0-9]+)'    //    <version>\n  + ')?'            //  }\n  + '$'\n  );\n\n  //. ### Usage\n  //.\n  //. ```javascript\n  //. const type = require ('sanctuary-type-identifiers');\n  //. ```\n  //.\n  //. ```javascript\n  //. > const Identity$prototype = {\n  //. .   '@@type': 'my-package/Identity@1',\n  //. .   '@@show': function() {\n  //. .     return 'Identity (' + show (this.value) + ')';\n  //. .   }\n  //. . }\n  //.\n  //. > const Identity = value =>\n  //. .   Object.assign (Object.create (Identity$prototype), {value})\n  //.\n  //. > type (Identity (0))\n  //. 'my-package/Identity@1'\n  //.\n  //. > type.parse (type (Identity (0)))\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  //.\n  //. ### API\n  //.\n  //# type :: Any -> String\n  //.\n  //. Takes any value and returns a string which identifies its type. If the\n  //. value conforms to the [specification][4], the custom type identifier is\n  //. returned.\n  //.\n  //. ```javascript\n  //. > type (null)\n  //. 'Null'\n  //.\n  //. > type (true)\n  //. 'Boolean'\n  //.\n  //. > type (Identity (0))\n  //. 'my-package/Identity@1'\n  //. ```\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x[$$type] === 'string' ?\n      x[$$type] :\n      (Object.prototype.toString.call (x)).slice ('[object '.length,\n                                                  -']'.length);\n  }\n\n  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }\n  //.\n  //. Takes any string and parses it according to the [specification][4],\n  //. returning an object with `namespace`, `name`, and `version` fields.\n  //.\n  //. ```javascript\n  //. > type.parse ('my-package/List@2')\n  //. {namespace: 'my-package', name: 'List', version: 2}\n  //.\n  //. > type.parse ('nonsense!')\n  //. {namespace: null, name: 'nonsense!', version: 0}\n  //.\n  //. > type.parse (type (Identity (0)))\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  type.parse = function parse(s) {\n    var namespace = null;\n    var name = s;\n    var version = 0;\n    var groups = pattern.exec (s);\n    if (groups != null) {\n      namespace = groups[1];\n      name = groups[2];\n      if (groups[3] != null) version = Number (groups[3]);\n    }\n    return {namespace: namespace, name: name, version: version};\n  };\n\n  return type;\n\n}));\n\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: https://docs.npmjs.com/misc/scope\n//. [4]: #specification\n","/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(f => {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-type-identifiers'], f);\n  } else {\n    self.sanctuaryTypeClasses = f (self.sanctuaryTypeIdentifiers);\n  }\n\n}) (type => {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars, no-var */\n    var Identity = __doctest.require ('sanctuary-identity');\n    var List = __doctest.require ('./test/List');\n    var Maybe = __doctest.require ('sanctuary-maybe');\n    var Pair = __doctest.require ('sanctuary-pair');\n    var Sum = __doctest.require ('./test/Sum');\n    var Useless = __doctest.require ('sanctuary-useless');\n\n    var {Nil, Cons} = List;\n    var {Nothing, Just} = Maybe;\n    /* eslint-enable no-unused-vars, no-var */\n  }\n\n  //  concat :: Array a -> Array a -> Array a\n  const concat = xs => ys => xs.concat (ys);\n\n  //  has :: (String, Object) -> Boolean\n  const has = (k, o) => Object.prototype.hasOwnProperty.call (o, k);\n\n  //  identity :: a -> a\n  const identity = x => x;\n\n  //  pair :: a -> b -> Array2 a b\n  const pair = x => y => [x, y];\n\n  //  sameType :: (a, b) -> Boolean\n  const sameType = (x, y) => typeof x === typeof y && type (x) === type (y);\n\n  //  sortedKeys :: Object -> Array String\n  const sortedKeys = o => (Object.keys (o)).sort ();\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  const iterationNext = x => ({value: x, done: false});\n\n  //  iterationDone :: a -> Iteration a\n  const iterationDone = x => ({value: x, done: true});\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      Z.equals (this.valueOf (), other.valueOf ()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      Z.lte (this.valueOf (), other.valueOf ()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      Z.equals (this.valueOf (), other.valueOf ()) :\n      isNaN (this) && isNaN (other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      Z.lte (this.valueOf (), other.valueOf ()) :\n      isNaN (this) || this <= other;\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return Z.equals (this.valueOf (), other.valueOf ());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return Z.lte (this.valueOf (), other.valueOf ());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  const String$empty = () => '';\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      Z.equals (this.valueOf (), other.valueOf ()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      Z.lte (this.valueOf (), other.valueOf ()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  const Array$empty = () => [];\n\n  //  Array$of :: a -> Array a\n  const Array$of = x => [x];\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  const Array$chainRec = (f, x) => {\n    const result = [];\n    const nil = {};\n    let todo = {head: x, tail: nil};\n    while (todo !== nil) {\n      let more = nil;\n      const steps = f (iterationNext, iterationDone, todo.head);\n      for (let idx = 0; idx < steps.length; idx += 1) {\n        const step = steps[idx];\n        if (step.done) {\n          result.push (step.value);\n        } else {\n          more = {head: step.value, tail: more};\n        }\n      }\n      todo = todo.tail;\n      while (more !== nil) {\n        todo = {head: more.head, tail: todo};\n        more = more.tail;\n      }\n    }\n    return result;\n  };\n\n  //  Array$zero :: () -> Array a\n  const Array$zero = () => [];\n\n  //  Array$prototype$equals :: Setoid a => Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (let idx = 0; idx < this.length; idx += 1) {\n      if (!(Z.equals (this[idx], other[idx]))) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Ord a => Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (let idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!(Z.equals (this[idx], other[idx]))) {\n        return Z.lte (this[idx], other[idx]);\n      }\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat (other);\n  }\n\n  //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a\n  function Array$prototype$filter(pred) {\n    return this.filter (x => pred (x));\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map (x => f (x));\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    const result = [];\n    for (let idx = 0; idx < fs.length; idx += 1) {\n      for (let idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push (fs[idx] (this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    const result = [];\n    for (let idx = 0; idx < this.length; idx += 1) {\n      for (let idx2 = 0, xs = f (this[idx]); idx2 < xs.length; idx2 += 1) {\n        result.push (xs[idx2]);\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  const Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    let acc = initial;\n    for (let idx = 0; idx < this.length; idx += 1) acc = f (acc, this[idx]);\n    return acc;\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    const go = (idx, n) => {\n      switch (n) {\n        case 0: return Z.of (typeRep, []);\n        case 2: return Z.lift2 (pair, f (this[idx]), f (this[idx + 1]));\n        default: {\n          const m = Math.floor (n / 4) * 2;\n          return Z.lift2 (concat, go (idx, m), go (idx + m, n - m));\n        }\n      }\n    };\n    return this.length % 2 === 1 ?\n      Z.lift2 (\n        concat,\n        Z.map (Array$of, f (this[0])), go (1, this.length - 1)\n      ) :\n      go (0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map ((_, idx, xs) => f (xs.slice (idx)));\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call (this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call (this, other);\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return Z.equals (this.name, other.name) &&\n           Z.equals (this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  const Object$empty = () => ({});\n\n  //  Object$zero :: () -> StrMap a\n  const Object$zero = () => ({});\n\n  //  Object$prototype$equals :: Setoid a => StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    const keys = sortedKeys (this);\n    return Z.equals (keys, sortedKeys (other)) &&\n           keys.every (k => Z.equals (this[k], other[k]));\n  }\n\n  //  Object$prototype$lte :: Ord a => StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    const theseKeys = sortedKeys (this);\n    const otherKeys = sortedKeys (other);\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      const k = theseKeys.shift ();\n      const z = otherKeys.shift ();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!(Z.equals (this[k], other[k]))) return Z.lte (this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    const result = {};\n    (Object.keys (this)).forEach (k => { result[k] = this[k]; });\n    (Object.keys (other)).forEach (k => { result[k] = other[k]; });\n    return result;\n  }\n\n  //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a\n  function Object$prototype$filter(pred) {\n    const result = {};\n    (Object.keys (this)).forEach (k => {\n      if (pred (this[k])) result[k] = this[k];\n    });\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    const result = {};\n    (Object.keys (this)).forEach (k => { result[k] = f (this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    const result = {};\n    (Object.keys (this)).forEach (k => {\n      if (has (k, other)) result[k] = other[k] (this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  const Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    return sortedKeys (this)\n           .reduce ((acc, k) => f (acc, this[k]), initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    return Object.keys (this)\n           .reduce (\n             (applicative, k) => (\n               Z.lift2 (\n                 o => v => Object$prototype$concat.call (o, {[k]: v}),\n                 applicative,\n                 f (this[k])\n               )\n             ),\n             Z.of (typeRep, {})\n           );\n  }\n\n  //  Function$id :: () -> a -> a\n  const Function$id = () => identity;\n\n  //  Function$of :: b -> (a -> b)\n  const Function$of = x => _ => x;\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  const Function$chainRec = (f, x) => a => {\n    let step = iterationNext (x);\n    while (!step.done) step = f (iterationNext, iterationDone, step.value) (a);\n    return step.value;\n  };\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    return x => other (this (x));\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    return x => f (this (x));\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    return x => g (this (f (x)));\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    return x => f (x) (this (x));\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    return x => f (this (x)) (x);\n  }\n\n  //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)\n  function Function$prototype$extend(f) {\n    return x => f (y => this (Z.concat (x, y)));\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    return x => this (f (x));\n  }\n\n  const staticMethod = (name, implementations, typeRep) => {\n    switch (typeRep) {\n      case String: return implementations.String;\n      case Array: return implementations.Array;\n      case Object: return implementations.Object;\n      case Function: return implementations.Function;\n    }\n\n    const prefixedName = 'fantasy-land/' + name;\n    if (typeof typeRep[prefixedName] === 'function') {\n      return typeRep[prefixedName];\n    }\n\n    switch (typeRep.name) {\n      case 'String': return implementations.String;\n      case 'Array': return implementations.Array;\n      case 'Object': return implementations.Object;\n      case 'Function': return implementations.Function;\n    }\n  };\n\n  const hasPrototypeMethod = (name, implementations, value) => {\n    switch (value) {\n      case null: return implementations.Null != null;\n      case undefined: return implementations.Undefined != null;\n    }\n\n    const prefixedName = 'fantasy-land/' + name;\n    const isPrototype = value.constructor == null ||\n                        value.constructor.prototype !== value;\n    if (isPrototype && typeof value[prefixedName] === 'function') {\n      return true;\n    }\n\n    if (typeof value['@@type'] === 'string') return false;\n\n    if (name === 'equals') {\n      if (value.constructor === Array || type (value) === 'Array') {\n        return value.every (Z.Setoid.test);\n      }\n\n      if (value.constructor === Object || type (value) === 'Object') {\n        return (Object.values (value)).every (Z.Setoid.test);\n      }\n    }\n\n    if (name === 'lte') {\n      if (value.constructor === Array || type (value) === 'Array') {\n        return value.every (Z.Ord.test);\n      }\n\n      if (value.constructor === Object || type (value) === 'Object') {\n        return (Object.values (value)).every (Z.Ord.test);\n      }\n    }\n\n    return customPrototypeMethod (implementations, value) != null;\n  };\n\n  const prototypeMethod = (name, implementations, value) => {\n    // Single-member types are identified most quickly.\n    switch (value) {\n      case null: return implementations.Null;\n      case undefined: return implementations.Undefined;\n    }\n\n    // Check if we can dispatch to a Fantasy Land method.\n    const prefixedName = 'fantasy-land/' + name;\n    const isPrototype = value.constructor == null ||\n                        value.constructor.prototype !== value;\n    if (isPrototype && typeof value[prefixedName] === 'function') {\n      return value[prefixedName];\n    }\n\n    // Separate function for performance reasons.\n    return customPrototypeMethod (implementations, value);\n  };\n\n  const customPrototypeMethod = (implementations, value) => {\n    // Checking constructor reference has the best performance.\n    switch (value.constructor) {\n      case Boolean: return implementations.Boolean;\n      case Number: return implementations.Number;\n      case Date: return implementations.Date;\n      case RegExp: return implementations.RegExp;\n      case String: return implementations.String;\n      case Array: return implementations.Array;\n      case Function: return implementations.Function;\n    }\n\n    // For all other values we use their type-identity.\n    switch (type (value)) {\n      case 'Arguments': return implementations.Arguments;\n      case 'Error': return implementations.Error;\n      case 'Object': return implementations.Object;\n\n      // A repeat of the constructor-matched values, in case they were created\n      // in other contexts (e.g. vm.runInNewContext).\n      case 'Boolean': return implementations.Boolean;\n      case 'Number': return implementations.Number;\n      case 'Date': return implementations.Date;\n      case 'RegExp': return implementations.RegExp;\n      case 'String': return implementations.String;\n      case 'Array': return implementations.Array;\n      case 'Function': return implementations.Function;\n    }\n  };\n\n  const Z = {};\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass (\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod ('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass (\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod ('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  Z.TypeClass = (name, url, dependencies, test) => ({\n    '@@type': 'sanctuary-type-classes/TypeClass@1',\n    'name': name,\n    'url': url,\n    'test': x => dependencies.every (d => d.test (x)) && test (x),\n  });\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  const Constructor = 'Constructor';\n\n  //  Value :: Location\n  const Value = 'Value';\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  const $ = (_name, dependencies, requirements) => {\n    const version = '12.1.0';  // updated programmatically\n\n    const staticMethods = requirements.filter (req => (\n      req.location === Constructor\n    ));\n\n    const prototypeMethods = requirements.filter (req => (\n      req.location === Value\n    ));\n\n    const typeClass = Z.TypeClass (\n      `sanctuary-type-classes/${_name}`,\n      `https://github.com/sanctuary-js/sanctuary-type-classes/tree/v${version}#${_name}`,\n      dependencies,\n      ($seen => x => {\n        if ($seen.includes (x)) return true;\n\n        $seen.push (x);\n        try {\n          return (\n            staticMethods.every (({name, implementations}) => (\n              x != null &&\n              staticMethod (name, implementations, x.constructor) != null\n            )) &&\n            prototypeMethods.every (({name, implementations}) => (\n              hasPrototypeMethod (name, implementations, x)\n            ))\n          );\n        } finally {\n          $seen.pop ();\n        }\n      }) ([])\n    );\n\n    typeClass.methods = {};\n\n    staticMethods.forEach (({name, arity, implementations}) => {\n      typeClass.methods[name] = (\n        arity === 0 ? typeRep => (\n          staticMethod (name, implementations, typeRep) ()\n        ) :\n        arity === 1 ? (typeRep, a) => (\n          staticMethod (name, implementations, typeRep) (a)\n        ) :\n        (typeRep, a, b) => (\n          staticMethod (name, implementations, typeRep) (a, b)\n        )\n      );\n    });\n\n    prototypeMethods.forEach (({name, arity, implementations}) => {\n      typeClass.methods[name] = (\n        arity === 0 ? context => (\n          (prototypeMethod (name, implementations, context)).call (context)\n        ) :\n        arity === 1 ? (a, context) => (\n          (prototypeMethod (name, implementations, context)).call (context, a)\n        ) :\n        (a, b, context) => (\n          (prototypeMethod (name, implementations, context))\n          .call (context, a, b)\n        )\n      );\n    });\n\n    return typeClass;\n  };\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Z.Setoid.test (null)\n  //. true\n  //.\n  //. > Z.Setoid.test (Useless)\n  //. false\n  //.\n  //. > Z.Setoid.test ([1, 2, 3])\n  //. true\n  //.\n  //. > Z.Setoid.test ([Useless])\n  //. false\n  //. ```\n  Z.Setoid = $ ('Setoid', [], [{\n    name: 'equals',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Arguments: Arguments$prototype$equals,\n      Array: Array$prototype$equals,\n      Boolean: Boolean$prototype$equals,\n      Date: Date$prototype$equals,\n      Error: Error$prototype$equals,\n      Function: Function$prototype$equals,\n      Null: Null$prototype$equals,\n      Number: Number$prototype$equals,\n      Object: Object$prototype$equals,\n      RegExp: RegExp$prototype$equals,\n      String: String$prototype$equals,\n      Undefined: Undefined$prototype$equals,\n    },\n  }]);\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Z.Ord.test (0)\n  //. true\n  //.\n  //. > Z.Ord.test (Math.sqrt)\n  //. false\n  //.\n  //. > Z.Ord.test ([1, 2, 3])\n  //. true\n  //.\n  //. > Z.Ord.test ([Math.sqrt])\n  //. false\n  //. ```\n  Z.Ord = $ ('Ord', [Z.Setoid], [{\n    name: 'lte',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Arguments: Arguments$prototype$lte,\n      Array: Array$prototype$lte,\n      Boolean: Boolean$prototype$lte,\n      Date: Date$prototype$lte,\n      Null: Null$prototype$lte,\n      Number: Number$prototype$lte,\n      Object: Object$prototype$lte,\n      String: String$prototype$lte,\n      Undefined: Undefined$prototype$lte,\n    },\n  }]);\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Z.Semigroupoid.test (Math.sqrt)\n  //. true\n  //.\n  //. > Z.Semigroupoid.test (0)\n  //. false\n  //. ```\n  Z.Semigroupoid = $ ('Semigroupoid', [], [{\n    name: 'compose',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Function: Function$prototype$compose,\n    },\n  }]);\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Z.Category.test (Math.sqrt)\n  //. true\n  //.\n  //. > Z.Category.test (0)\n  //. false\n  //. ```\n  Z.Category = $ ('Category', [Z.Semigroupoid], [{\n    name: 'id',\n    location: Constructor,\n    arity: 0,\n    implementations: {\n      Function: Function$id,\n    },\n  }]);\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Z.Semigroup.test ('')\n  //. true\n  //.\n  //. > Z.Semigroup.test (0)\n  //. false\n  //. ```\n  Z.Semigroup = $ ('Semigroup', [], [{\n    name: 'concat',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$concat,\n      Object: Object$prototype$concat,\n      String: String$prototype$concat,\n    },\n  }]);\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Z.Monoid.test ('')\n  //. true\n  //.\n  //. > Z.Monoid.test (0)\n  //. false\n  //. ```\n  Z.Monoid = $ ('Monoid', [Z.Semigroup], [{\n    name: 'empty',\n    location: Constructor,\n    arity: 0,\n    implementations: {\n      Array: Array$empty,\n      Object: Object$empty,\n      String: String$empty,\n    },\n  }]);\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Z.Group.test (Sum (0))\n  //. true\n  //.\n  //. > Z.Group.test ('')\n  //. false\n  //. ```\n  Z.Group = $ ('Group', [Z.Monoid], [{\n    name: 'invert',\n    location: Value,\n    arity: 0,\n    implementations: {},\n  }]);\n\n  //# Filterable :: TypeClass\n  //.\n  //. `TypeClass` value for [Filterable][].\n  //.\n  //. ```javascript\n  //. > Z.Filterable.test ({})\n  //. true\n  //.\n  //. > Z.Filterable.test ('')\n  //. false\n  //. ```\n  Z.Filterable = $ ('Filterable', [], [{\n    name: 'filter',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$filter,\n      Object: Object$prototype$filter,\n    },\n  }]);\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Z.Functor.test ([])\n  //. true\n  //.\n  //. > Z.Functor.test ('')\n  //. false\n  //. ```\n  Z.Functor = $ ('Functor', [], [{\n    name: 'map',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$map,\n      Function: Function$prototype$map,\n      Object: Object$prototype$map,\n    },\n  }]);\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Z.Bifunctor.test (Pair ('foo') (64))\n  //. true\n  //.\n  //. > Z.Bifunctor.test ([])\n  //. false\n  //. ```\n  Z.Bifunctor = $ ('Bifunctor', [Z.Functor], [{\n    name: 'bimap',\n    location: Value,\n    arity: 2,\n    implementations: {},\n  }]);\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Z.Profunctor.test (Math.sqrt)\n  //. true\n  //.\n  //. > Z.Profunctor.test ([])\n  //. false\n  //. ```\n  Z.Profunctor = $ ('Profunctor', [Z.Functor], [{\n    name: 'promap',\n    location: Value,\n    arity: 2,\n    implementations: {\n      Function: Function$prototype$promap,\n    },\n  }]);\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Z.Apply.test ([])\n  //. true\n  //.\n  //. > Z.Apply.test ('')\n  //. false\n  //. ```\n  Z.Apply = $ ('Apply', [Z.Functor], [{\n    name: 'ap',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$ap,\n      Function: Function$prototype$ap,\n      Object: Object$prototype$ap,\n    },\n  }]);\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Z.Applicative.test ([])\n  //. true\n  //.\n  //. > Z.Applicative.test ({})\n  //. false\n  //. ```\n  Z.Applicative = $ ('Applicative', [Z.Apply], [{\n    name: 'of',\n    location: Constructor,\n    arity: 1,\n    implementations: {\n      Array: Array$of,\n      Function: Function$of,\n    },\n  }]);\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Z.Chain.test ([])\n  //. true\n  //.\n  //. > Z.Chain.test ({})\n  //. false\n  //. ```\n  Z.Chain = $ ('Chain', [Z.Apply], [{\n    name: 'chain',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$chain,\n      Function: Function$prototype$chain,\n    },\n  }]);\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > Z.ChainRec.test ([])\n  //. true\n  //.\n  //. > Z.ChainRec.test ({})\n  //. false\n  //. ```\n  Z.ChainRec = $ ('ChainRec', [Z.Chain], [{\n    name: 'chainRec',\n    location: Constructor,\n    arity: 2,\n    implementations: {\n      Array: Array$chainRec,\n      Function: Function$chainRec,\n    },\n  }]);\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Z.Monad.test ([])\n  //. true\n  //.\n  //. > Z.Monad.test ({})\n  //. false\n  //. ```\n  Z.Monad = $ ('Monad', [Z.Applicative, Z.Chain], []);\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Z.Alt.test ({})\n  //. true\n  //.\n  //. > Z.Alt.test ('')\n  //. false\n  //. ```\n  Z.Alt = $ ('Alt', [Z.Functor], [{\n    name: 'alt',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$alt,\n      Object: Object$prototype$alt,\n    },\n  }]);\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Z.Plus.test ({})\n  //. true\n  //.\n  //. > Z.Plus.test ('')\n  //. false\n  //. ```\n  Z.Plus = $ ('Plus', [Z.Alt], [{\n    name: 'zero',\n    location: Constructor,\n    arity: 0,\n    implementations: {\n      Array: Array$zero,\n      Object: Object$zero,\n    },\n  }]);\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Z.Alternative.test ([])\n  //. true\n  //.\n  //. > Z.Alternative.test ({})\n  //. false\n  //. ```\n  Z.Alternative = $ ('Alternative', [Z.Applicative, Z.Plus], []);\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Z.Foldable.test ({})\n  //. true\n  //.\n  //. > Z.Foldable.test ('')\n  //. false\n  //. ```\n  Z.Foldable = $ ('Foldable', [], [{\n    name: 'reduce',\n    location: Value,\n    arity: 2,\n    implementations: {\n      Array: Array$prototype$reduce,\n      Object: Object$prototype$reduce,\n    },\n  }]);\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Z.Traversable.test ([])\n  //. true\n  //.\n  //. > Z.Traversable.test ('')\n  //. false\n  //. ```\n  Z.Traversable = $ ('Traversable', [Z.Functor, Z.Foldable], [{\n    name: 'traverse',\n    location: Value,\n    arity: 2,\n    implementations: {\n      Array: Array$prototype$traverse,\n      Object: Object$prototype$traverse,\n    },\n  }]);\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Z.Extend.test ([])\n  //. true\n  //.\n  //. > Z.Extend.test ({})\n  //. false\n  //. ```\n  Z.Extend = $ ('Extend', [Z.Functor], [{\n    name: 'extend',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Array: Array$prototype$extend,\n      Function: Function$prototype$extend,\n    },\n  }]);\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Z.Comonad.test (Identity (0))\n  //. true\n  //.\n  //. > Z.Comonad.test ([])\n  //. false\n  //. ```\n  Z.Comonad = $ ('Comonad', [Z.Extend], [{\n    name: 'extract',\n    location: Value,\n    arity: 0,\n    implementations: {},\n  }]);\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Z.Contravariant.test (Math.sqrt)\n  //. true\n  //.\n  //. > Z.Contravariant.test ([])\n  //. false\n  //. ```\n  Z.Contravariant = $ ('Contravariant', [], [{\n    name: 'contramap',\n    location: Value,\n    arity: 1,\n    implementations: {\n      Function: Function$prototype$contramap,\n    },\n  }]);\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are equal; `false` otherwise.\n  //.\n  //. Specifically:\n  //.\n  //.   - Arguments with different [type identities][] are unequal.\n  //.\n  //.   - If the first argument has a [`fantasy-land/equals`][] method,\n  //.     that method is invoked to determine whether the arguments are\n  //.     equal (`fantasy-land/equals` implementations are provided for the\n  //.     following built-in types: Null, Undefined, Boolean, Number, Date,\n  //.     RegExp, String, Array, Arguments, Error, Object, and Function).\n  //.\n  //.   - Otherwise, the arguments are equal if their\n  //.     [entries][`Object.entries`] are equal (according to this algorithm).\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > Z.equals (0, -0)\n  //. true\n  //.\n  //. > Z.equals (NaN, NaN)\n  //. true\n  //.\n  //. > Z.equals (Cons (1, Cons (2, Nil)), Cons (1, Cons (2, Nil)))\n  //. true\n  //.\n  //. > Z.equals (Cons (1, Cons (2, Nil)), Cons (2, Cons (1, Nil)))\n  //. false\n  //. ```\n  {\n    //  $pairs :: Array (Array2 Any Any)\n    const $pairs = [];\n\n    Z.equals = (x, y) => {\n      if (!(sameType (x, y))) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some (([xx, yy]) => xx === x && yy === y)) {\n        return true;\n      }\n\n      $pairs.push ([x, y]);\n      try {\n        return Z.Setoid.test (x) ?\n               Z.Setoid.methods.equals (y, x) :\n               Object$prototype$equals.call (x, y);\n      } finally {\n        $pairs.pop ();\n      }\n    };\n  }\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > Z.lt (0, 0)\n  //. false\n  //.\n  //. > Z.lt (0, 1)\n  //. true\n  //.\n  //. > Z.lt (1, 0)\n  //. false\n  //. ```\n  Z.lt = (x, y) => sameType (x, y) && !(Z.lte (y, x));\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > Z.lte (0, 0)\n  //. true\n  //.\n  //. > Z.lte (0, 1)\n  //. true\n  //.\n  //. > Z.lte (1, 0)\n  //. false\n  //. ```\n  {\n    //  $pairs :: Array (Array2 Any Any)\n    const $pairs = [];\n\n    Z.lte = (x, y) => {\n      if (!(sameType (x, y))) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some (([xx, yy]) => xx === x && yy === y)) {\n        return Z.equals (x, y);\n      }\n\n      $pairs.push ([x, y]);\n      try {\n        return Z.Ord.test (x) && Z.Ord.methods.lte (y, x);\n      } finally {\n        $pairs.pop ();\n      }\n    };\n  }\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > Z.gt (0, 0)\n  //. false\n  //.\n  //. > Z.gt (0, 1)\n  //. false\n  //.\n  //. > Z.gt (1, 0)\n  //. true\n  //. ```\n  Z.gt = (x, y) => Z.lt (y, x);\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > Z.gte (0, 0)\n  //. true\n  //.\n  //. > Z.gte (0, 1)\n  //. false\n  //.\n  //. > Z.gte (1, 0)\n  //. true\n  //. ```\n  Z.gte = (x, y) => Z.lte (y, x);\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > Z.min (10, 2)\n  //. 2\n  //.\n  //. > Z.min (new Date ('1999-12-31'), new Date ('2000-01-01'))\n  //. new Date ('1999-12-31')\n  //.\n  //. > Z.min ('10', '2')\n  //. '10'\n  //. ```\n  Z.min = (x, y) => Z.lte (x, y) ? x : y;\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > Z.max (10, 2)\n  //. 10\n  //.\n  //. > Z.max (new Date ('1999-12-31'), new Date ('2000-01-01'))\n  //. new Date ('2000-01-01')\n  //.\n  //. > Z.max ('10', '2')\n  //. '2'\n  //. ```\n  Z.max = (x, y) => Z.lte (x, y) ? y : x;\n\n  //# clamp :: Ord a => (a, a, a) -> a\n  //.\n  //. Takes a lower bound, an upper bound, and a value of the same type.\n  //. Returns the value if it is within the bounds; the nearer bound otherwise.\n  //.\n  //. This function is derived from [`min`](#min) and [`max`](#max).\n  //.\n  //. ```javascript\n  //. > Z.clamp (0, 100, 42)\n  //. 42\n  //.\n  //. > Z.clamp (0, 100, -1)\n  //. 0\n  //.\n  //. > Z.clamp ('A', 'Z', '~')\n  //. 'Z'\n  //. ```\n  Z.clamp = (lower, upper, x) => Z.max (lower, Z.min (upper, x));\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > Z.compose (Math.sqrt, x => x + 1) (99)\n  //. 10\n  //. ```\n  Z.compose = Z.Semigroupoid.methods.compose;\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > Z.id (Function) ('foo')\n  //. 'foo'\n  //. ```\n  Z.id = Z.Category.methods.id;\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > Z.concat ('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > Z.concat ([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > Z.concat ({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > Z.concat (Cons ('foo', Cons ('bar', Cons ('baz', Nil))), Cons ('quux', Nil))\n  //. Cons ('foo', Cons ('bar', Cons ('baz', Cons ('quux', Nil))))\n  //. ```\n  Z.concat = (a, b) => Z.Semigroup.methods.concat (b, a);\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > Z.empty (String)\n  //. ''\n  //.\n  //. > Z.empty (Array)\n  //. []\n  //.\n  //. > Z.empty (Object)\n  //. {}\n  //.\n  //. > Z.empty (List)\n  //. Nil\n  //. ```\n  Z.empty = Z.Monoid.methods.empty;\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. > Z.invert (Sum (5))\n  //. Sum (-5)\n  //. ```\n  Z.invert = Z.Group.methods.invert;\n\n  //# filter :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/filter`][]. Discards every element\n  //. which does not satisfy the predicate.\n  //.\n  //. `fantasy-land/filter` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > Z.filter (x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > Z.filter (x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > Z.filter (x => x % 2 == 1, Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (1, Cons (3, Nil))\n  //.\n  //. > Z.filter (x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > Z.filter (x => x % 2 == 1, Just (0))\n  //. Nothing\n  //.\n  //. > Z.filter (x => x % 2 == 1, Just (1))\n  //. Just (1)\n  //. ```\n  Z.filter = Z.Filterable.methods.filter;\n\n  //# reject :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards every element which satisfies the predicate.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > Z.reject (x => x % 2 == 1, [1, 2, 3])\n  //. [2]\n  //.\n  //. > Z.reject (x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > Z.reject (x => x % 2 == 1, Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (2, Nil)\n  //.\n  //. > Z.reject (x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > Z.reject (x => x % 2 == 1, Just (0))\n  //. Just (0)\n  //.\n  //. > Z.reject (x => x % 2 == 1, Just (1))\n  //. Nothing\n  //. ```\n  Z.reject = (pred, filterable) => Z.filter (x => !(pred (x)), filterable);\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > Z.map (Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > Z.map (Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > Z.map (Math.sqrt, s => s.length) ('Sanctuary')\n  //. 3\n  //.\n  //. > Z.map (Math.sqrt, Pair ('foo') (64))\n  //. Pair ('foo') (8)\n  //.\n  //. > Z.map (Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > Z.map (Math.sqrt, Cons (1, Cons (4, Cons (9, Nil))))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  Z.map = Z.Functor.methods.map;\n\n  //# flip :: Functor f => (f (a -> b), a) -> f b\n  //.\n  //. Maps over the given functions, applying each to the given value.\n  //.\n  //. This function is derived from [`map`](#map).\n  //.\n  //. ```javascript\n  //. > Z.flip (x => y => x + y, '!') ('foo')\n  //. 'foo!'\n  //.\n  //. > Z.flip ([Math.floor, Math.ceil], 1.5)\n  //. [1, 2]\n  //.\n  //. > Z.flip ({floor: Math.floor, ceil: Math.ceil}, 1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > Z.flip (Cons (Math.floor, Cons (Math.ceil, Nil)), 1.5)\n  //. Cons (1, Cons (2, Nil))\n  //. ```\n  Z.flip = (functor, x) => Z.map (f => f (x), functor);\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > Z.bimap (s => s.toUpperCase (), Math.sqrt, Pair ('foo') (64))\n  //. Pair ('FOO') (8)\n  //. ```\n  Z.bimap = Z.Bifunctor.methods.bimap;\n\n  //# mapLeft :: Bifunctor f => (a -> b, f a c) -> f b c\n  //.\n  //. Maps the given function over the left side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > Z.mapLeft (Math.sqrt, Pair (64) (9))\n  //. Pair (8) (9)\n  //. ```\n  Z.mapLeft = (f, bifunctor) => Z.bimap (f, identity, bifunctor);\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > Z.promap (Math.abs, x => x + 1, Math.sqrt) (-100)\n  //. 11\n  //. ```\n  Z.promap = Z.Profunctor.methods.promap;\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > Z.ap ([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > Z.ap ({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > Z.ap (s => n => s.slice (0, n), s => Math.ceil (s.length / 2)) ('Haskell')\n  //. 'Hask'\n  //.\n  //. > Z.ap (Identity (Math.sqrt), Identity (64))\n  //. Identity (8)\n  //.\n  //. > Z.ap (Cons (Math.sqrt, Cons (x => x * x, Nil)), Cons (16, Cons (100, Nil)))\n  //. Cons (4, Cons (10, Cons (256, Cons (10000, Nil))))\n  //. ```\n  Z.ap = Z.Apply.methods.ap;\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > Z.lift2 (x => y => Math.pow (x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > Z.lift2 (x => y => Math.pow (x, y), Identity (10), Identity (3))\n  //. Identity (1000)\n  //. ```\n  Z.lift2 = (f, x, y) => Z.ap (Z.map (f, x), y);\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > Z.lift3 (x => y => z => x + z + y,\n  //. .          ['<', '['],\n  //. .          ['>', ']'],\n  //. .          ['foo', 'bar', 'baz'])\n  //. [ '<foo>', '<bar>', '<baz>',\n  //. . '<foo]', '<bar]', '<baz]',\n  //. . '[foo>', '[bar>', '[baz>',\n  //. . '[foo]', '[bar]', '[baz]' ]\n  //.\n  //. > Z.lift3 (x => y => z => x + z + y,\n  //. .          Identity ('<'),\n  //. .          Identity ('>'),\n  //. .          Identity ('baz'))\n  //. Identity ('<baz>')\n  //. ```\n  Z.lift3 = (f, x, y, z) => Z.ap (Z.ap (Z.map (f, x), y), z);\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > Z.apFirst ([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > Z.apFirst (Identity (1), Identity (2))\n  //. Identity (1)\n  //. ```\n  Z.apFirst = (x, y) => Z.lift2 (x => y => x, x, y);\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > Z.apSecond ([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > Z.apSecond (Identity (1), Identity (2))\n  //. Identity (2)\n  //. ```\n  Z.apSecond = (x, y) => Z.lift2 (x => y => y, x, y);\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > Z.of (Array, 42)\n  //. [42]\n  //.\n  //. > Z.of (Function, 42) (null)\n  //. 42\n  //.\n  //. > Z.of (List, 42)\n  //. Cons (42, Nil)\n  //. ```\n  Z.of = Z.Applicative.methods.of;\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > Z.append (3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > Z.append (3, Cons (1, Cons (2, Nil)))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  Z.append = (x, xs) => Z.concat (xs, Z.of (xs.constructor, x));\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > Z.prepend (1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > Z.prepend (1, Cons (2, Cons (3, Nil)))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  Z.prepend = (x, xs) => Z.concat (Z.of (xs.constructor, x), xs);\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > Z.chain (x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > Z.chain (x => x % 2 == 1 ? Z.of (List, x) : Nil,\n  //. .          Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (1, Cons (3, Nil))\n  //.\n  //. > Z.chain (n => s => s.slice (0, n),\n  //. .          s => Math.ceil (s.length / 2))\n  //. .         ('Haskell')\n  //. 'Hask'\n  //. ```\n  Z.chain = Z.Chain.methods.chain;\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > Z.join ([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > Z.join ([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > Z.join (Identity (Identity (1)))\n  //. Identity (1)\n  //. ```\n  Z.join = chain => Z.chain (identity, chain);\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > Z.chainRec (\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map (done)\n  //. .                                    : [s + 'o', s + 'n'].map (next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  Z.chainRec = Z.ChainRec.methods.chainRec;\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > Z.alt ([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > Z.alt (Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > Z.alt (Nothing, Just (1))\n  //. Just (1)\n  //.\n  //. > Z.alt (Just (2), Just (3))\n  //. Just (2)\n  //. ```\n  Z.alt = (a, b) => Z.Alt.methods.alt (b, a);\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > Z.zero (Array)\n  //. []\n  //.\n  //. > Z.zero (Object)\n  //. {}\n  //.\n  //. > Z.zero (Maybe)\n  //. Nothing\n  //. ```\n  Z.zero = Z.Plus.methods.zero;\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > Z.reduce ((xs, x) => [x].concat (xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > Z.reduce (Z.concat, '', Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. 'foobarbaz'\n  //.\n  //. > Z.reduce (Z.concat, '', {foo: 'x', bar: 'y', baz: 'z'})\n  //. 'yzx'\n  //. ```\n  Z.reduce = Z.Foldable.methods.reduce;\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > Z.size ([])\n  //. 0\n  //.\n  //. > Z.size (['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > Z.size (Nil)\n  //. 0\n  //.\n  //. > Z.size (Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. 3\n  //. ```\n  Z.size = foldable => (\n    Array.isArray (foldable)\n    ? foldable.length\n    : Z.reduce ((n, _) => n + 1, 0, foldable)\n  );\n\n  //# all :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if all the elements of the structure satisfy the\n  //. predicate; `false` otherwise.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. See also [`any`](#any) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > Z.all (Number.isInteger, [])\n  //. true\n  //.\n  //. > Z.all (Number.isInteger, [1, 2, 3])\n  //. true\n  //.\n  //. > Z.all (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. false\n  //. ```\n  Z.all = (pred, foldable) => (\n    Array.isArray (foldable)\n    ? foldable.every (x => pred (x))\n    : Z.reduce ((b, x) => b && pred (x), true, foldable)\n  );\n\n  //# any :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if any element of the structure satisfies the predicate;\n  //. `false` otherwise.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. See also [`all`](#all) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > Z.any (Number.isInteger, [])\n  //. false\n  //.\n  //. > Z.any (Number.isInteger, [1, 2, 3])\n  //. true\n  //.\n  //. > Z.any (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. true\n  //. ```\n  Z.any = (pred, foldable) => (\n    Array.isArray (foldable)\n    ? foldable.some (x => pred (x))\n    : Z.reduce ((b, x) => b || pred (x), false, foldable)\n  );\n\n  //# none :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if none of the elements of the structure satisfies the\n  //. predicate; `false` otherwise.\n  //.\n  //. This function is derived from [`any`](#any). `Z.none (pred, foldable)` is\n  //. equivalent to `!(Z.any (pred, foldable))`.\n  //.\n  //. See also [`all`](#all).\n  //.\n  //. ```javascript\n  //. > Z.none (Number.isInteger, [])\n  //. true\n  //.\n  //. > Z.none (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. false\n  //. ```\n  Z.none = (pred, foldable) => !(Z.any (pred, foldable));\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > Z.elem ('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > Z.elem ('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > Z.elem (3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > Z.elem (8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > Z.elem (0, Just (0))\n  //. true\n  //.\n  //. > Z.elem (0, Just (1))\n  //. false\n  //.\n  //. > Z.elem (0, Nothing)\n  //. false\n  //. ```\n  Z.elem = (x, foldable) => Z.any (y => Z.equals (x, y), foldable);\n\n  //# intercalate :: (Monoid m, Foldable f) => (m, f m) -> m\n  //.\n  //. Concatenates the elements of the given structure, separating each pair\n  //. of adjacent elements with the given separator.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > Z.intercalate (', ', [])\n  //. ''\n  //.\n  //. > Z.intercalate (', ', ['foo', 'bar', 'baz'])\n  //. 'foo, bar, baz'\n  //.\n  //. > Z.intercalate (', ', Nil)\n  //. ''\n  //.\n  //. > Z.intercalate (', ', Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. 'foo, bar, baz'\n  //.\n  //. > Z.intercalate ([0, 0, 0], [])\n  //. []\n  //.\n  //. > Z.intercalate ([0, 0, 0], [[1], [2, 3], [4, 5, 6], [7, 8], [9]])\n  //. [1, 0, 0, 0, 2, 3, 0, 0, 0, 4, 5, 6, 0, 0, 0, 7, 8, 0, 0, 0, 9]\n  //. ```\n  Z.intercalate = (separator, foldable) => (\n    Z.reduce (\n      ({empty, value}, x) => ({\n        empty: false,\n        value: Z.concat (value, empty ? x : Z.concat (separator, x)),\n      }),\n      {empty: true, value: Z.empty (separator.constructor)},\n      foldable\n    )\n    .value\n  );\n\n  //# foldMap :: (Monoid m, Foldable f) => (TypeRep m, a -> m, f a) -> m\n  //.\n  //. Deconstructs a foldable by mapping every element to a monoid and\n  //. concatenating the results.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > Z.foldMap (String, f => f.name, [Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //. ```\n  Z.foldMap = (typeRep, f, foldable) => (\n    Z.reduce (\n      (monoid, x) => Z.concat (monoid, f (x)),\n      Z.empty (typeRep),\n      foldable\n    )\n  );\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > Z.reverse ([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > Z.reverse (Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (3, Cons (2, Cons (1, Nil)))\n  //. ```\n  Z.reverse = foldable => {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) return (foldable.slice ()).reverse ();\n    const F = foldable.constructor;\n    return Z.reduce (\n      (xs, x) => Z.concat (Z.of (F, x), xs),\n      Z.empty (F),\n      foldable\n    );\n  };\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > Z.sort (['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > Z.sort ([Just (2), Nothing, Just (1)])\n  //. [Nothing, Just (1), Just (2)]\n  //.\n  //. > Z.sort (Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. Cons ('bar', Cons ('baz', Cons ('foo', Nil)))\n  //. ```\n  Z.sort = foldable => Z.sortBy (identity, foldable);\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > Z.sortBy (s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > Z.sortBy (s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > Z.sortBy (s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > Z.sortBy (s => s.length, Cons ('red', Cons ('green', Cons ('blue', Nil))))\n  //. Cons ('red', Cons ('blue', Cons ('green', Nil)))\n  //. ```\n  Z.sortBy = (f, foldable) => {\n    const rs = Z.reduce ((rs, x) => {\n      rs.push ({idx: rs.length, x, fx: f (x)});\n      return rs;\n    }, [], foldable);\n\n    const lte = (r => {\n      switch (typeof (r && r.fx)) {\n        case 'number':  return (x, y) => x <= y || x !== x;\n        case 'string':  return (x, y) => x <= y;\n        default:        return Z.lte;\n      }\n    }) (rs[0]);\n\n    rs.sort ((a, b) => (\n      lte (a.fx, b.fx) ? lte (b.fx, a.fx) ? a.idx - b.idx : -1 : 1\n    ));\n\n    if (Array.isArray (foldable)) {\n      for (let idx = 0; idx < rs.length; idx += 1) rs[idx] = rs[idx].x;\n      return rs;\n    }\n\n    const F = foldable.constructor;\n    let result = Z.empty (F);\n    for (let idx = 0; idx < rs.length; idx += 1) {\n      result = Z.concat (result, Z.of (F, rs[idx].x));\n    }\n    return result;\n  };\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > Z.traverse (Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > Z.traverse (Identity, x => Identity (x + 1), [1, 2, 3])\n  //. Identity ([2, 3, 4])\n  //. ```\n  Z.traverse = Z.Traversable.methods.traverse;\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > Z.sequence (Array, Identity ([1, 2, 3]))\n  //. [Identity (1), Identity (2), Identity (3)]\n  //.\n  //. > Z.sequence (Identity, [Identity (1), Identity (2), Identity (3)])\n  //. Identity ([1, 2, 3])\n  //. ```\n  Z.sequence = (typeRep, traversable) => (\n    Z.traverse (typeRep, identity, traversable)\n  );\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > Z.extend (ss => ss.join (''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > Z.extend (f => f ([3, 4]), Z.reverse) ([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  Z.extend = Z.Extend.methods.extend;\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. This function is derived from [`extend`](#extend).\n  //.\n  //. ```javascript\n  //. > Z.duplicate (Identity (1))\n  //. Identity (Identity (1))\n  //.\n  //. > Z.duplicate ([1])\n  //. [[1]]\n  //.\n  //. > Z.duplicate ([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > Z.duplicate (Z.reverse) ([1, 2]) ([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  Z.duplicate = extend => Z.extend (identity, extend);\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > Z.extract (Identity (42))\n  //. 42\n  //. ```\n  Z.extract = Z.Comonad.methods.extract;\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > Z.contramap (s => s.length, Math.sqrt) ('Sanctuary')\n  //. 3\n  //. ```\n  Z.contramap = Z.Contravariant.methods.contramap;\n\n  return Z;\n\n});\n\n//. [Alt]:                      v:fantasyland/fantasy-land#alt\n//. [Alternative]:              v:fantasyland/fantasy-land#alternative\n//. [Applicative]:              v:fantasyland/fantasy-land#applicative\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Bifunctor]:                v:fantasyland/fantasy-land#bifunctor\n//. [Category]:                 v:fantasyland/fantasy-land#category\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [ChainRec]:                 v:fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  v:fantasyland/fantasy-land#comonad\n//. [Contravariant]:            v:fantasyland/fantasy-land#contravariant\n//. [Extend]:                   v:fantasyland/fantasy-land#extend\n//. [FL]:                       v:fantasyland/fantasy-land\n//. [Filterable]:               v:fantasyland/fantasy-land#filterable\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Functor]:                  v:fantasyland/fantasy-land#functor\n//. [Group]:                    v:fantasyland/fantasy-land#group\n//. [Monad]:                    v:fantasyland/fantasy-land#monad\n//. [Monoid]:                   v:fantasyland/fantasy-land#monoid\n//. [Ord]:                      v:fantasyland/fantasy-land#ord\n//. [Plus]:                     v:fantasyland/fantasy-land#plus\n//. [Profunctor]:               v:fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                v:fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   v:fantasyland/fantasy-land#setoid\n//. [Traversable]:              v:fantasyland/fantasy-land#traversable\n//. [`Object.entries`]:         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n//. [`fantasy-land/alt`]:       v:fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        v:fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     v:fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     v:fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  v:fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   v:fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    v:fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: v:fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     v:fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    v:fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    v:fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   v:fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/filter`]:    v:fantasyland/fantasy-land#filter-method\n//. [`fantasy-land/id`]:        v:fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    v:fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       v:fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       v:fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        v:fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    v:fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    v:fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  v:fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      v:fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type identities]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n","/*\n         _______    ___    _________    ___   ___    _______    ______\n        /  ____/\\  /  /\\  /__   ___/\\  /  /\\ /  /\\  /  ____/\\  /  __  \\\n       /  /\\___\\/ /  / /  \\_/  /\\__\\/ /  /_//  / / /  /\\___\\/ /  /\\/  /\\\n      /  ____/\\  /  / /    /  / /    /  ___   / / /  ____/\\  /      _/ /\n     /  /\\___\\/ /  / /    /  / /    /  /\\_/  / / /  /\\___\\/ /  /|  |\\\\/\n    /______/\\  /__/ /    /__/ /    /__/ //__/ / /______/\\  /__/ |__| |\n    \\______\\/  \\__\\/     \\__\\/     \\__\\/ \\__\\/  \\______\\/  \\__\\/ \\__\\|\n                                                                            */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-either\n//.\n//. The Either type represents values with two possibilities: a value of type\n//. `Either a b` is either a Left whose value is of type `a` or a Right whose\n//. value is of type `b`.\n\n(f => {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-show', 'sanctuary-type-classes'], f);\n  } else {\n    self.sanctuaryEither = f (self.sanctuaryShow,\n                              self.sanctuaryTypeClasses);\n  }\n\n}) ((show, Z) => {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars, no-var */\n    var S = __doctest.require ('sanctuary');\n    var $ = __doctest.require ('sanctuary-def');\n    /* eslint-enable no-unused-vars, no-var */\n  }\n\n  const eitherTypeIdent = 'sanctuary-either/Either@1';\n\n  const Either = {};\n\n  const Left$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Either,\n    'isLeft':                 true,\n    'isRight':                false,\n    '@@type':                 eitherTypeIdent,\n    '@@show':                 Left$prototype$show,\n    'fantasy-land/map':       Left$prototype$map,\n    'fantasy-land/bimap':     Left$prototype$bimap,\n    'fantasy-land/ap':        Left$prototype$ap,\n    'fantasy-land/chain':     Left$prototype$chain,\n    'fantasy-land/alt':       Left$prototype$alt,\n    'fantasy-land/reduce':    Left$prototype$reduce,\n    'fantasy-land/traverse':  Left$prototype$traverse,\n    'fantasy-land/extend':    Left$prototype$extend,\n    /* eslint-enable key-spacing */\n  };\n\n  const Right$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Either,\n    'isLeft':                 false,\n    'isRight':                true,\n    '@@type':                 eitherTypeIdent,\n    '@@show':                 Right$prototype$show,\n    'fantasy-land/map':       Right$prototype$map,\n    'fantasy-land/bimap':     Right$prototype$bimap,\n    'fantasy-land/ap':        Right$prototype$ap,\n    'fantasy-land/chain':     Right$prototype$chain,\n    'fantasy-land/alt':       Right$prototype$alt,\n    'fantasy-land/reduce':    Right$prototype$reduce,\n    'fantasy-land/traverse':  Right$prototype$traverse,\n    'fantasy-land/extend':    Right$prototype$extend,\n    /* eslint-enable key-spacing */\n  };\n\n  /* istanbul ignore else */\n  if (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  ) {\n    Left$prototype[\n      Symbol.for ('nodejs.util.inspect.custom')  // added in Node.js v10.12.0\n    ] = Left$prototype$show;\n    Right$prototype[\n      Symbol.for ('nodejs.util.inspect.custom')  // added in Node.js v10.12.0\n    ] = Right$prototype$show;\n  }\n  /* istanbul ignore if */\n  if (typeof Deno !== 'undefined') {\n    if (Deno != null && typeof Deno.customInspect === 'symbol') {\n      Left$prototype[Deno.customInspect] = Left$prototype$show;\n      Right$prototype[Deno.customInspect] = Right$prototype$show;\n    }\n  }\n\n  //. `Either a b` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Right (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Right (['foo'])) ? '\\u2705 * ' :\n  //. .              /* otherwise */               '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid           * ',  // if a and b satisfy Setoid\n  //. . 'Ord              * ',  // if a and b satisfy Ord\n  //. . 'Semigroupoid       ',\n  //. . 'Category           ',\n  //. . 'Semigroup        * ',  // if a and b satisfy Semigroup\n  //. . 'Monoid             ',\n  //. . 'Group              ',\n  //. . 'Filterable         ',\n  //. . 'Functor            ',\n  //. . 'Bifunctor          ',\n  //. . 'Profunctor         ',\n  //. . 'Apply              ',\n  //. . 'Applicative        ',\n  //. . 'Chain              ',\n  //. . 'ChainRec           ',\n  //. . 'Monad              ',\n  //. . 'Alt                ',\n  //. . 'Plus               ',\n  //. . 'Alternative        ',\n  //. . 'Foldable           ',\n  //. . 'Traversable        ',\n  //. . 'Extend             ',\n  //. . 'Comonad            ',\n  //. . 'Contravariant      ' ]\n  //. ```\n\n  //# Either :: TypeRep Either\n  //.\n  //. Either [type representative][].\n\n  //# Either.Left :: a -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > Left ('sqrt undefined for -1')\n  //. Left ('sqrt undefined for -1')\n  //. ```\n  const Left = Either.Left = value => {\n    const left = Object.create (Left$prototype);\n    if (Z.Setoid.test (value)) {\n      left['fantasy-land/equals'] = Left$prototype$equals;\n      if (Z.Ord.test (value)) {\n        left['fantasy-land/lte'] = Left$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      left['fantasy-land/concat'] = Left$prototype$concat;\n    }\n    left.value = value;\n    return left;\n  };\n\n  //# Either.Right :: b -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `b`.\n  //.\n  //. ```javascript\n  //. > Right (42)\n  //. Right (42)\n  //. ```\n  const Right = Either.Right = value => {\n    const right = Object.create (Right$prototype);\n    if (Z.Setoid.test (value)) {\n      right['fantasy-land/equals'] = Right$prototype$equals;\n      if (Z.Ord.test (value)) {\n        right['fantasy-land/lte'] = Right$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      right['fantasy-land/concat'] = Right$prototype$concat;\n    }\n    right.value = value;\n    return right;\n  };\n\n  //# Either.fantasy-land/of :: b -> Either a b\n  //.\n  //.   - `of (Either) (x)` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.of (Either) (42)\n  //. Right (42)\n  //. ```\n  Either['fantasy-land/of'] = Right;\n\n  const next = x => ({tag: next, value: x});\n  const done = x => ({tag: done, value: x});\n\n  //# Either.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Either d c, a) -> Either d b\n  //.\n  //. ```javascript\n  //. > Z.chainRec (\n  //. .   Either,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),\n  //. .   1\n  //. . )\n  //. Left ('!!')\n  //.\n  //. > Z.chainRec (\n  //. .   Either,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),\n  //. .   2\n  //. . )\n  //. Right (65536)\n  //. ```\n  Either['fantasy-land/chainRec'] = (f, x) => {\n    let r = next (x);\n    while (r.tag === next) {\n      const either = f (next, done, r.value);\n      if (either.isLeft) return either;\n      r = either.value;\n    }\n    return Right (r.value);\n  };\n\n  //# Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String\n  //.\n  //.   - `show (Left (x))` is equivalent to `'Left (' + show (x) + ')'`\n  //.   - `show (Right (x))` is equivalent to `'Right (' + show (x) + ')'`\n  //.\n  //. ```javascript\n  //. > S.show (Left ('sqrt undefined for -1'))\n  //. 'Left (\"sqrt undefined for -1\")'\n  //.\n  //. > S.show (Right ([1, 2, 3]))\n  //. 'Right ([1, 2, 3])'\n  //. ```\n  function Left$prototype$show() {\n    return 'Left (' + show (this.value) + ')';\n  }\n  function Right$prototype$show() {\n    return 'Right (' + show (this.value) + ')';\n  }\n\n  //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean\n  //.\n  //.   - `Left (x)` is equal to `Left (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Right (x)` is equal to `Right (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Left (x)` is never equal to `Right (y)`\n  //.\n  //. ```javascript\n  //. > S.equals (Left ([1, 2, 3])) (Left ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Right ([1, 2, 3])) (Right ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Left ([1, 2, 3])) (Right ([1, 2, 3]))\n  //. false\n  //. ```\n  function Left$prototype$equals(other) {\n    return other.isLeft && Z.equals (this.value, other.value);\n  }\n  function Right$prototype$equals(other) {\n    return other.isRight && Z.equals (this.value, other.value);\n  }\n\n  //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean\n  //.\n  //.   - `Left (x)` is less than or equal to `Left (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Right (x)` is less than or equal to `Right (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Left (x)` is always less than `Right (y)`\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Left (1))) ([Left (0), Left (1), Left (2)])\n  //. [Left (0), Left (1)]\n  //.\n  //. > S.filter (S.lte (Right (1))) ([Right (0), Right (1), Right (2)])\n  //. [Right (0), Right (1)]\n  //.\n  //. > S.filter (S.lte (Left (1))) ([Right (0), Right (1), Right (2)])\n  //. []\n  //.\n  //. > S.filter (S.lte (Right (1))) ([Left (0), Left (1), Left (2)])\n  //. [Left (0), Left (1), Left (2)]\n  //. ```\n  function Left$prototype$lte(other) {\n    return other.isRight || Z.lte (this.value, other.value);\n  }\n  function Right$prototype$lte(other) {\n    return other.isRight && Z.lte (this.value, other.value);\n  }\n\n  //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b\n  //.\n  //.   - `concat (Left (x)) (Left (y))` is equivalent to\n  //.     `Left (concat (x) (y))`\n  //.   - `concat (Right (x)) (Right (y))` is equivalent to\n  //.     `Right (concat (x) (y))`\n  //.   - `concat (Left (x)) (Right (y))` is equivalent to `Right (y)`\n  //.   - `concat (Right (x)) (Left (y))` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.concat (Left ('abc')) (Left ('def'))\n  //. Left ('abcdef')\n  //.\n  //. > S.concat (Right ([1, 2, 3])) (Right ([4, 5, 6]))\n  //. Right ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Left ('abc')) (Right ([1, 2, 3]))\n  //. Right ([1, 2, 3])\n  //.\n  //. > S.concat (Right ([1, 2, 3])) (Left ('abc'))\n  //. Right ([1, 2, 3])\n  //. ```\n  function Left$prototype$concat(other) {\n    return other.isLeft ? Left (Z.concat (this.value, other.value)) : other;\n  }\n  function Right$prototype$concat(other) {\n    return other.isRight ? Right (Z.concat (this.value, other.value)) : this;\n  }\n\n  //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c\n  //.\n  //.   - `map (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `map (f) (Right (x))` is equivalent to `Right (f (x))`\n  //.\n  //. ```javascript\n  //. > S.map (S.add (1)) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.map (S.add (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$map(f) {\n    return this;\n  }\n  function Right$prototype$map(f) {\n    return Right (f (this.value));\n  }\n\n  //# Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d\n  //.\n  //.   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`\n  //.   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (S.add (1)) (Left ('abc'))\n  //. Left ('ABC')\n  //.\n  //. > S.bimap (S.toUpper) (S.add (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$bimap(f, g) {\n    return Left (f (this.value));\n  }\n  function Right$prototype$bimap(f, g) {\n    return Right (g (this.value));\n  }\n\n  //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c\n  //.\n  //.   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`\n  //.   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`\n  //.   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`\n  //.   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`\n  //.\n  //. ```javascript\n  //. > S.ap (Left ('div undefined for 0')) (Left ('sqrt undefined for -1'))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.ap (Left ('div undefined for 0')) (Right (99))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.ap (Right (S.add (1))) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.ap (Right (S.add (1))) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$ap(other) {\n    return other.isLeft ? other : this;\n  }\n  function Right$prototype$ap(other) {\n    return other.isLeft ? other : Right (other.value (this.value));\n  }\n\n  //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c\n  //.\n  //.   - `chain (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `chain (f) (Right (x))` is equivalent to `f (x)`\n  //.\n  //. ```javascript\n  //. > const sqrt = n => n < 0 ? Left ('sqrt undefined for ' + S.show (n))\n  //. .                         : Right (Math.sqrt (n))\n  //.\n  //. > S.chain (sqrt) (Left ('div undefined for 0'))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.chain (sqrt) (Right (-1))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.chain (sqrt) (Right (25))\n  //. Right (5)\n  //. ```\n  function Left$prototype$chain(f) {\n    return this;\n  }\n  function Right$prototype$chain(f) {\n    return f (this.value);\n  }\n\n  //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b\n  //.\n  //.   - `alt (Left (y)) (Left (x))` is equivalent to `Left (y)`\n  //.   - `alt (Right (y)) (Left (x))` is equivalent to `Right (y)`\n  //.   - `alt (Left (y)) (Right (x))` is equivalent to `Right (x)`\n  //.   - `alt (Right (y)) (Right (x))` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.alt (Left ('B')) (Left ('A'))\n  //. Left ('B')\n  //.\n  //. > S.alt (Right (1)) (Left ('C'))\n  //. Right (1)\n  //.\n  //. > S.alt (Left ('D')) (Right (2))\n  //. Right (2)\n  //.\n  //. > S.alt (Right (4)) (Right (3))\n  //. Right (3)\n  //. ```\n  function Left$prototype$alt(other) {\n    return other;\n  }\n  function Right$prototype$alt(other) {\n    return this;\n  }\n\n  //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c\n  //.\n  //.   - `reduce (f) (x) (Left (y))` is equivalent to `x`\n  //.   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ([1]) (Left ('sqrt undefined for -1'))\n  //. [1]\n  //.\n  //. > S.reduce (S.concat) ([1]) (Right ([2]))\n  //. [1, 2]\n  //. ```\n  function Left$prototype$reduce(f, x) {\n    return x;\n  }\n  function Right$prototype$reduce(f, x) {\n    return f (x, this.value);\n  }\n\n  //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)\n  //.\n  //.   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`\n  //.   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Left ('sqrt undefined for -1'))\n  //. [Left ('sqrt undefined for -1')]\n  //.\n  //. > S.traverse (Array) (S.words) (Right ('foo bar baz'))\n  //. [Right ('foo'), Right ('bar'), Right ('baz')]\n  //. ```\n  function Left$prototype$traverse(typeRep, f) {\n    return Z.of (typeRep, this);\n  }\n  function Right$prototype$traverse(typeRep, f) {\n    return Z.map (Right, f (this.value));\n  }\n\n  //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c\n  //.\n  //.   - `extend (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.extend (S.reduce (S.add) (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$extend(f) {\n    return this;\n  }\n  function Right$prototype$extend(f) {\n    return Right (f (this));\n  }\n\n  return Either;\n\n});\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n","/*              ___                 ______\n               /  /\\               /  ___/\\\n        ______/  / / _______    __/  /___\\/\n       /  ___   / / /  ___  \\  /_   __/\\\n      /  /\\_/  / / /  /__/  /\\ \\/  /\\_\\/\n     /  / //  / / /  ______/ / /  / /\n    /  /_//  / / /  /______\\/ /  / /\n    \\_______/ /  \\_______/\\  /__/ /\n     \\______\\/    \\______\\/  \\__*/\n\n//. # sanctuary-def\n//.\n//. sanctuary-def is a run-time type system for JavaScript. It facilitates\n//. the definition of curried JavaScript functions that are explicit about\n//. the number of arguments to which they may be applied and the types of\n//. those arguments.\n//.\n//. It is conventional to import the package as `$`:\n//.\n//. ```javascript\n//. const $ = require ('sanctuary-def');\n//. ```\n//.\n//. The next step is to define an environment. An environment is an array\n//. of [types][]. [`env`][] is an environment containing all the built-in\n//. JavaScript types. It may be used as the basis for environments that\n//. include custom types in addition to the built-in types:\n//.\n//. ```javascript\n//. //    Integer :: Type\n//. const Integer = '...';\n//.\n//. //    NonZeroInteger :: Type\n//. const NonZeroInteger = '...';\n//.\n//. //    env :: Array Type\n//. const env = $.env.concat ([Integer, NonZeroInteger]);\n//. ```\n//.\n//. Type constructors such as `List :: Type -> Type` cannot be included in\n//. an environment as they're not of the correct type. One could, though,\n//. use a type constructor to define a fixed number of concrete types:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat ([\n//.   List ($.Number),                // :: Type\n//.   List ($.String),                // :: Type\n//.   List (List ($.Number)),         // :: Type\n//.   List (List ($.String)),         // :: Type\n//.   List (List (List ($.Number))),  // :: Type\n//.   List (List (List ($.String))),  // :: Type\n//. ]);\n//. ```\n//.\n//. Not only would this be tedious, but one could never enumerate all possible\n//. types as there are infinitely many. Instead, one should use [`Unknown`][]:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat ([List ($.Unknown)]);\n//. ```\n//.\n//. The next step is to define a `def` function for the environment using\n//. `$.create`:\n//.\n//. ```javascript\n//. //    def :: String -> StrMap (Array TypeClass) -> Array Type -> Function -> Function\n//. const def = $.create ({checkTypes: true, env});\n//. ```\n//.\n//. The `checkTypes` option determines whether type checking is enabled.\n//. This allows one to only pay the performance cost of run-time type checking\n//. during development. For example:\n//.\n//. ```javascript\n//. //    def :: String -> StrMap (Array TypeClass) -> Array Type -> Function -> Function\n//. const def = $.create ({\n//.   checkTypes: process.env.NODE_ENV === 'development',\n//.   env,\n//. });\n//. ```\n//.\n//. `def` is a function for defining functions. For example:\n//.\n//. ```javascript\n//. //    add :: Number -> Number -> Number\n//. const add =\n//. def ('add')                           // name\n//.     ({})                              // type-class constraints\n//.     ([$.Number, $.Number, $.Number])  // input and output types\n//.     (x => y => x + y);                // implementation\n//. ```\n//.\n//. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments\n//. of type `Number`, one at a time, and returns a value of type `Number`.\n//.\n//. Applying `add` to two arguments, one at a time, gives the expected result:\n//.\n//. ```javascript\n//. add (2) (2);\n//. // => 4\n//. ```\n//.\n//. Applying `add` to multiple arguments at once results in an exception being\n//. thrown:\n//.\n//. ```javascript\n//. add (2, 2, 2);\n//. // ! TypeError: add applied to the wrong number of arguments\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   Expected one argument but received three arguments:\n//. //\n//. //     - 2\n//. //     - 2\n//. //     - 2\n//. ```\n//.\n//. Applying `add` to one argument produces a function awaiting the remaining\n//. argument. This is known as partial application. Partial application allows\n//. more specific functions to be defined in terms of more general ones:\n//.\n//. ```javascript\n//. //    inc :: Number -> Number\n//. const inc = add (1);\n//.\n//. inc (7);\n//. // => 8\n//. ```\n//.\n//. JavaScript's implicit type coercion often obfuscates the source of type\n//. errors. Consider the following function:\n//.\n//. ```javascript\n//. //    _add :: Number -> Number -> Number\n//. const _add = x => y => x + y;\n//. ```\n//.\n//. The type signature indicates that `_add` takes arguments of type `Number`,\n//. but this is not enforced. This allows type errors to be silently ignored:\n//.\n//. ```javascript\n//. _add ('2') ('2');\n//. // => '22'\n//. ```\n//.\n//. `add`, on the other hand, throws if applied to arguments of the wrong\n//. types:\n//.\n//. ```javascript\n//. add ('2') ('2');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"2\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n//.\n//. Type checking is performed as arguments are provided (rather than once all\n//. arguments have been provided), so type errors are reported early:\n//.\n//. ```javascript\n//. add ('X');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"X\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-either'),\n                        require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'),\n                        require ('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-either',\n             'sanctuary-show',\n             'sanctuary-type-classes',\n             'sanctuary-type-identifiers'],\n            f);\n  } else {\n    self.sanctuaryDef = f (self.sanctuaryEither,\n                           self.sanctuaryShow,\n                           self.sanctuaryTypeClasses,\n                           self.sanctuaryTypeIdentifiers);\n  }\n\n} (function(Either, show, Z, type) {\n\n  'use strict';\n\n  var MAX_SAFE_INTEGER = Math.pow (2, 53) - 1;\n  var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n  var slice             = Array.prototype.slice;\n  var hasOwnProperty    = Object.prototype.hasOwnProperty;\n  var toString          = Object.prototype.toString;\n\n  //  Left :: a -> Either a b\n  var Left = Either.Left;\n\n  //  Right :: b -> Either a b\n  var Right = Either.Right;\n\n  //  lefts :: (Filterable f, Functor f) => f (Either a b) -> f a\n  var lefts = Z.compose (map (prop ('value')), filter (prop ('isLeft')));\n\n  //  B :: (b -> c) -> (a -> b) -> a -> c\n  function B(f) {\n    return function(g) {\n      return function(x) {\n        return f (g (x));\n      };\n    };\n  }\n\n  //  I :: a -> a\n  function I(x) { return x; }\n\n  //  K :: a -> b -> a\n  function K(x) { return function(y) { return x; }; }\n\n  //  always0 :: a -> () -> a\n  function always0(x) { return function() { return x; }; }\n\n  //  always2 :: a -> (b, c) -> a\n  function always2(x) { return function(y, z) { return x; }; }\n\n  //  complement :: (a -> Boolean) -> a -> Boolean\n  function complement(pred) { return function(x) { return !(pred (x)); }; }\n\n  //  filter :: Filterable f => (a -> Boolean) -> f a -> f a\n  function filter(pred) {\n    return function(xs) {\n      return Z.filter (pred, xs);\n    };\n  }\n\n  //  map :: Functor f => (a -> b) -> f a -> f b\n  function map(f) {\n    return function(xs) {\n      return Z.map (f, xs);\n    };\n  }\n\n  //  init :: Array a -> Array a\n  function init(xs) { return xs.slice (0, -1); }\n\n  //  isEmpty :: Foldable f => f a -> Boolean\n  function isEmpty(xs) { return Z.size (xs) === 0; }\n\n  //  isPrefix :: Array a -> Array a -> Boolean\n  function isPrefix(candidate) {\n    return function(xs) {\n      if (candidate.length > xs.length) return false;\n      for (var idx = 0; idx < candidate.length; idx += 1) {\n        if (candidate[idx] !== xs[idx]) return false;\n      }\n      return true;\n    };\n  }\n\n  //  joinWith :: (String, Array String) -> String\n  function joinWith(separator, ss) {\n    return ss.join (separator);\n  }\n\n  //  last :: Array a -> a\n  function last(xs) { return xs[xs.length - 1]; }\n\n  //  memberOf :: Array a -> a -> Boolean\n  function memberOf(xs) {\n    return function(y) {\n      return xs.some (function(x) { return Z.equals (x, y); });\n    };\n  }\n\n  //  or :: (Array a, Array a) -> Array a\n  function or(xs, ys) { return isEmpty (xs) ? ys : xs; }\n\n  //  prop :: String -> {} -> a\n  function prop(field) { return function(record) { return record[field]; }; }\n\n  //  sizeEq :: Foldable f => Integer -> f a -> Boolean\n  function sizeEq(n) { return function(xs) { return Z.size (xs) === n; }; }\n\n  //  strRepeat :: (String, Integer) -> String\n  function strRepeat(s, times) {\n    return joinWith (s, Array (times + 1));\n  }\n\n  //  r :: Char -> String -> String\n  function r(c) {\n    return function(s) {\n      return strRepeat (c, s.length);\n    };\n  }\n\n  //  _ :: String -> String\n  var _ = r (' ');\n\n  //  sortedKeys :: Object -> Array String\n  function sortedKeys(o) {\n    return (Object.keys (o)).sort ();\n  }\n\n  //  toArray :: Foldable f => f a -> Array a\n  function toArray(foldable) {\n    return Array.isArray (foldable) ?\n           foldable :\n           Z.reduce (function(xs, x) { xs.push (x); return xs; },\n                     [],\n                     foldable);\n  }\n\n  //  toMarkdownList :: (String, String, a -> String, Array a) -> String\n  function toMarkdownList(empty, s, f, xs) {\n    return isEmpty (xs) ?\n      empty :\n      Z.reduce (function(s, x) { return s + '  - ' + f (x) + '\\n'; }, s, xs);\n  }\n\n  //  trimTrailingSpaces :: String -> String\n  function trimTrailingSpaces(s) {\n    return s.replace (/[ ]+$/gm, '');\n  }\n\n  //  when :: Boolean -> (a -> a) -> a -> a\n  function when(bool) {\n    return function(f) {\n      return function(x) {\n        return bool ? f (x) : x;\n      };\n    };\n  }\n\n  //  wrap :: String -> String -> String -> String\n  function wrap(prefix) {\n    return function(suffix) {\n      return function(s) {\n        return prefix + s + suffix;\n      };\n    };\n  }\n\n  //  parenthesize :: (String -> String) -> String -> String\n  function parenthesize(f) { return wrap (f ('(')) (f (')')); }\n\n  //  q :: String -> String\n  var q = wrap ('\\u2018') ('\\u2019');\n\n  //  stripNamespace :: TypeClass -> String\n  function stripNamespace(typeClass) {\n    return typeClass.name.slice (typeClass.name.indexOf ('/') + 1);\n  }\n\n  function _test(env) {\n    return function(x) {\n      return function recur(t) {\n        return t.supertypes.every (recur) && t._test (env) (x);\n      };\n    };\n  }\n\n  var Type$prototype = {\n    '@@type': 'sanctuary-def/Type@1',\n    '@@show': function() {\n      return this.format (I, K (I));\n    },\n    'validate': function(env) {\n      var test2 = _test (env);\n      var type = this;\n      return function(x) {\n        if (!(test2 (x) (type))) return Left ({value: x, propPath: []});\n        for (var idx = 0; idx < type.keys.length; idx += 1) {\n          var k = type.keys[idx];\n          var t = type.types[k];\n          var ys = type.extractors[k] (x);\n          for (var idx2 = 0; idx2 < ys.length; idx2 += 1) {\n            var result = t.validate (env) (ys[idx2]);\n            if (result.isLeft) {\n              return Left ({value: result.value.value,\n                            propPath: Z.concat ([k], result.value.propPath)});\n            }\n          }\n        }\n        return Right (x);\n      };\n    },\n    'fantasy-land/equals': function(other) {\n      return (\n        Z.equals (this.type, other.type) &&\n        Z.equals (this.name, other.name) &&\n        Z.equals (this.url, other.url) &&\n        Z.equals (this.supertypes, other.supertypes) &&\n        this.keys.length === other.keys.length &&\n        this.keys.every (function(k) { return other.keys.includes (k); }) &&\n        Z.equals (this.types, other.types)\n      );\n    }\n  };\n\n  //  _Type :: ... -> Type\n  function _Type(\n    type,       // :: String\n    name,       // :: String\n    url,        // :: String\n    arity,      // :: NonNegativeInteger\n    format,\n    // :: Nullable ((String -> String, String -> String -> String) -> String)\n    supertypes, // :: Array Type\n    test,       // :: Any -> Boolean\n    tuples      // :: Array (Array3 String (a -> Array b) Type)\n  ) {\n    var t = Object.create (Type$prototype);\n    t._test = test;\n    t._extractors = tuples.reduce (function(_extractors, tuple) {\n      _extractors[tuple[0]] = tuple[1];\n      return _extractors;\n    }, {});\n    t.arity = arity;  // number of type parameters\n    t.extractors = Z.map (B (toArray), t._extractors);\n    t.format = format || function(outer, inner) {\n      return Z.reduce (function(s, tuple) {\n        return s +\n               outer (' ') +\n               when (tuple[2].arity > 0)\n                    (parenthesize (outer))\n                    (inner (tuple[0]) (show (tuple[2])));\n      }, outer (name), tuples);\n    };\n    t.keys = tuples.map (function(tuple) { return tuple[0]; });\n    t.name = name;\n    t.supertypes = supertypes;\n    t.type = type;\n    t.types = tuples.reduce (function(types, tuple) {\n      types[tuple[0]] = tuple[2];\n      return types;\n    }, {});\n    t.url = url;\n    return t;\n  }\n\n  var BINARY        = 'BINARY';\n  var FUNCTION      = 'FUNCTION';\n  var INCONSISTENT  = 'INCONSISTENT';\n  var NO_ARGUMENTS  = 'NO_ARGUMENTS';\n  var NULLARY       = 'NULLARY';\n  var RECORD        = 'RECORD';\n  var UNARY         = 'UNARY';\n  var UNKNOWN       = 'UNKNOWN';\n  var VARIABLE      = 'VARIABLE';\n\n  //  Inconsistent :: Type\n  var Inconsistent =\n  _Type (INCONSISTENT, '', '', 0, always2 ('???'), [], K (K (false)), []);\n\n  //  NoArguments :: Type\n  var NoArguments =\n  _Type (NO_ARGUMENTS, '', '', 0, always2 ('()'), [], K (K (true)), []);\n\n  //  arityGte :: NonNegativeInteger -> Type -> Boolean\n  function arityGte(n) {\n    return function(t) {\n      return t.arity >= n;\n    };\n  }\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(name) {\n    return function(x) {\n      return type (x) === name;\n    };\n  }\n\n  //  typeofEq :: String -> a -> Boolean\n  function typeofEq(typeof_) {\n    return function(x) {\n      // eslint-disable-next-line valid-typeof\n      return typeof x === typeof_;\n    };\n  }\n\n  //  functionUrl :: String -> String\n  function functionUrl(name) {\n    var version = '0.22.0';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary-def/tree/v' + version +\n           '#' + name;\n  }\n\n  var NullaryTypeWithUrl = Z.ap (NullaryType, functionUrl);\n  var UnaryTypeWithUrl = Z.ap (UnaryType, functionUrl);\n  var BinaryTypeWithUrl = Z.ap (BinaryType, functionUrl);\n\n  //. ### Types\n  //.\n  //. Conceptually, a type is a set of values. One can think of a value of\n  //. type `Type` as a function of type `Any -> Boolean` that tests values\n  //. for membership in the set (though this is an oversimplification).\n\n  //# Unknown :: Type\n  //.\n  //. Type used to represent missing type information. The type of `[]`,\n  //. for example, is `Array ???`.\n  //.\n  //. May be used with type constructors when defining environments. Given a\n  //. type constructor `List :: Type -> Type`, one could use `List ($.Unknown)`\n  //. to include an infinite number of types in an environment:\n  //.\n  //.   - `List Number`\n  //.   - `List String`\n  //.   - `List (List Number)`\n  //.   - `List (List String)`\n  //.   - `List (List (List Number))`\n  //.   - `List (List (List String))`\n  //.   - `...`\n  var Unknown =\n  _Type (UNKNOWN, '', '', 0, always2 ('Unknown'), [], K (K (true)), []);\n\n  //# Void :: Type\n  //.\n  //. Uninhabited type.\n  //.\n  //. May be used to convey that a type parameter of an algebraic data type\n  //. will not be used. For example, a future of type `Future Void String`\n  //. will never be rejected.\n  var Void = NullaryTypeWithUrl\n    ('Void')\n    ([])\n    (K (false));\n\n  //# Any :: Type\n  //.\n  //. Type comprising every JavaScript value.\n  var Any = NullaryTypeWithUrl\n    ('Any')\n    ([])\n    (K (true));\n\n  //# AnyFunction :: Type\n  //.\n  //. Type comprising every Function value.\n  var AnyFunction = NullaryTypeWithUrl\n    ('Function')\n    ([])\n    (typeofEq ('function'));\n\n  //# Arguments :: Type\n  //.\n  //. Type comprising every [`arguments`][arguments] object.\n  var Arguments = NullaryTypeWithUrl\n    ('Arguments')\n    ([])\n    (typeEq ('Arguments'));\n\n  //# Array :: Type -> Type\n  //.\n  //. Constructor for homogeneous Array types.\n  var Array_ = UnaryTypeWithUrl\n    ('Array')\n    ([])\n    (typeEq ('Array'))\n    (I);\n\n  //# Array0 :: Type\n  //.\n  //. Type whose sole member is `[]`.\n  var Array0 = NullaryTypeWithUrl\n    ('Array0')\n    ([Array_ (Unknown)])\n    (sizeEq (0));\n\n  //# Array1 :: Type -> Type\n  //.\n  //. Constructor for singleton Array types.\n  var Array1 = UnaryTypeWithUrl\n    ('Array1')\n    ([Array_ (Unknown)])\n    (sizeEq (1))\n    (I);\n\n  //# Array2 :: Type -> Type -> Type\n  //.\n  //. Constructor for heterogeneous Array types of length 2. `['foo', true]` is\n  //. a member of `Array2 String Boolean`.\n  var Array2 = BinaryTypeWithUrl\n    ('Array2')\n    ([Array_ (Unknown)])\n    (sizeEq (2))\n    (function(array2) { return [array2[0]]; })\n    (function(array2) { return [array2[1]]; });\n\n  //# Boolean :: Type\n  //.\n  //. Type comprising `true` and `false`.\n  var Boolean_ = NullaryTypeWithUrl\n    ('Boolean')\n    ([])\n    (typeofEq ('boolean'));\n\n  //# Buffer :: Type\n  //.\n  //. Type comprising every [Buffer][] object.\n  var Buffer_ = NullaryTypeWithUrl\n    ('Buffer')\n    ([])\n    (function(x) {\n       return typeof Buffer !== 'undefined' &&\n              // eslint-disable-next-line no-undef\n              Buffer.isBuffer (x);\n     });\n\n  //# Date :: Type\n  //.\n  //. Type comprising every Date value.\n  var Date_ = NullaryTypeWithUrl\n    ('Date')\n    ([])\n    (typeEq ('Date'));\n\n  //# ValidDate :: Type\n  //.\n  //. Type comprising every [`Date`][] value except `new Date (NaN)`.\n  var ValidDate = NullaryTypeWithUrl\n    ('ValidDate')\n    ([Date_])\n    (B (complement (isNaN)) (Number));\n\n  //# Descending :: Type -> Type\n  //.\n  //. [Descending][] type constructor.\n  var Descending = UnaryTypeWithUrl\n    ('Descending')\n    ([])\n    (typeEq ('sanctuary-descending/Descending@1'))\n    (I);\n\n  //# Either :: Type -> Type -> Type\n  //.\n  //. [Either][] type constructor.\n  var Either_ = BinaryTypeWithUrl\n    ('Either')\n    ([])\n    (typeEq ('sanctuary-either/Either@1'))\n    (function(either) { return either.isLeft ? [either.value] : []; })\n    (function(either) { return either.isLeft ? [] : [either.value]; });\n\n  //# Error :: Type\n  //.\n  //. Type comprising every Error value, including values of more specific\n  //. constructors such as [`SyntaxError`][] and [`TypeError`][].\n  var Error_ = NullaryTypeWithUrl\n    ('Error')\n    ([])\n    (typeEq ('Error'));\n\n  //# Fn :: Type -> Type -> Type\n  //.\n  //. Binary type constructor for unary function types. `$.Fn (I) (O)`\n  //. represents `I -> O`, the type of functions that take a value of\n  //. type `I` and return a value of type `O`.\n  function Fn($1) { return function($2) { return Function_ ([$1, $2]); }; }\n\n  //# Function :: NonEmpty (Array Type) -> Type\n  //.\n  //. Constructor for Function types.\n  //.\n  //. Examples:\n  //.\n  //.   - `$.Function ([$.Date, $.String])` represents the `Date -> String`\n  //.     type; and\n  //.   - `$.Function ([a, b, a])` represents the `(a, b) -> a` type.\n  function Function_(types) {\n    var tuples = Z.reduce (function(tuples, t) {\n      tuples.push (['$' + show (tuples.length + 1), K ([]), t]);\n      return tuples;\n    }, [], types);\n\n    function format(outer, inner) {\n      return when (tuples.length !== 2)\n                  (parenthesize (outer))\n                  (joinWith (outer (', '),\n                             Z.map (function(tuple) {\n                               return when (tuple[2].type === FUNCTION)\n                                           (parenthesize (outer))\n                                           (inner (tuple[0])\n                                                  (show (tuple[2])));\n                             }, init (tuples)))) +\n             outer (' -> ') +\n             inner ((last (tuples))[0])\n                   (show ((last (tuples))[2]));\n    }\n\n    return _Type (FUNCTION,\n                  '',\n                  '',\n                  types.length,\n                  format,\n                  [AnyFunction],\n                  K (K (true)),\n                  tuples);\n  }\n\n  //# HtmlElement :: Type\n  //.\n  //. Type comprising every [HTML element][].\n  var HtmlElement = NullaryTypeWithUrl\n    ('HtmlElement')\n    ([])\n    (function(x) {\n      return (x && x.toString && /^\\[object HTML.*Element\\]$/.test (x.toString ()) || false);\n    });\n\n  //# Identity :: Type -> Type\n  //.\n  //. [Identity][] type constructor.\n  var Identity = UnaryTypeWithUrl\n    ('Identity')\n    ([])\n    (typeEq ('sanctuary-identity/Identity@1'))\n    (I);\n\n  //# JsMap :: Type -> Type -> Type\n  //.\n  //. Constructor for native Map types. `$.JsMap ($.Number) ($.String)`,\n  //. for example, is the type comprising every native Map whose keys are\n  //. numbers and whose values are strings.\n  var JsMap = BinaryTypeWithUrl\n    ('JsMap')\n    ([])\n    (function(x) { return toString.call (x) === '[object Map]'; })\n    (function(jsMap) { return Array.from (jsMap.keys ()); })\n    (function(jsMap) { return Array.from (jsMap.values ()); });\n\n  //# JsSet :: Type -> Type\n  //.\n  //. Constructor for native Set types. `$.JsSet ($.Number)`, for example,\n  //. is the type comprising every native Set whose values are numbers.\n  var JsSet = UnaryTypeWithUrl\n    ('JsSet')\n    ([])\n    (function(x) { return toString.call (x) === '[object Set]'; })\n    (function(jsSet) { return Array.from (jsSet.values ()); });\n\n  //# Maybe :: Type -> Type\n  //.\n  //. [Maybe][] type constructor.\n  var Maybe = UnaryTypeWithUrl\n    ('Maybe')\n    ([])\n    (typeEq ('sanctuary-maybe/Maybe@1'))\n    (I);\n\n  //# Module :: Type\n  //.\n  //. Type comprising every ES module.\n  var Module = NullaryTypeWithUrl\n    ('Module')\n    ([])\n    (function(x) { return toString.call (x) === '[object Module]'; });\n\n  //# NonEmpty :: Type -> Type\n  //.\n  //. Constructor for non-empty types. `$.NonEmpty ($.String)`, for example, is\n  //. the type comprising every [`String`][] value except `''`.\n  //.\n  //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.\n  var NonEmpty = UnaryTypeWithUrl\n    ('NonEmpty')\n    ([])\n    (function(x) {\n       return Z.Monoid.test (x) &&\n              Z.Setoid.test (x) &&\n              !(Z.equals (x, Z.empty (x.constructor)));\n     })\n    (function(monoid) { return [monoid]; });\n\n  //# Null :: Type\n  //.\n  //. Type whose sole member is `null`.\n  var Null = NullaryTypeWithUrl\n    ('Null')\n    ([])\n    (typeEq ('Null'));\n\n  //# Nullable :: Type -> Type\n  //.\n  //. Constructor for types that include `null` as a member.\n  var Nullable = UnaryTypeWithUrl\n    ('Nullable')\n    ([])\n    (K (true))\n    (function(nullable) {\n       // eslint-disable-next-line eqeqeq\n       return nullable === null ? [] : [nullable];\n     });\n\n  //# Number :: Type\n  //.\n  //. Type comprising every primitive Number value (including `NaN`).\n  var Number_ = NullaryTypeWithUrl\n    ('Number')\n    ([])\n    (typeofEq ('number'));\n\n  function nonZero(x) { return x !== 0; }\n  function nonNegative(x) { return x >= 0; }\n  function positive(x) { return x > 0; }\n  function negative(x) { return x < 0; }\n\n  //# PositiveNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value greater than zero.\n  var PositiveNumber = NullaryTypeWithUrl\n    ('PositiveNumber')\n    ([Number_])\n    (positive);\n\n  //# NegativeNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value less than zero.\n  var NegativeNumber = NullaryTypeWithUrl\n    ('NegativeNumber')\n    ([Number_])\n    (negative);\n\n  //# ValidNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value except `NaN`.\n  var ValidNumber = NullaryTypeWithUrl\n    ('ValidNumber')\n    ([Number_])\n    (complement (isNaN));\n\n  //# NonZeroValidNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.\n  var NonZeroValidNumber = NullaryTypeWithUrl\n    ('NonZeroValidNumber')\n    ([ValidNumber])\n    (nonZero);\n\n  //# FiniteNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `Infinity` and\n  //. `-Infinity`.\n  var FiniteNumber = NullaryTypeWithUrl\n    ('FiniteNumber')\n    ([ValidNumber])\n    (isFinite);\n\n  //# NonZeroFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.\n  var NonZeroFiniteNumber = NullaryTypeWithUrl\n    ('NonZeroFiniteNumber')\n    ([FiniteNumber])\n    (nonZero);\n\n  //# PositiveFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value greater than zero.\n  var PositiveFiniteNumber = NullaryTypeWithUrl\n    ('PositiveFiniteNumber')\n    ([FiniteNumber])\n    (positive);\n\n  //# NegativeFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value less than zero.\n  var NegativeFiniteNumber = NullaryTypeWithUrl\n    ('NegativeFiniteNumber')\n    ([FiniteNumber])\n    (negative);\n\n  //# Integer :: Type\n  //.\n  //. Type comprising every integer in the range\n  //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].\n  var Integer = NullaryTypeWithUrl\n    ('Integer')\n    ([ValidNumber])\n    (function(x) {\n       return Math.floor (x) === x &&\n              x >= MIN_SAFE_INTEGER &&\n              x <= MAX_SAFE_INTEGER;\n     });\n\n  //# NonZeroInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value except `0` and `-0`.\n  var NonZeroInteger = NullaryTypeWithUrl\n    ('NonZeroInteger')\n    ([Integer])\n    (nonZero);\n\n  //# NonNegativeInteger :: Type\n  //.\n  //. Type comprising every non-negative [`Integer`][] value (including `-0`).\n  //. Also known as the set of natural numbers under ISO 80000-2:2009.\n  var NonNegativeInteger = NullaryTypeWithUrl\n    ('NonNegativeInteger')\n    ([Integer])\n    (nonNegative);\n\n  //# PositiveInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value greater than zero.\n  var PositiveInteger = NullaryTypeWithUrl\n    ('PositiveInteger')\n    ([Integer])\n    (positive);\n\n  //# NegativeInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value less than zero.\n  var NegativeInteger = NullaryTypeWithUrl\n    ('NegativeInteger')\n    ([Integer])\n    (negative);\n\n  //# Object :: Type\n  //.\n  //. Type comprising every \"plain\" Object value. Specifically, values\n  //. created via:\n  //.\n  //.   - object literal syntax;\n  //.   - [`Object.create`][]; or\n  //.   - the `new` operator in conjunction with `Object` or a custom\n  //.     constructor function.\n  var Object_ = NullaryTypeWithUrl\n    ('Object')\n    ([])\n    (typeEq ('Object'));\n\n  //# Pair :: Type -> Type -> Type\n  //.\n  //. [Pair][] type constructor.\n  var Pair = BinaryTypeWithUrl\n    ('Pair')\n    ([])\n    (typeEq ('sanctuary-pair/Pair@1'))\n    (function(pair) { return [pair.fst]; })\n    (function(pair) { return [pair.snd]; });\n\n  //# RegExp :: Type\n  //.\n  //. Type comprising every RegExp value.\n  var RegExp_ = NullaryTypeWithUrl\n    ('RegExp')\n    ([])\n    (typeEq ('RegExp'));\n\n  //# GlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.\n  //.\n  //. See also [`NonGlobalRegExp`][].\n  var GlobalRegExp = NullaryTypeWithUrl\n    ('GlobalRegExp')\n    ([RegExp_])\n    (prop ('global'));\n\n  //# NonGlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.\n  //.\n  //. See also [`GlobalRegExp`][].\n  var NonGlobalRegExp = NullaryTypeWithUrl\n    ('NonGlobalRegExp')\n    ([RegExp_])\n    (complement (prop ('global')));\n\n  //# StrMap :: Type -> Type\n  //.\n  //. Constructor for homogeneous Object types.\n  //.\n  //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;\n  //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.\n  var StrMap = UnaryTypeWithUrl\n    ('StrMap')\n    ([Object_])\n    (K (true))\n    (I);\n\n  //# String :: Type\n  //.\n  //. Type comprising every primitive String value.\n  var String_ = NullaryTypeWithUrl\n    ('String')\n    ([])\n    (typeofEq ('string'));\n\n  //# RegexFlags :: Type\n  //.\n  //. Type comprising the canonical RegExp flags:\n  //.\n  //.   - `''`\n  //.   - `'g'`\n  //.   - `'i'`\n  //.   - `'m'`\n  //.   - `'gi'`\n  //.   - `'gm'`\n  //.   - `'im'`\n  //.   - `'gim'`\n  var RegexFlags = NullaryTypeWithUrl\n    ('RegexFlags')\n    ([String_])\n    (function(s) { return /^g?i?m?$/.test (s); });\n\n  //# Symbol :: Type\n  //.\n  //. Type comprising every Symbol value.\n  var Symbol_ = NullaryTypeWithUrl\n    ('Symbol')\n    ([])\n    (typeofEq ('symbol'));\n\n  //# Type :: Type\n  //.\n  //. Type comprising every `Type` value.\n  var Type = NullaryTypeWithUrl\n    ('Type')\n    ([])\n    (typeEq ('sanctuary-def/Type@1'));\n\n  //# TypeClass :: Type\n  //.\n  //. Type comprising every [`TypeClass`][] value.\n  var TypeClass = NullaryTypeWithUrl\n    ('TypeClass')\n    ([])\n    (typeEq ('sanctuary-type-classes/TypeClass@1'));\n\n  //# Undefined :: Type\n  //.\n  //. Type whose sole member is `undefined`.\n  var Undefined = NullaryTypeWithUrl\n    ('Undefined')\n    ([])\n    (typeEq ('Undefined'));\n\n  //# env :: Array Type\n  //.\n  //. An array of [types][]:\n  //.\n  //.   - <code>[AnyFunction](#AnyFunction)</code>\n  //.   - <code>[Arguments](#Arguments)</code>\n  //.   - <code>[Array](#Array) ([Unknown][])</code>\n  //.   - <code>[Array2](#Array2) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[Boolean](#Boolean)</code>\n  //.   - <code>[Buffer](#Buffer)</code>\n  //.   - <code>[Date](#Date)</code>\n  //.   - <code>[Descending](#Descending) ([Unknown][])</code>\n  //.   - <code>[Either](#Either) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[Error](#Error)</code>\n  //.   - <code>[Fn](#Fn) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[HtmlElement](#HtmlElement)</code>\n  //.   - <code>[Identity](#Identity) ([Unknown][])</code>\n  //.   - <code>[JsMap](#JsMap) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[JsSet](#JsSet) ([Unknown][])</code>\n  //.   - <code>[Maybe](#Maybe) ([Unknown][])</code>\n  //.   - <code>[Module](#Module)</code>\n  //.   - <code>[Null](#Null)</code>\n  //.   - <code>[Number](#Number)</code>\n  //.   - <code>[Object](#Object)</code>\n  //.   - <code>[Pair](#Pair) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[RegExp](#RegExp)</code>\n  //.   - <code>[StrMap](#StrMap) ([Unknown][])</code>\n  //.   - <code>[String](#String)</code>\n  //.   - <code>[Symbol](#Symbol)</code>\n  //.   - <code>[Type](#Type)</code>\n  //.   - <code>[TypeClass](#TypeClass)</code>\n  //.   - <code>[Undefined](#Undefined)</code>\n  var env = [\n    AnyFunction,\n    Arguments,\n    Array_ (Unknown),\n    Array2 (Unknown) (Unknown),\n    Boolean_,\n    Buffer_,\n    Date_,\n    Descending (Unknown),\n    Either_ (Unknown) (Unknown),\n    Error_,\n    Fn (Unknown) (Unknown),\n    HtmlElement,\n    Identity (Unknown),\n    JsMap (Unknown) (Unknown),\n    JsSet (Unknown),\n    Maybe (Unknown),\n    Module,\n    Null,\n    Number_,\n    Object_,\n    Pair (Unknown) (Unknown),\n    RegExp_,\n    StrMap (Unknown),\n    String_,\n    Symbol_,\n    Type,\n    TypeClass,\n    Undefined\n  ];\n\n  //  Unchecked :: String -> Type\n  function Unchecked(s) { return NullaryType (s) ('') ([]) (K (true)); }\n\n  //  production :: Boolean\n  var production =\n    typeof process !== 'undefined' &&\n    /* global process:false */\n    process != null &&\n    process.env != null &&\n    process.env.NODE_ENV === 'production';\n\n  //  numbers :: Array String\n  var numbers = [\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine'\n  ];\n\n  //  numArgs :: Integer -> String\n  function numArgs(n) {\n    return (n < numbers.length ? numbers[n] : show (n)) + ' ' +\n           (n === 1 ? 'argument' : 'arguments');\n  }\n\n  //  expandUnknown\n  //  :: Array Type\n  //  -> Array Object\n  //  -> Any\n  //  -> (a -> Array b)\n  //  -> Type\n  //  -> Array Type\n  function expandUnknown(env) {\n    return function(seen) {\n      return function(value) {\n        return function(extractor) {\n          return function(type) {\n            return type.type === UNKNOWN ?\n                   _determineActualTypes (env, seen, extractor (value)) :\n                   [type];\n          };\n        };\n      };\n    };\n  }\n\n  //  _determineActualTypes :: ... -> Array Type\n  function _determineActualTypes(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    values          // :: Array Any\n  ) {\n    var expandUnknown4 = expandUnknown (env);\n\n    function refine(types, value) {\n      var seen$;\n      if (typeof value === 'object' && value != null ||\n          typeof value === 'function') {\n        //  Abort if a circular reference is encountered; add the current\n        //  object to the array of seen objects otherwise.\n        if (seen.indexOf (value) >= 0) return [];\n        seen$ = Z.concat (seen, [value]);\n      } else {\n        seen$ = seen;\n      }\n      var expandUnknown2 = expandUnknown4 (seen$) (value);\n      return Z.chain (function(t) {\n        return (\n          (t.validate (env) (value)).isLeft ?\n            [] :\n          t.type === UNARY ?\n            Z.map (fromUnaryType (t),\n                   expandUnknown2 (t.extractors.$1) (t.types.$1)) :\n          t.type === BINARY ?\n            Z.lift2 (fromBinaryType (t),\n                     expandUnknown2 (t.extractors.$1) (t.types.$1),\n                     expandUnknown2 (t.extractors.$2) (t.types.$2)) :\n          // else\n            [t]\n        );\n      }, types);\n    }\n\n    return isEmpty (values) ?\n      [Unknown] :\n      or (Z.reduce (refine, env, values), [Inconsistent]);\n  }\n\n  //  isConsistent :: Type -> Boolean\n  function isConsistent(t) {\n    return t.type === UNARY   ? isConsistent (t.types.$1) :\n           t.type === BINARY  ? isConsistent (t.types.$1) &&\n                                isConsistent (t.types.$2) :\n           /* else */           t.type !== INCONSISTENT;\n  }\n\n  //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesStrict(env, values) {\n    return Z.filter (isConsistent,\n                     _determineActualTypes (env, [], values));\n  }\n\n  //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesLoose(env, values) {\n    return Z.reject (function(t) { return t.type === INCONSISTENT; },\n                     _determineActualTypes (env, [], values));\n  }\n\n  //  TypeInfo = { name :: String\n  //             , constraints :: StrMap (Array TypeClass)\n  //             , types :: NonEmpty (Array Type) }\n  //\n  //  TypeVarMap = StrMap { types :: Array Type\n  //                      , valuesByPath :: StrMap (Array Any) }\n  //\n  //  PropPath = Array (Number | String)\n\n  //  updateTypeVarMap :: ... -> TypeVarMap\n  function updateTypeVarMap(\n    env,            // :: Array Type\n    typeVarMap,     // :: TypeVarMap\n    typeVar,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var $typeVarMap = {};\n    for (var typeVarName in typeVarMap) {\n      var entry = typeVarMap[typeVarName];\n      var $entry = {types: entry.types.slice (), valuesByPath: {}};\n      for (var k in entry.valuesByPath) {\n        $entry.valuesByPath[k] = entry.valuesByPath[k].slice ();\n      }\n      $typeVarMap[typeVarName] = $entry;\n    }\n    if (!(hasOwnProperty.call ($typeVarMap, typeVar.name))) {\n      $typeVarMap[typeVar.name] = {\n        types: Z.filter (arityGte (typeVar.arity), env),\n        valuesByPath: {}\n      };\n    }\n\n    var key = JSON.stringify (Z.concat ([index], propPath));\n    if (!(hasOwnProperty.call ($typeVarMap[typeVar.name].valuesByPath, key))) {\n      $typeVarMap[typeVar.name].valuesByPath[key] = [];\n    }\n\n    var isValid = test (env);\n\n    var expandUnknownStrict = B (B (B (filter (isConsistent))))\n                                (expandUnknown (env) ([]));\n\n    values.forEach (function(value) {\n      var expandUnknownStrict2 = expandUnknownStrict (value);\n      $typeVarMap[typeVar.name].valuesByPath[key].push (value);\n      $typeVarMap[typeVar.name].types = Z.chain (function(t) {\n        return (\n          !(isValid (t) (value)) ?\n            [] :\n          typeVar.arity === 0 && t.type === UNARY ?\n            Z.map (fromUnaryType (t),\n                   expandUnknownStrict2 (t.extractors.$1) (t.types.$1)) :\n          typeVar.arity === 0 && t.type === BINARY ?\n            Z.lift2 (fromBinaryType (t),\n                     expandUnknownStrict2 (t.extractors.$1) (t.types.$1),\n                     expandUnknownStrict2 (t.extractors.$2) (t.types.$2)) :\n          // else\n            [t]\n        );\n      }, $typeVarMap[typeVar.name].types);\n    });\n\n    return $typeVarMap;\n  }\n\n  //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String\n  function underlineTypeVars(typeInfo, valuesByPath) {\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var paths = Z.map (JSON.parse, sortedKeys (valuesByPath));\n    return underline (\n      typeInfo,\n      K (K (_)),\n      function(index) {\n        return function(f) {\n          return function(t) {\n            return function(propPath) {\n              var indexedPropPath = Z.concat ([index], propPath);\n              return function(s) {\n                if (paths.some (isPrefix (indexedPropPath))) {\n                  var key = JSON.stringify (indexedPropPath);\n                  if (!(hasOwnProperty.call (valuesByPath, key))) return s;\n                  if (!(isEmpty (valuesByPath[key]))) return f (s);\n                }\n                return _ (s);\n              };\n            };\n          };\n        };\n      }\n    );\n  }\n\n  //  satisfactoryTypes :: ... -> Either (() -> Error)\n  //                                     { typeVarMap :: TypeVarMap\n  //                                     , types :: Array Type }\n  function satisfactoryTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeVarMap,     // :: TypeVarMap\n    expType,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var recur = satisfactoryTypes;\n\n    for (var idx = 0; idx < values.length; idx += 1) {\n      var result = expType.validate (env) (values[idx]);\n      if (result.isLeft) {\n        return Left (function() {\n          return invalidValue (env,\n                               typeInfo,\n                               index,\n                               Z.concat (propPath, result.value.propPath),\n                               result.value.value);\n        });\n      }\n    }\n\n    switch (expType.type) {\n\n      case VARIABLE:\n        var typeVarName = expType.name;\n        var constraints = typeInfo.constraints;\n        if (hasOwnProperty.call (constraints, typeVarName)) {\n          var typeClasses = constraints[typeVarName];\n          for (idx = 0; idx < values.length; idx += 1) {\n            for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {\n              if (!(typeClasses[idx2].test (values[idx]))) {\n                return Left (function() {\n                  return typeClassConstraintViolation (\n                    env,\n                    typeInfo,\n                    typeClasses[idx2],\n                    index,\n                    propPath,\n                    values[idx],\n                    typeVarMap\n                  );\n                });\n              }\n            }\n          }\n        }\n\n        var typeVarMap$ = updateTypeVarMap (env,\n                                            typeVarMap,\n                                            expType,\n                                            index,\n                                            propPath,\n                                            values);\n\n        var okTypes = typeVarMap$[typeVarName].types;\n        return isEmpty (okTypes) ?\n          Left (function() {\n            return typeVarConstraintViolation (\n              env,\n              typeInfo,\n              index,\n              propPath,\n              typeVarMap$[typeVarName].valuesByPath\n            );\n          }) :\n          Z.reduce (function(e, t) {\n            return Z.chain (function(r) {\n              //  The `a` in `Functor f => f a` corresponds to the `a`\n              //  in `Maybe a` but to the `b` in `Either a b`. A type\n              //  variable's $1 will correspond to either $1 or $2 of\n              //  the actual type depending on the actual type's arity.\n              var offset = t.arity - expType.arity;\n              return expType.keys.reduce (function(e, k, idx) {\n                var extractor = t.extractors[t.keys[offset + idx]];\n                return Z.reduce (function(e, x) {\n                  return Z.chain (function(r) {\n                    return recur (env,\n                                  typeInfo,\n                                  r.typeVarMap,\n                                  expType.types[k],\n                                  index,\n                                  Z.concat (propPath, [k]),\n                                  [x]);\n                  }, e);\n                }, e, Z.chain (extractor, values));\n              }, Right (r));\n            }, e);\n          }, Right ({typeVarMap: typeVarMap$, types: okTypes}), okTypes);\n\n      case UNARY:\n        return Z.map (\n          function(result) {\n            return {\n              typeVarMap: result.typeVarMap,\n              types: Z.map (fromUnaryType (expType),\n                            or (result.types, [expType.types.$1]))\n            };\n          },\n          recur (env,\n                 typeInfo,\n                 typeVarMap,\n                 expType.types.$1,\n                 index,\n                 Z.concat (propPath, ['$1']),\n                 Z.chain (expType.extractors.$1, values))\n        );\n\n      case BINARY:\n        return Z.chain (\n          function(result) {\n            var $1s = result.types;\n            return Z.map (\n              function(result) {\n                var $2s = result.types;\n                return {\n                  typeVarMap: result.typeVarMap,\n                  types: Z.lift2 (fromBinaryType (expType),\n                                  or ($1s, [expType.types.$1]),\n                                  or ($2s, [expType.types.$2]))\n                };\n              },\n              recur (env,\n                     typeInfo,\n                     result.typeVarMap,\n                     expType.types.$2,\n                     index,\n                     Z.concat (propPath, ['$2']),\n                     Z.chain (expType.extractors.$2, values))\n            );\n          },\n          recur (env,\n                 typeInfo,\n                 typeVarMap,\n                 expType.types.$1,\n                 index,\n                 Z.concat (propPath, ['$1']),\n                 Z.chain (expType.extractors.$1, values))\n        );\n\n      case RECORD:\n        return Z.reduce (function(e, k) {\n          return Z.chain (function(r) {\n            return recur (env,\n                          typeInfo,\n                          r.typeVarMap,\n                          expType.types[k],\n                          index,\n                          Z.concat (propPath, [k]),\n                          Z.chain (expType.extractors[k], values));\n          }, e);\n        }, Right ({typeVarMap: typeVarMap, types: [expType]}), expType.keys);\n\n      default:\n        return Right ({typeVarMap: typeVarMap, types: [expType]});\n    }\n  }\n\n  //# test :: Array Type -> Type -> a -> Boolean\n  //.\n  //. Takes an environment, a type, and any value. Returns `true` if the value\n  //. is a member of the type; `false` otherwise.\n  //.\n  //. The environment is only significant if the type contains\n  //. [type variables][].\n  function test(env) {\n    return function(t) {\n      return function(x) {\n        var typeInfo = {name: 'name', constraints: {}, types: [t]};\n        return (satisfactoryTypes (env, typeInfo, {}, t, 0, [], [x])).isRight;\n      };\n    };\n  }\n\n  //# validate :: Type -> a -> Either (Array ValidationError) a\n  //.\n  //. Takes a type, and any value. Returns `Right a` if\n  //. the value is a member of the type;\n  //. `Left (Array ValidationError)` for each property\n  //. that is invalid. The first index in a `Left` array\n  //. is always named `$$`, which refers to the entire value.\n  function validate(t) {\n    return function(x) {\n      //  $$Result :: {value, propPath} e => Either e a\n      var $$Result = t.validate ([]) (x);\n\n      //  props :: Array (Either ValidationError TestObject)\n      var props = t.keys.map (function(p) {\n        return x == null\n          ? Left ({\n              error: 'MissingValue',\n              type: t.name || t.type,\n              name: p,\n              value: x\n            })\n          : Right ({\n              name: p,\n              type: t.types[p],\n              value: x[p]\n            });\n      });\n\n      //  validateTestObject :: TestObject -> Either ValidationError TestObject\n      var validateTestObject = Z.compose (function(p) {\n        if (p.result.isRight) {\n          return Right (p);\n        } else if (p.name in x) {\n          return Left ({\n            error: 'WrongValue',\n            // TODO: figure out what propPath really is\n            type: p.result.value.propPath.length > 0\n              ? p.type.types[p.result.value.propPath[0]].name\n              : p.type.name,\n            name: p.name,\n            value: p.value\n          });\n        } else {\n          return Left ({\n            error: 'MissingValue',\n            type: p.type.name,\n            name: p.name,\n            value: p.value\n          });\n        }\n      }, function(p) {\n        return {\n          name: p.name,\n          result: p.type.validate ([]) (p.value),\n          type: p.type,\n          value: p.value\n        };\n      });\n\n      if ($$Result.isLeft) {\n        //  tmp0 :: Array (ValidationError)\n        var tmp0 = lefts (Z.map (function(prop) {\n          return Z.chain (validateTestObject, prop);\n        }, props));\n\n        //  tmp1 :: Array (ValidationError)\n        var tmp1 = Z.prepend ({\n          error: 'WrongValue',\n          type: t.name || t.type,\n          name: '$$',\n          value: x\n        }, tmp0);\n\n        // return :: Left (Array ValidationError)\n        return Left (tmp1);\n      } else {\n        // return :: Right a\n        return $$Result;\n      }\n\n      // return Z.concat (\n      //   returnValue,\n      //   Z.filter (\n      //     either => either.isLeft,\n      //     Z.map (prop => Z.map (validateRights, prop), props))\n      // );\n    };\n  }\n\n  //. ### Type constructors\n  //.\n  //. sanctuary-def provides several functions for defining types.\n\n  //# NullaryType :: String -> String -> Array Type -> (Any -> Boolean) -> Type\n  //.\n  //. Type constructor for types with no type variables (such as [`Number`][]).\n  //.\n  //. To define a nullary type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`); and\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Integer :: Type\n  //. const Integer = $.NullaryType\n  //.   ('Integer')\n  //.   ('http://example.com/my-package#Integer')\n  //.   ([])\n  //.   (x => typeof x === 'number' &&\n  //.         Math.floor (x) === x &&\n  //.         x >= Number.MIN_SAFE_INTEGER &&\n  //.         x <= Number.MAX_SAFE_INTEGER);\n  //.\n  //. //    NonZeroInteger :: Type\n  //. const NonZeroInteger = $.NullaryType\n  //.   ('NonZeroInteger')\n  //.   ('http://example.com/my-package#NonZeroInteger')\n  //.   ([Integer])\n  //.   (x => x !== 0);\n  //.\n  //. //    rem :: Integer -> NonZeroInteger -> Integer\n  //. const rem =\n  //. def ('rem')\n  //.     ({})\n  //.     ([Integer, NonZeroInteger, Integer])\n  //.     (x => y => x % y);\n  //.\n  //. rem (42) (5);\n  //. // => 2\n  //.\n  //. rem (0.5);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //          ^^^^^^^\n  //. //             1\n  //. //\n  //. //   1)  0.5 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of Integer.\n  //. //\n  //. //   See http://example.com/my-package#Integer for information about the Integer type.\n  //.\n  //. rem (42) (0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //                     ^^^^^^^^^^^^^^\n  //. //                           1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of NonZeroInteger.\n  //. //\n  //. //   See http://example.com/my-package#NonZeroInteger for information about the NonZeroInteger type.\n  //. ```\n  function NullaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return _Type (NULLARY, name, url, 0, null, supertypes, K (test), []);\n        };\n      };\n    };\n  }\n\n  //# UnaryType :: Foldable f => String -> String -> Array Type -> (Any -> Boolean) -> (t a -> f a) -> Type -> Type\n  //.\n  //. Type constructor for types with one type variable (such as [`Array`][]).\n  //.\n  //. To define a unary type `t a` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`);\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t x` for some type `x`;\n  //.\n  //.   - a function that takes any value of type `t a` and returns the values\n  //.     of type `a` contained in the `t`; and\n  //.\n  //.   - the type of `a`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const show = require ('sanctuary-show');\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    maybeTypeIdent :: String\n  //. const maybeTypeIdent = 'my-package/Maybe';\n  //.\n  //. //    Maybe :: Type -> Type\n  //. const Maybe = $.UnaryType\n  //.   ('Maybe')\n  //.   ('http://example.com/my-package#Maybe')\n  //.   ([])\n  //.   (x => type (x) === maybeTypeIdent)\n  //.   (maybe => maybe.isJust ? [maybe.value] : []);\n  //.\n  //. //    Nothing :: Maybe a\n  //. const Nothing = {\n  //.   'isJust': false,\n  //.   'isNothing': true,\n  //.   '@@type': maybeTypeIdent,\n  //.   '@@show': () => 'Nothing',\n  //. };\n  //.\n  //. //    Just :: a -> Maybe a\n  //. const Just = x => ({\n  //.   'isJust': true,\n  //.   'isNothing': false,\n  //.   '@@type': maybeTypeIdent,\n  //.   '@@show': () => `Just (${show (x)})`,\n  //.   'value': x,\n  //. });\n  //.\n  //. //    fromMaybe :: a -> Maybe a -> a\n  //. const fromMaybe =\n  //. def ('fromMaybe')\n  //.     ({})\n  //.     ([a, Maybe (a), a])\n  //.     (x => m => m.isJust ? m.value : x);\n  //.\n  //. fromMaybe (0) (Just (42));\n  //. // => 42\n  //.\n  //. fromMaybe (0) (Nothing);\n  //. // => 0\n  //.\n  //. fromMaybe (0) (Just ('XXX'));\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   fromMaybe :: a -> Maybe a -> a\n  //. //                ^          ^\n  //. //                1          2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"XXX\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function UnaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return function(_1) {\n            return function($1) {\n              return _Type (UNARY,\n                            name,\n                            url,\n                            1,\n                            null,\n                            supertypes,\n                            K (test),\n                            [['$1', _1, $1]]);\n            };\n          };\n        };\n      };\n    };\n  }\n\n  //  fromUnaryType :: Type -> Type -> Type\n  function fromUnaryType(t) {\n    return UnaryType (t.name)\n                     (t.url)\n                     (t.supertypes)\n                     (t._test ([]))\n                     (t._extractors.$1);\n  }\n\n  //# BinaryType :: Foldable f => String -> String -> Array Type -> (Any -> Boolean) -> (t a b -> f a) -> (t a b -> f b) -> Type -> Type -> Type\n  //.\n  //. Type constructor for types with two type variables (such as\n  //. [`Array2`][]).\n  //.\n  //. To define a binary type `t a b` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`);\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t x y` for some types `x` and `y`;\n  //.\n  //.   - a function that takes any value of type `t a b` and returns the\n  //.     values of type `a` contained in the `t`;\n  //.\n  //.   - a function that takes any value of type `t a b` and returns the\n  //.     values of type `b` contained in the `t`;\n  //.\n  //.   - the type of `a`; and\n  //.\n  //.   - the type of `b`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    pairTypeIdent :: String\n  //. const pairTypeIdent = 'my-package/Pair';\n  //.\n  //. //    $Pair :: Type -> Type -> Type\n  //. const $Pair = $.BinaryType\n  //.   ('Pair')\n  //.   ('http://example.com/my-package#Pair')\n  //.   ([])\n  //.   (x => type (x) === pairTypeIdent)\n  //.   (({fst}) => [fst])\n  //.   (({snd}) => [snd]);\n  //.\n  //. //    Pair :: a -> b -> Pair a b\n  //. const Pair =\n  //. def ('Pair')\n  //.     ({})\n  //.     ([a, b, $Pair (a) (b)])\n  //.     (fst => snd => ({\n  //.        'fst': fst,\n  //.        'snd': snd,\n  //.        '@@type': pairTypeIdent,\n  //.        '@@show': () => `Pair (${show (fst)}) (${show (snd)})`,\n  //.      }));\n  //.\n  //. //    Rank :: Type\n  //. const Rank = $.NullaryType\n  //.   ('Rank')\n  //.   ('http://example.com/my-package#Rank')\n  //.   ([$.String])\n  //.   (x => /^(A|2|3|4|5|6|7|8|9|10|J|Q|K)$/.test (x));\n  //.\n  //. //    Suit :: Type\n  //. const Suit = $.NullaryType\n  //.   ('Suit')\n  //.   ('http://example.com/my-package#Suit')\n  //.   ([$.String])\n  //.   (x => /^[\\u2660\\u2663\\u2665\\u2666]$/.test (x));\n  //.\n  //. //    Card :: Type\n  //. const Card = $Pair (Rank) (Suit);\n  //.\n  //. //    showCard :: Card -> String\n  //. const showCard =\n  //. def ('showCard')\n  //.     ({})\n  //.     ([Card, $.String])\n  //.     (card => card.fst + card.snd);\n  //.\n  //. showCard (Pair ('A') (''));\n  //. // => 'A'\n  //.\n  //. showCard (Pair ('X') (''));\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   showCard :: Pair Rank Suit -> String\n  //. //                    ^^^^\n  //. //                     1\n  //. //\n  //. //   1)  \"X\" :: String\n  //. //\n  //. //   The value at position 1 is not a member of Rank.\n  //. //\n  //. //   See http://example.com/my-package#Rank for information about the Rank type.\n  //. ```\n  function BinaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return function(_1) {\n            return function(_2) {\n              return function($1) {\n                return function($2) {\n                  return _Type (BINARY,\n                                name,\n                                url,\n                                2,\n                                null,\n                                supertypes,\n                                K (test),\n                                [['$1', _1, $1],\n                                 ['$2', _2, $2]]);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  }\n\n  //  fromBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type\n  function fromBinaryType(t) {\n    return BinaryType (t.name)\n                      (t.url)\n                      (t.supertypes)\n                      (t._test ([]))\n                      (t._extractors.$1)\n                      (t._extractors.$2);\n  }\n\n  //# EnumType :: String -> String -> Array Any -> Type\n  //.\n  //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).\n  //.\n  //. To define an enumerated type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - an array of distinct values.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Denomination :: Type\n  //. const Denomination = $.EnumType\n  //.   ('Denomination')\n  //.   ('http://example.com/my-package#Denomination')\n  //.   ([10, 20, 50, 100, 200]);\n  //. ```\n  function EnumType(name) {\n    return function(url) {\n      return B (NullaryType (name) (url) ([])) (memberOf);\n    };\n  }\n\n  //# RecordType :: StrMap Type -> Type\n  //.\n  //. `RecordType` is used to construct anonymous record types. The type\n  //. definition specifies the name and type of each required field. A field is\n  //. an enumerable property (either an own property or an inherited property).\n  //.\n  //. To define an anonymous record type one must provide:\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Point :: Type\n  //. const Point = $.RecordType ({x: $.FiniteNumber, y: $.FiniteNumber});\n  //.\n  //. //    dist :: Point -> Point -> FiniteNumber\n  //. const dist =\n  //. def ('dist')\n  //.     ({})\n  //.     ([Point, Point, $.FiniteNumber])\n  //.     (p => q => Math.sqrt (Math.pow (p.x - q.x, 2) +\n  //.                           Math.pow (p.y - q.y, 2)));\n  //.\n  //. dist ({x: 0, y: 0}) ({x: 3, y: 4});\n  //. // => 5\n  //.\n  //. dist ({x: 0, y: 0}) ({x: 3, y: 4, color: 'red'});\n  //. // => 5\n  //.\n  //. dist ({x: 0, y: 0}) ({x: NaN, y: NaN});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //                                                              ^^^^^^^^^^^^\n  //. //                                                                   1\n  //. //\n  //. //   1)  NaN :: Number\n  //. //\n  //. //   The value at position 1 is not a member of FiniteNumber.\n  //.\n  //. dist (0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  //. //                              1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of { x :: FiniteNumber, y :: FiniteNumber }.\n  //. ```\n  function RecordType(fields) {\n    var keys = Object.keys (fields);\n\n    function format(outer, inner) {\n      if (isEmpty (keys)) return outer ('{}');\n      var reprs = Z.map (function(k) {\n        var t = fields[k];\n        return outer (' ') +\n               outer (/^(?!\\d)[$\\w]+$/.test (k) ? k : show (k)) +\n               outer (' :: ') +\n               inner (k) (show (t));\n      }, keys);\n      return wrap (outer ('{')) (outer (' }')) (joinWith (outer (','), reprs));\n    }\n\n    function test(env) {\n      return function(x) {\n        if (x == null) return false;\n        var missing = {};\n        keys.forEach (function(k) { missing[k] = k; });\n        for (var k in x) delete missing[k];\n        return isEmpty (missing);\n      };\n    }\n\n    var tuples = keys.map (function(k) {\n      return [k, function(x) { return [x[k]]; }, fields[k]];\n    });\n\n    return _Type (RECORD, '', '', 0, format, [], test, tuples);\n  }\n\n  //# NamedRecordType :: NonEmpty String -> String -> Array Type -> StrMap Type -> Type\n  //.\n  //. `NamedRecordType` is used to construct named record types. The type\n  //. definition specifies the name and type of each required field. A field is\n  //. an enumerable property (either an own property or an inherited property).\n  //.\n  //. To define a named record type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`); and\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Circle :: Type\n  //. const Circle = $.NamedRecordType\n  //.   ('my-package/Circle')\n  //.   ('http://example.com/my-package#Circle')\n  //.   ([])\n  //.   ({radius: $.PositiveFiniteNumber});\n  //.\n  //. //    Cylinder :: Type\n  //. const Cylinder = $.NamedRecordType\n  //.   ('Cylinder')\n  //.   ('http://example.com/my-package#Cylinder')\n  //.   ([Circle])\n  //.   ({height: $.PositiveFiniteNumber});\n  //.\n  //. //    volume :: Cylinder -> PositiveFiniteNumber\n  //. const volume =\n  //. def ('volume')\n  //.     ({})\n  //.     ([Cylinder, $.FiniteNumber])\n  //.     (cyl => Math.PI * cyl.radius * cyl.radius * cyl.height);\n  //.\n  //. volume ({radius: 2, height: 10});\n  //. // => 125.66370614359172\n  //.\n  //. volume ({radius: 2});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   volume :: Cylinder -> FiniteNumber\n  //. //             ^^^^^^^^\n  //. //                1\n  //. //\n  //. //   1)  {\"radius\": 2} :: Object, StrMap Number\n  //. //\n  //. //   The value at position 1 is not a member of Cylinder.\n  //. //\n  //. //   See http://example.com/my-package#Cylinder for information about the Cylinder type.\n  //. ```\n  function NamedRecordType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(fields) {\n          var keys = sortedKeys (fields);\n\n          function format(outer, inner) {\n            return outer (name);\n          }\n\n          function test(env) {\n            var test2 = _test (env);\n            return function(x) {\n              if (x == null) return false;\n              var missing = {};\n              keys.forEach (function(k) { missing[k] = k; });\n              for (var k in x) delete missing[k];\n              return isEmpty (missing) &&\n                     keys.every (function(k) {\n                       return test2 (x[k]) (fields[k]);\n                     });\n            };\n          }\n\n          var tuples = keys.map (function(k) {\n            return [k, function(x) { return [x[k]]; }, fields[k]];\n          });\n\n          return _Type (RECORD,\n                        name,\n                        url,\n                        0,\n                        format,\n                        supertypes,\n                        test,\n                        tuples);\n        };\n      };\n    };\n  }\n\n  //  typeVarPred :: NonNegativeInteger -> Array Type -> Any -> Boolean\n  function typeVarPred(arity) {\n    var filter = arityGte (arity);\n    return function(env) {\n      var test2 = _test (env);\n      return function(x) {\n        var test1 = test2 (x);\n        return env.some (function(t) { return filter (t) && test1 (t); });\n      };\n    };\n  }\n\n  //# TypeVariable :: String -> Type\n  //.\n  //. Polymorphism is powerful. Not being able to define a function for\n  //. all types would be very limiting indeed: one couldn't even define the\n  //. identity function!\n  //.\n  //. Before defining a polymorphic function one must define one or more type\n  //. variables:\n  //.\n  //. ```javascript\n  //. const a = $.TypeVariable ('a');\n  //. const b = $.TypeVariable ('b');\n  //.\n  //. //    id :: a -> a\n  //. const id = def ('id') ({}) ([a, a]) (x => x);\n  //.\n  //. id (42);\n  //. // => 42\n  //.\n  //. id (null);\n  //. // => null\n  //. ```\n  //.\n  //. The same type variable may be used in multiple positions, creating a\n  //. constraint:\n  //.\n  //. ```javascript\n  //. //    cmp :: a -> a -> Number\n  //. const cmp =\n  //. def ('cmp')\n  //.     ({})\n  //.     ([a, a, $.Number])\n  //.     (x => y => x < y ? -1 : x > y ? 1 : 0);\n  //.\n  //. cmp (42) (42);\n  //. // => 0\n  //.\n  //. cmp ('a') ('z');\n  //. // => -1\n  //.\n  //. cmp ('z') ('a');\n  //. // => 1\n  //.\n  //. cmp (0) ('1');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   cmp :: a -> a -> Number\n  //. //          ^    ^\n  //. //          1    2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"1\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function TypeVariable(name) {\n    var tuples = [];\n    var test = typeVarPred (tuples.length);\n    return _Type (VARIABLE, name, '', 0, always2 (name), [], test, tuples);\n  }\n\n  //# UnaryTypeVariable :: String -> Type -> Type\n  //.\n  //. Combines [`UnaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a unary type variable `t a` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`); and\n  //.\n  //.   - the type of `a`.\n  //.\n  //. Consider the type of a generalized `map`:\n  //.\n  //. ```haskell\n  //. map :: Functor f => (a -> b) -> f a -> f b\n  //. ```\n  //.\n  //. `f` is a unary type variable. With two (nullary) type variables, one\n  //. unary type variable, and one [type class][] it's possible to define a\n  //. fully polymorphic `map` function:\n  //.\n  //. ```javascript\n  //. const $ = require ('sanctuary-def');\n  //. const Z = require ('sanctuary-type-classes');\n  //.\n  //. const a = $.TypeVariable ('a');\n  //. const b = $.TypeVariable ('b');\n  //. const f = $.UnaryTypeVariable ('f');\n  //.\n  //. //    map :: Functor f => (a -> b) -> f a -> f b\n  //. const map =\n  //. def ('map')\n  //.     ({f: [Z.Functor]})\n  //.     ([$.Function ([a, b]), f (a), f (b)])\n  //.     (f => functor => Z.map (f, functor));\n  //. ```\n  //.\n  //. Whereas a regular type variable is fully resolved (`a` might become\n  //. `Array (Array String)`, for example), a unary type variable defers to\n  //. its type argument, which may itself be a type variable. The type argument\n  //. corresponds to the type argument of a unary type or the *second* type\n  //. argument of a binary type. The second type argument of `Map k v`, for\n  //. example, is `v`. One could replace `Functor => f` with `Map k` or with\n  //. `Map Integer`, but not with `Map`.\n  //.\n  //. This shallow inspection makes it possible to constrain a value's \"outer\"\n  //. and \"inner\" types independently.\n  function UnaryTypeVariable(name) {\n    return function($1) {\n      var tuples = [['$1', K ([]), $1]];\n      var test = typeVarPred (tuples.length);\n      return _Type (VARIABLE, name, '', 1, null, [], test, tuples);\n    };\n  }\n\n  //# BinaryTypeVariable :: String -> Type -> Type -> Type\n  //.\n  //. Combines [`BinaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a binary type variable `t a b` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`);\n  //.\n  //.   - the type of `a`; and\n  //.\n  //.   - the type of `b`.\n  //.\n  //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to\n  //. `BinaryTypeVariable`.\n  function BinaryTypeVariable(name) {\n    return function($1) {\n      return function($2) {\n        var tuples = [['$1', K ([]), $1],\n                      ['$2', K ([]), $2]];\n        var test = typeVarPred (tuples.length);\n        return _Type (VARIABLE, name, '', 2, null, [], test, tuples);\n      };\n    };\n  }\n\n  //# Thunk :: Type -> Type\n  //.\n  //. `$.Thunk (T)` is shorthand for `$.Function ([T])`, the type comprising\n  //. every nullary function (thunk) that returns a value of type `T`.\n  function Thunk(t) { return Function_ ([t]); }\n\n  //# Predicate :: Type -> Type\n  //.\n  //. `$.Predicate (T)` is shorthand for `$.Fn (T) ($.Boolean)`, the type\n  //. comprising every predicate function that takes a value of type `T`.\n  function Predicate(t) { return Fn (t) (Boolean_); }\n\n  //. ### Type classes\n  //.\n  //. One can trivially define a function of type `String -> String -> String`\n  //. that concatenates two strings. This is overly restrictive, though, since\n  //. other types support concatenation (`Array a`, for example).\n  //.\n  //. One could use a type variable to define a polymorphic \"concat\" function:\n  //.\n  //. ```javascript\n  //. //    _concat :: a -> a -> a\n  //. const _concat =\n  //. def ('_concat')\n  //.     ({})\n  //.     ([a, a, a])\n  //.     (x => y => x.concat (y));\n  //.\n  //. _concat ('fizz') ('buzz');\n  //. // => 'fizzbuzz'\n  //.\n  //. _concat ([1, 2]) ([3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. _concat ([1, 2]) ('buzz');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   _concat :: a -> a -> a\n  //. //              ^    ^\n  //. //              1    2\n  //. //\n  //. //   1)  [1, 2] :: Array Number\n  //. //\n  //. //   2)  \"buzz\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  //.\n  //. The type of `_concat` is misleading: it suggests that it can operate on\n  //. any two values of *any* one type. In fact there's an implicit constraint,\n  //. since the type must support concatenation (in [mathematical][semigroup]\n  //. terms, the type must have a [semigroup][FL:Semigroup]). Violating this\n  //. implicit constraint results in a run-time error in the implementation:\n  //.\n  //. ```javascript\n  //. _concat (null) (null);\n  //. // ! TypeError: Cannot read property 'concat' of null\n  //. ```\n  //.\n  //. The solution is to constrain `a` by first defining a [`TypeClass`][]\n  //. value, then specifying the constraint in the definition of the \"concat\"\n  //. function:\n  //.\n  //. ```javascript\n  //. const Z = require ('sanctuary-type-classes');\n  //.\n  //. //    Semigroup :: TypeClass\n  //. const Semigroup = Z.TypeClass (\n  //.   'my-package/Semigroup',\n  //.   'http://example.com/my-package#Semigroup',\n  //.   [],\n  //.   x => x != null && typeof x.concat === 'function'\n  //. );\n  //.\n  //. //    concat :: Semigroup a => a -> a -> a\n  //. const concat =\n  //. def ('concat')\n  //.     ({a: [Semigroup]})\n  //.     ([a, a, a])\n  //.     (x => y => x.concat (y));\n  //.\n  //. concat ([1, 2]) ([3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. concat (null) (null);\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  null :: Null\n  //. //\n  //. //   concat requires a to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //. ```\n  //.\n  //. Multiple constraints may be placed on a type variable by including\n  //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).\n\n  //  invalidArgumentsCount :: (TypeInfo, Integer, Integer, Array Any) -> Error\n  //\n  //  This function is used in `curry` when a function defined via `def`\n  //  is applied to too many arguments.\n  function invalidArgumentsCount(typeInfo, index, numArgsExpected, args) {\n    return new TypeError (trimTrailingSpaces (\n      q (typeInfo.name) + ' applied to the wrong number of arguments\\n\\n' +\n      underline (\n        typeInfo,\n        K (K (_)),\n        function(index_) {\n          return function(f) {\n            return K (K (index_ === index ? f : _));\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs (numArgsExpected) +\n      ' but received ' + numArgs (args.length) +\n      toMarkdownList ('.\\n', ':\\n\\n', show, args)\n    ));\n  }\n\n  //  constraintsRepr :: ... -> String\n  function constraintsRepr(\n    constraints,    // :: StrMap (Array TypeClass)\n    outer,          // :: String -> String\n    inner           // :: String -> TypeClass -> String -> String\n  ) {\n    var $reprs = [];\n    (Object.keys (constraints)).forEach (function(k) {\n      var f = inner (k);\n      constraints[k].forEach (function(typeClass) {\n        $reprs.push (f (typeClass) (stripNamespace (typeClass) + ' ' + k));\n      });\n    });\n    return when ($reprs.length > 0)\n                (wrap ('') (outer (' => ')))\n                (when ($reprs.length > 1)\n                      (parenthesize (outer))\n                      (joinWith (outer (', '), $reprs)));\n  }\n\n  //  label :: String -> String -> String\n  function label(label) {\n    return function(s) {\n      var delta = s.length - label.length;\n      return strRepeat (' ', Math.floor (delta / 2)) + label +\n             strRepeat (' ', Math.ceil (delta / 2));\n    };\n  }\n\n  //  typeVarNames :: Type -> Array String\n  function typeVarNames(t) {\n    return Z.concat (\n      t.type === VARIABLE ? [t.name] : [],\n      Z.chain (function(k) { return typeVarNames (t.types[k]); }, t.keys)\n    );\n  }\n\n  //  showTypeWith :: Array Type -> Type -> String\n  function showTypeWith(types) {\n    var names = Z.chain (typeVarNames, types);\n    return function(t) {\n      var code = 'a'.charCodeAt (0);\n      return when (t.type === FUNCTION)\n                  (parenthesize (I))\n                  ((show (t)).replace (/\\bUnknown\\b/g, function() {\n                     // eslint-disable-next-line no-plusplus\n                     do var name = String.fromCharCode (code++);\n                     while (names.indexOf (name) >= 0);\n                     return name;\n                   }));\n    };\n  }\n\n  //  showValuesAndTypes :: ... -> String\n  function showValuesAndTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    values,         // :: Array Any\n    pos             // :: Integer\n  ) {\n    var showType = showTypeWith (typeInfo.types);\n    return show (pos) + ')  ' + joinWith ('\\n    ', Z.map (function(x) {\n      return show (x) +\n             ' :: ' +\n             joinWith (', ',\n                       or (Z.map (showType,\n                                  determineActualTypesLoose (env, [x])),\n                           ['(no types)']));\n    }, values));\n  }\n\n  //  typeSignature :: TypeInfo -> String\n  function typeSignature(typeInfo) {\n    return typeInfo.name + ' :: ' +\n           constraintsRepr (typeInfo.constraints, I, K (K (I))) +\n           joinWith (' -> ',\n                     Z.map (showTypeWith (typeInfo.types), typeInfo.types));\n  }\n\n  //  _underline :: ... -> String\n  function _underline(\n    t,              // :: Type\n    propPath,       // :: PropPath\n    formatType3     // :: Type -> Array String -> String -> String\n  ) {\n    return formatType3 (t) (propPath) (t.format (_, function(k) {\n      return K (_underline (t.types[k],\n                            Z.concat (propPath, [k]),\n                            formatType3));\n    }));\n  }\n\n  //  underline :: ... -> String\n  function underline(\n    typeInfo,               // :: TypeInfo\n    underlineConstraint,    // :: String -> TypeClass -> String -> String\n    formatType5\n    // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String\n  ) {\n    var st = typeInfo.types.reduce (function(st, t, index) {\n      var f = B (when (t.type === FUNCTION)\n                      (parenthesize (_)))\n                (B (function(f) { return _underline (t, [], f); })\n                   (formatType5 (index)));\n      st.carets.push (f (r ('^')));\n      st.numbers.push (f (function(s) {\n        return label (show (st.counter += 1)) (s);\n      }));\n      return st;\n    }, {carets: [], numbers: [], counter: 0});\n\n    return typeSignature (typeInfo) + '\\n' +\n           _ (typeInfo.name + ' :: ') +\n              constraintsRepr (typeInfo.constraints, _, underlineConstraint) +\n              joinWith (_ (' -> '), st.carets) + '\\n' +\n           _ (typeInfo.name + ' :: ') +\n              constraintsRepr (typeInfo.constraints, _, K (K (_))) +\n              joinWith (_ (' -> '), st.numbers) + '\\n';\n  }\n\n  //  resolvePropPath :: (Type, Array String) -> Type\n  function resolvePropPath(t, propPath) {\n    return Z.reduce (function(t, prop) { return t.types[prop]; },\n                     t,\n                     propPath);\n  }\n\n  //  formatType6 ::\n  //    PropPath -> Integer -> (String -> String) ->\n  //      Type -> PropPath -> String -> String\n  function formatType6(indexedPropPath) {\n    return function(index_) {\n      return function(f) {\n        return function(t) {\n          return function(propPath_) {\n            var indexedPropPath_ = Z.concat ([index_], propPath_);\n            var p = isPrefix (indexedPropPath_) (indexedPropPath);\n            var q = isPrefix (indexedPropPath) (indexedPropPath_);\n            return p && q ? f : p ? I : _;\n          };\n        };\n      };\n    };\n  }\n\n  //  see :: (String, { name :: String, url :: String? }) -> String\n  function see(label, record) {\n    return record.url == null || record.url === '' ?\n           '' :\n           '\\nSee ' + record.url +\n           ' for information about the ' + record.name + ' ' + label + '.\\n';\n  }\n\n  //  typeClassConstraintViolation :: ... -> Error\n  function typeClassConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeClass,      // :: TypeClass\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value,          // :: Any\n    typeVarMap      // :: TypeVarMap\n  ) {\n    var expType = resolvePropPath (typeInfo.types[index], propPath);\n    return new TypeError (trimTrailingSpaces (\n      'Type-class constraint violation\\n\\n' +\n      underline (typeInfo,\n                 function(tvn) {\n                   return function(tc) {\n                     return (\n                       tvn === expType.name && tc.name === typeClass.name ?\n                         r ('^') :\n                         _\n                     );\n                   };\n                 },\n                 formatType6 (Z.concat ([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n      q (typeInfo.name) + ' requires ' +\n      q (expType.name) + ' to satisfy the ' +\n      stripNamespace (typeClass) + ' type-class constraint; ' +\n      'the value at position 1 does not.\\n' +\n      see ('type class', typeClass)\n    ));\n  }\n\n  //  typeVarConstraintViolation :: ... -> Error\n  function typeVarConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    valuesByPath    // :: StrMap (Array Any)\n  ) {\n    //  If we apply an a -> a -> a -> a function to Left ('x'), Right (1),\n    //  and Right (null) we'd like to avoid underlining the first argument\n    //  position, since Left ('x') is compatible with the other a values.\n    var key = JSON.stringify (Z.concat ([index], propPath));\n    var values = valuesByPath[key];\n\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var keys = Z.filter (function(k) {\n      var values_ = valuesByPath[k];\n      return (\n        //  Keep X, the position at which the violation was observed.\n        k === key ||\n        //  Keep positions whose values are incompatible with the values at X.\n        isEmpty (determineActualTypesStrict (env, Z.concat (values, values_)))\n      );\n    }, sortedKeys (valuesByPath));\n\n    var underlinedTypeVars =\n    underlineTypeVars (typeInfo,\n                       Z.reduce (function($valuesByPath, k) {\n                         $valuesByPath[k] = valuesByPath[k];\n                         return $valuesByPath;\n                       }, {}, keys));\n\n    return new TypeError (trimTrailingSpaces (\n      'Type-variable constraint violation\\n\\n' +\n      underlinedTypeVars + '\\n' +\n      (Z.reduce (function(st, k) {\n        var values = valuesByPath[k];\n        return isEmpty (values) ? st : {\n          idx: st.idx + 1,\n          s: st.s +\n             showValuesAndTypes (env, typeInfo, values, st.idx + 1) +\n             '\\n\\n'\n        };\n      }, {idx: 0, s: ''}, keys)).s +\n      'Since there is no type of which all the above values are ' +\n      'members, the type-variable constraint has been violated.\\n'\n    ));\n  }\n\n  //  invalidValue :: ... -> Error\n  function invalidValue(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value           // :: Any\n  ) {\n    var t = resolvePropPath (typeInfo.types[index], propPath);\n\n    var underlinedTypeVars =\n    underline (typeInfo,\n               K (K (_)),\n               formatType6 (Z.concat ([index], propPath)));\n\n    return new TypeError (trimTrailingSpaces (\n      t.type === VARIABLE &&\n      isEmpty (determineActualTypesLoose (env, [value])) ?\n        'Unrecognized value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n        toMarkdownList (\n          'The environment is empty! ' +\n          'Polymorphic functions require a non-empty environment.\\n',\n          'The value at position 1 is not a member of any type in ' +\n          'the environment.\\n\\n' +\n          'The environment contains the following types:\\n\\n',\n          showTypeWith (typeInfo.types),\n          env\n        ) :\n      // else\n        'Invalid value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n        'The value at position 1 is not a member of ' +\n        q (show (t)) + '.\\n' +\n        see (arityGte (1) (t) ? 'type constructor' : 'type', t)\n    ));\n  }\n\n  //  invalidArgumentsLength :: ... -> Error\n  //\n  //  This function is used in `wrapFunctionCond` to ensure that higher-order\n  //  functions defined via `def` only ever apply a function argument to the\n  //  correct number of arguments.\n  function invalidArgumentsLength(\n    typeInfo,           // :: TypeInfo\n    index,              // :: Integer\n    numArgsExpected,    // :: Integer\n    args                // :: Array Any\n  ) {\n    return new TypeError (trimTrailingSpaces (\n      q (typeInfo.name) +\n      ' applied ' + q (show (typeInfo.types[index])) +\n      ' to the wrong number of arguments\\n\\n' +\n      underline (\n        typeInfo,\n        K (K (_)),\n        function(index_) {\n          return function(f) {\n            return function(t) {\n              return function(propPath) {\n                return function(s) {\n                  return index_ === index ?\n                    t.format (_, function(k) { return k === '$1' ? f : _; }) :\n                    _ (s);\n                };\n              };\n            };\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs (numArgsExpected) +\n      ' but received ' + numArgs (args.length) +\n      toMarkdownList ('.\\n', ':\\n\\n', show, args)\n    ));\n  }\n\n  //  assertRight :: Either (() -> Error) a -> a !\n  function assertRight(either) {\n    if (either.isLeft) throw either.value ();\n    return either.value;\n  }\n\n  //  withTypeChecking :: ... -> Function\n  function withTypeChecking(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    impl            // :: Function\n  ) {\n    var n = typeInfo.types.length - 1;\n\n    //  wrapFunctionCond :: (TypeVarMap, Integer, a) -> a\n    function wrapFunctionCond(_typeVarMap, index, value) {\n      var expType = typeInfo.types[index];\n      if (expType.type !== FUNCTION) return value;\n\n      //  checkValue :: (TypeVarMap, Integer, String, a) -> Either (() -> Error) TypeVarMap\n      function checkValue(typeVarMap, index, k, x) {\n        var propPath = [k];\n        var t = expType.types[k];\n        return (\n          t.type === VARIABLE ?\n            Z.chain (\n              function(typeVarMap) {\n                return isEmpty (typeVarMap[t.name].types) ?\n                  Left (function() {\n                    return typeVarConstraintViolation (\n                      env,\n                      typeInfo,\n                      index,\n                      propPath,\n                      typeVarMap[t.name].valuesByPath\n                    );\n                  }) :\n                  Right (typeVarMap);\n              },\n              Right (updateTypeVarMap (env,\n                                       typeVarMap,\n                                       t,\n                                       index,\n                                       propPath,\n                                       [x]))\n            ) :\n          // else\n            Z.map (\n              function(r) { return r.typeVarMap; },\n              satisfactoryTypes (env,\n                                 typeInfo,\n                                 typeVarMap,\n                                 t,\n                                 index,\n                                 propPath,\n                                 [x])\n            )\n        );\n      }\n\n      var typeVarMap = _typeVarMap;\n      return function(x) {\n        if (arguments.length !== expType.arity - 1) {\n          throw invalidArgumentsLength (typeInfo,\n                                        index,\n                                        expType.arity - 1,\n                                        slice.call (arguments));\n        }\n\n        var args = arguments;\n        typeVarMap = assertRight (\n          (init (expType.keys)).reduce (function(either, k, idx) {\n            var arg = args[idx];\n            return Z.chain (function(typeVarMap) {\n              return checkValue (typeVarMap, index, k, arg);\n            }, either);\n          }, Right (typeVarMap))\n        );\n\n        var output = value.apply (this, arguments);\n        var k = last (expType.keys);\n        typeVarMap = assertRight (checkValue (typeVarMap, index, k, output));\n        return output;\n      };\n    }\n\n    //  wrapNext :: (TypeVarMap, Array Any, Integer) -> (a -> b)\n    function wrapNext(_typeVarMap, _values, index) {\n      return function(x) {\n        var args = slice.call (arguments);\n        if (args.length !== 1) {\n          throw invalidArgumentsCount (typeInfo, index, 1, args);\n        }\n        var typeVarMap = (assertRight (\n          satisfactoryTypes (env,\n                             typeInfo,\n                             _typeVarMap,\n                             typeInfo.types[index],\n                             index,\n                             [],\n                             args)\n        )).typeVarMap;\n\n        var values = Z.concat (_values, args);\n        if (index + 1 === n) {\n          var value = values.reduce (function(f, x, idx) {\n            return f (wrapFunctionCond (typeVarMap, idx, x));\n          }, impl);\n          typeVarMap = (assertRight (\n            satisfactoryTypes (env,\n                               typeInfo,\n                               typeVarMap,\n                               typeInfo.types[n],\n                               n,\n                               [],\n                               [value])\n          )).typeVarMap;\n          return wrapFunctionCond (typeVarMap, n, value);\n        } else {\n          return wrapNext (typeVarMap, values, index + 1);\n        }\n      };\n    }\n\n    var wrapped = typeInfo.types[0].type === NO_ARGUMENTS ?\n      function() {\n        if (arguments.length !== 0) {\n          throw invalidArgumentsCount (typeInfo, 0, 0, slice.call (arguments));\n        }\n        var value = impl ();\n        var typeVarMap = (assertRight (\n          satisfactoryTypes (env,\n                             typeInfo,\n                             {},\n                             typeInfo.types[n],\n                             n,\n                             [],\n                             [value])\n        )).typeVarMap;\n        return wrapFunctionCond (typeVarMap, n, value);\n      } :\n      wrapNext ({}, [], 0);\n\n    wrapped.toString = always0 (typeSignature (typeInfo));\n    /* istanbul ignore else */\n    if (\n      typeof process !== 'undefined' &&\n      process != null &&\n      process.versions != null &&\n      process.versions.node != null\n    ) wrapped[Symbol.for ('nodejs.util.inspect.custom')] = wrapped.toString;\n    /* istanbul ignore if */\n    if (typeof Deno !== 'undefined') {\n      if (Deno != null && typeof Deno.customInspect === 'symbol') {\n        wrapped[Deno.customInspect] = wrapped.toString;\n      }\n    }\n\n    return wrapped;\n  }\n\n  //  defTypes :: NonEmpty (Array Type)\n  var defTypes = [\n    String_,\n    StrMap (Array_ (TypeClass)),\n    NonEmpty (Array_ (Type)),\n    AnyFunction,\n    AnyFunction\n  ];\n\n  function create(opts) {\n    function def(name) {\n      return function(constraints) {\n        return function(expTypes) {\n          return function(impl) {\n            return opts.checkTypes ?\n              withTypeChecking (opts.env,\n                                {name: name,\n                                 constraints: constraints,\n                                 types: expTypes.length === 1 ?\n                                        Z.concat ([NoArguments], expTypes) :\n                                        expTypes},\n                                impl) :\n              impl;\n          };\n        };\n      };\n    }\n    return def (def.name) ({}) (defTypes) (def);\n  }\n\n  var def = create ({checkTypes: !production, env: env});\n\n  //  fromUncheckedUnaryType :: (Type -> Type) -> Type -> Type\n  function fromUncheckedUnaryType(typeConstructor) {\n    var t = typeConstructor (Unknown);\n    return def (t.name) ({}) ([Type, Type]) (fromUnaryType (t));\n  }\n\n  //  fromUncheckedBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type\n  function fromUncheckedBinaryType(typeConstructor) {\n    var t = typeConstructor (Unknown) (Unknown);\n    return def (t.name) ({}) ([Type, Type, Type]) (fromBinaryType (t));\n  }\n\n  return {\n    Any: Any,\n    AnyFunction: AnyFunction,\n    Arguments: Arguments,\n    Array: fromUncheckedUnaryType (Array_),\n    Array0: Array0,\n    Array1: fromUncheckedUnaryType (Array1),\n    Array2: fromUncheckedBinaryType (Array2),\n    Boolean: Boolean_,\n    Buffer: Buffer_,\n    Date: Date_,\n    ValidDate: ValidDate,\n    Descending: fromUncheckedUnaryType (Descending),\n    Either: fromUncheckedBinaryType (Either_),\n    Error: Error_,\n    Fn:\n      def ('Fn')\n          ({})\n          ([Type, Type, Type])\n          (Fn),\n    Function:\n      def ('Function')\n          ({})\n          ([NonEmpty (Array_ (Type)), Type])\n          (Function_),\n    HtmlElement: HtmlElement,\n    Identity: fromUncheckedUnaryType (Identity),\n    JsMap: fromUncheckedBinaryType (JsMap),\n    JsSet: fromUncheckedUnaryType (JsSet),\n    Maybe: fromUncheckedUnaryType (Maybe),\n    Module: Module,\n    NonEmpty: NonEmpty,\n    Null: Null,\n    Nullable: fromUncheckedUnaryType (Nullable),\n    Number: Number_,\n    PositiveNumber: PositiveNumber,\n    NegativeNumber: NegativeNumber,\n    ValidNumber: ValidNumber,\n    NonZeroValidNumber: NonZeroValidNumber,\n    FiniteNumber: FiniteNumber,\n    NonZeroFiniteNumber: NonZeroFiniteNumber,\n    PositiveFiniteNumber: PositiveFiniteNumber,\n    NegativeFiniteNumber: NegativeFiniteNumber,\n    Integer: Integer,\n    NonZeroInteger: NonZeroInteger,\n    NonNegativeInteger: NonNegativeInteger,\n    PositiveInteger: PositiveInteger,\n    NegativeInteger: NegativeInteger,\n    Object: Object_,\n    Pair: fromUncheckedBinaryType (Pair),\n    RegExp: RegExp_,\n    GlobalRegExp: GlobalRegExp,\n    NonGlobalRegExp: NonGlobalRegExp,\n    RegexFlags: RegexFlags,\n    StrMap: fromUncheckedUnaryType (StrMap),\n    String: String_,\n    Symbol: Symbol_,\n    Type: Type,\n    TypeClass: TypeClass,\n    Undefined: Undefined,\n    Unknown: Unknown,\n    Void: Void,\n    env: env,\n    create:\n      def ('create')\n          ({})\n          ([RecordType ({checkTypes: Boolean_, env: Array_ (Type)}),\n            Unchecked (joinWith (' -> ', Z.map (show, defTypes)))])\n          (create),\n    test:\n      def ('test')\n          ({})\n          ([Array_ (Type), Type, Any, Boolean_])\n          (test),\n    validate:\n      def ('validate')\n          ({})\n          ([Type, Any, Either_ (Array_ (Object_)) (Any)])\n          (validate),\n    NullaryType:\n      def ('NullaryType')\n          ({})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Type])\n          (NullaryType),\n    UnaryType:\n      def ('UnaryType')\n          ({f: [Z.Foldable]})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Unchecked ('(t a -> f a)'),\n            Unchecked ('Type -> Type')])\n          (function(name) {\n             return B (B (B (B (def (name) ({}) ([Type, Type])))))\n                      (UnaryType (name));\n           }),\n    BinaryType:\n      def ('BinaryType')\n          ({f: [Z.Foldable]})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Unchecked ('(t a b -> f a)'),\n            Unchecked ('(t a b -> f b)'),\n            Unchecked ('Type -> Type -> Type')])\n          (function(name) {\n             return B (B (B (B (B (def (name) ({}) ([Type, Type, Type]))))))\n                      (BinaryType (name));\n           }),\n    EnumType:\n      def ('EnumType')\n          ({})\n          ([String_, String_, Array_ (Any), Type])\n          (EnumType),\n    RecordType:\n      def ('RecordType')\n          ({})\n          ([StrMap (Type), Type])\n          (RecordType),\n    NamedRecordType:\n      def ('NamedRecordType')\n          ({})\n          ([NonEmpty (String_), String_, Array_ (Type), StrMap (Type), Type])\n          (NamedRecordType),\n    TypeVariable:\n      def ('TypeVariable')\n          ({})\n          ([String_, Type])\n          (TypeVariable),\n    UnaryTypeVariable:\n      def ('UnaryTypeVariable')\n          ({})\n          ([String_, Unchecked ('Type -> Type')])\n          (function(name) {\n             return def (name) ({}) ([Type, Type]) (UnaryTypeVariable (name));\n           }),\n    BinaryTypeVariable:\n      def ('BinaryTypeVariable')\n          ({})\n          ([String_, Unchecked ('Type -> Type -> Type')])\n          (function(name) {\n             return def (name)\n                        ({})\n                        ([Type, Type, Type])\n                        (BinaryTypeVariable (name));\n           }),\n    Thunk:\n      def ('Thunk')\n          ({})\n          ([Type, Type])\n          (Thunk),\n    Predicate:\n      def ('Predicate')\n          ({})\n          ([Type, Type])\n          (Predicate)\n  };\n\n}));\n\n//. [Buffer]:               https://nodejs.org/api/buffer.html#buffer_buffer\n//. [Descending]:           v:sanctuary-js/sanctuary-descending\n//. [Either]:               v:sanctuary-js/sanctuary-either\n//. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup\n//. [HTML element]:         https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n//. [Identity]:             v:sanctuary-js/sanctuary-identity\n//. [Maybe]:                v:sanctuary-js/sanctuary-maybe\n//. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid\n//. [Pair]:                 v:sanctuary-js/sanctuary-pair\n//. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid\n//. [Unknown]:              #Unknown\n//. [`Array`]:              #Array\n//. [`Array2`]:             #Array2\n//. [`BinaryType`]:         #BinaryType\n//. [`Date`]:               #Date\n//. [`FiniteNumber`]:       #FiniteNumber\n//. [`GlobalRegExp`]:       #GlobalRegExp\n//. [`Integer`]:            #Integer\n//. [`NonGlobalRegExp`]:    #NonGlobalRegExp\n//. [`Number`]:             #Number\n//. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n//. [`RegExp`]:             #RegExp\n//. [`RegexFlags`]:         #RegexFlags\n//. [`String`]:             #String\n//. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\n//. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass\n//. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n//. [`TypeVariable`]:       #TypeVariable\n//. [`UnaryType`]:          #UnaryType\n//. [`UnaryTypeVariable`]:  #UnaryTypeVariable\n//. [`Unknown`]:            #Unknown\n//. [`ValidNumber`]:        #ValidNumber\n//. [`env`]:                #env\n//. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n//. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type\n//. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\n//. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER\n//. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup\n//. [type class]:           #type-classes\n//. [type variables]:       #TypeVariable\n//. [types]:                #types\n","/*\n    ,______  ______,  ,________,,_____,,_____,,__________  ,__________,\n    |      \\/      |  |        ||     ||     ||          \\ |          |\n    |_,          ,_|  |_      _||_    ||    _||_,   __    ||_,   _____|\n      |   \\  /   |     /      \\   \\   \\/   /    |        /   |      |\n    ,_|    ||    |_,,_/   /\\   \\_, \\      /   ,_|   __   \\ ,_|   ___|_,\n    |      ||      ||     ||     |  |    |    |           ||          |\n    |______||______||_____||_____|  |____|    |__________/ |__________|\n                                                                         */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-maybe\n//.\n//. The Maybe type represents optional values: a value of type `Maybe a` is\n//. either Nothing (the empty value) or a Just whose value is of type `a`.\n\n(f => {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-show', 'sanctuary-type-classes'], f);\n  } else {\n    self.sanctuaryMaybe = f (self.sanctuaryShow,\n                             self.sanctuaryTypeClasses);\n  }\n\n}) ((show, Z) => {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars, no-var */\n    var S = __doctest.require ('sanctuary');\n    var $ = __doctest.require ('sanctuary-def');\n    /* eslint-enable no-unused-vars, no-var */\n  }\n\n  const maybeTypeIdent = 'sanctuary-maybe/Maybe@1';\n\n  const Maybe = {};\n\n  const Nothing$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Maybe,\n    'isNothing':              true,\n    'isJust':                 false,\n    '@@type':                 maybeTypeIdent,\n    '@@show':                 Nothing$prototype$show,\n    'fantasy-land/equals':    Nothing$prototype$equals,\n    'fantasy-land/lte':       Nothing$prototype$lte,\n    'fantasy-land/concat':    Nothing$prototype$concat,\n    'fantasy-land/filter':    Nothing$prototype$filter,\n    'fantasy-land/map':       Nothing$prototype$map,\n    'fantasy-land/ap':        Nothing$prototype$ap,\n    'fantasy-land/chain':     Nothing$prototype$chain,\n    'fantasy-land/alt':       Nothing$prototype$alt,\n    'fantasy-land/reduce':    Nothing$prototype$reduce,\n    'fantasy-land/traverse':  Nothing$prototype$traverse,\n    'fantasy-land/extend':    Nothing$prototype$extend,\n    /* eslint-enable key-spacing */\n  };\n\n  const Just$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Maybe,\n    'isNothing':              false,\n    'isJust':                 true,\n    '@@type':                 maybeTypeIdent,\n    '@@show':                 Just$prototype$show,\n    'fantasy-land/filter':    Just$prototype$filter,\n    'fantasy-land/map':       Just$prototype$map,\n    'fantasy-land/ap':        Just$prototype$ap,\n    'fantasy-land/chain':     Just$prototype$chain,\n    'fantasy-land/alt':       Just$prototype$alt,\n    'fantasy-land/reduce':    Just$prototype$reduce,\n    'fantasy-land/traverse':  Just$prototype$traverse,\n    'fantasy-land/extend':    Just$prototype$extend,\n    /* eslint-enable key-spacing */\n  };\n\n  /* istanbul ignore else */\n  if (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  ) {\n    Nothing$prototype[\n      Symbol.for ('nodejs.util.inspect.custom')  // added in Node.js v10.12.0\n    ] = Nothing$prototype$show;\n    Just$prototype[\n      Symbol.for ('nodejs.util.inspect.custom')  // added in Node.js v10.12.0\n    ] = Just$prototype$show;\n  }\n  /* istanbul ignore if */\n  if (typeof Deno !== 'undefined') {\n    if (Deno != null && typeof Deno.customInspect === 'symbol') {\n      Nothing$prototype[Deno.customInspect] = Nothing$prototype$show;\n      Just$prototype[Deno.customInspect] = Just$prototype$show;\n    }\n  }\n\n  //. `Maybe a` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Just (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Nothing)        ? '\\u2705 * ' :\n  //. .              /* otherwise */              '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid           * ',  // if a satisfies Setoid\n  //. . 'Ord              * ',  // if a satisfies Ord\n  //. . 'Semigroupoid       ',\n  //. . 'Category           ',\n  //. . 'Semigroup        * ',  // if a satisfies Semigroup\n  //. . 'Monoid           * ',  // if a satisfies Semigroup\n  //. . 'Group              ',\n  //. . 'Filterable         ',\n  //. . 'Functor            ',\n  //. . 'Bifunctor          ',\n  //. . 'Profunctor         ',\n  //. . 'Apply              ',\n  //. . 'Applicative        ',\n  //. . 'Chain              ',\n  //. . 'ChainRec           ',\n  //. . 'Monad              ',\n  //. . 'Alt                ',\n  //. . 'Plus               ',\n  //. . 'Alternative        ',\n  //. . 'Foldable           ',\n  //. . 'Traversable        ',\n  //. . 'Extend             ',\n  //. . 'Comonad            ',\n  //. . 'Contravariant      ' ]\n  //. ```\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. Maybe [type representative][].\n\n  //# Maybe.Nothing :: Maybe a\n  //.\n  //. The empty value of type `Maybe a`.\n  //.\n  //. ```javascript\n  //. > Nothing\n  //. Nothing\n  //. ```\n  const Nothing = Maybe.Nothing = Object.create (Nothing$prototype);\n\n  //# Maybe.Just :: a -> Maybe a\n  //.\n  //. Constructs a value of type `Maybe a` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > Just (42)\n  //. Just (42)\n  //. ```\n  const Just = Maybe.Just = value => {\n    const just = Object.create (Just$prototype);\n    if (Z.Setoid.test (value)) {\n      just['fantasy-land/equals'] = Just$prototype$equals;\n      if (Z.Ord.test (value)) {\n        just['fantasy-land/lte'] = Just$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      just['fantasy-land/concat'] = Just$prototype$concat;\n    }\n    just.value = value;\n    return just;\n  };\n\n  //# Maybe.fantasy-land/empty :: () -> Maybe a\n  //.\n  //.   - `empty (Maybe)` is equivalent to `Nothing`\n  //.\n  //. ```javascript\n  //. > S.empty (Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/empty'] = () => Nothing;\n\n  //# Maybe.fantasy-land/of :: a -> Maybe a\n  //.\n  //.   - `of (Maybe) (x)` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.of (Maybe) (42)\n  //. Just (42)\n  //. ```\n  Maybe['fantasy-land/of'] = Just;\n\n  const next = x => ({tag: next, value: x});\n  const done = x => ({tag: done, value: x});\n\n  //# Maybe.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Maybe c, a) -> Maybe b\n  //.\n  //. ```javascript\n  //. > Z.chainRec (\n  //. .   Maybe,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),\n  //. .   1\n  //. . )\n  //. Nothing\n  //.\n  //. > Z.chainRec (\n  //. .   Maybe,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),\n  //. .   2\n  //. . )\n  //. Just (65536)\n  //. ```\n  Maybe['fantasy-land/chainRec'] = (f, x) => {\n    let r = next (x);\n    while (r.tag === next) {\n      const maybe = f (next, done, r.value);\n      if (maybe.isNothing) return maybe;\n      r = maybe.value;\n    }\n    return Just (r.value);\n  };\n\n  //# Maybe.fantasy-land/zero :: () -> Maybe a\n  //.\n  //.   - `zero (Maybe)` is equivalent to `Nothing`\n  //.\n  //. ```javascript\n  //. > S.zero (Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/zero'] = () => Nothing;\n\n  //# Maybe#@@show :: Showable a => Maybe a ~> () -> String\n  //.\n  //.   - `show (Nothing)` is equivalent to `'Nothing'`\n  //.   - `show (Just (x))` is equivalent to `'Just (' + show (x) + ')'`\n  //.\n  //. ```javascript\n  //. > S.show (Nothing)\n  //. 'Nothing'\n  //.\n  //. > S.show (Just (['foo', 'bar', 'baz']))\n  //. 'Just ([\"foo\", \"bar\", \"baz\"])'\n  //. ```\n  function Nothing$prototype$show() {\n    return 'Nothing';\n  }\n  function Just$prototype$show() {\n    return 'Just (' + show (this.value) + ')';\n  }\n\n  //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //.   - `Nothing` is equal to `Nothing`\n  //.   - `Just (x)` is equal to `Just (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Nothing` is never equal to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.equals (Nothing) (Nothing)\n  //. true\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Just ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Just ([3, 2, 1]))\n  //. false\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Nothing)\n  //. false\n  //. ```\n  function Nothing$prototype$equals(other) {\n    return other.isNothing;\n  }\n  function Just$prototype$equals(other) {\n    return other.isJust && Z.equals (this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //.   - `Nothing` is (less than or) equal to `Nothing`\n  //.   - `Just (x)` is less than or equal to `Just (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Nothing` is always less than `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Nothing)) ([Nothing, Just (0), Just (1), Just (2)])\n  //. [Nothing]\n  //.\n  //. > S.filter (S.lte (Just (1))) ([Nothing, Just (0), Just (1), Just (2)])\n  //. [Nothing, Just (0), Just (1)]\n  //. ```\n  function Nothing$prototype$lte(other) {\n    return true;\n  }\n  function Just$prototype$lte(other) {\n    return other.isJust && Z.lte (this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a\n  //.\n  //.   - `concat (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `concat (Just (x)) (Just (y))` is equivalent to\n  //.     `Just (concat (x) (y))`\n  //.   - `concat (Nothing) (Just (x))` is equivalent to `Just (x)`\n  //.   - `concat (Just (x)) (Nothing)` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.concat (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.concat (Just ([1, 2, 3])) (Just ([4, 5, 6]))\n  //. Just ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Nothing) (Just ([1, 2, 3]))\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.concat (Just ([1, 2, 3])) (Nothing)\n  //. Just ([1, 2, 3])\n  //. ```\n  function Nothing$prototype$concat(other) {\n    return other;\n  }\n  function Just$prototype$concat(other) {\n    return other.isJust ? Just (Z.concat (this.value, other.value)) : this;\n  }\n\n  //# Maybe#fantasy-land/filter :: Maybe a ~> (a -> Boolean) -> Maybe a\n  //.\n  //.   - `filter (p) (Nothing)` is equivalent to `Nothing`\n  //.   - `filter (p) (Just (x))` is equivalent to `p (x) ? Just (x) : Nothing`\n  //.\n  //. ```javascript\n  //. > S.filter (isFinite) (Nothing)\n  //. Nothing\n  //.\n  //. > S.filter (isFinite) (Just (Infinity))\n  //. Nothing\n  //.\n  //. > S.filter (isFinite) (Just (Number.MAX_SAFE_INTEGER))\n  //. Just (9007199254740991)\n  //. ```\n  function Nothing$prototype$filter(pred) {\n    return this;\n  }\n  function Just$prototype$filter(pred) {\n    return pred (this.value) ? this : Nothing;\n  }\n\n  //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b\n  //.\n  //.   - `map (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `map (f) (Just (x))` is equivalent to `Just (f (x))`\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (Nothing)\n  //. Nothing\n  //.\n  //. > S.map (Math.sqrt) (Just (9))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$map(f) {\n    return this;\n  }\n  function Just$prototype$map(f) {\n    return Just (f (this.value));\n  }\n\n  //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b\n  //.\n  //.   - `ap (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `ap (Nothing) (Just (x))` is equivalent to `Nothing`\n  //.   - `ap (Just (f)) (Nothing)` is equivalent to `Nothing`\n  //.   - `ap (Just (f)) (Just (x))` is equivalent to `Just (f (x))`\n  //.\n  //. ```javascript\n  //. > S.ap (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.ap (Nothing) (Just (9))\n  //. Nothing\n  //.\n  //. > S.ap (Just (Math.sqrt)) (Nothing)\n  //. Nothing\n  //.\n  //. > S.ap (Just (Math.sqrt)) (Just (9))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$ap(other) {\n    return this;\n  }\n  function Just$prototype$ap(other) {\n    return other.isJust ? Just (other.value (this.value)) : other;\n  }\n\n  //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b\n  //.\n  //.   - `chain (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `chain (f) (Just (x))` is equivalent to `f (x)`\n  //.\n  //. ```javascript\n  //. > const head = xs => xs.length === 0 ? Nothing : Just (xs[0])\n  //.\n  //. > S.chain (head) (Nothing)\n  //. Nothing\n  //.\n  //. > S.chain (head) (Just ([]))\n  //. Nothing\n  //.\n  //. > S.chain (head) (Just (['foo', 'bar', 'baz']))\n  //. Just ('foo')\n  //. ```\n  function Nothing$prototype$chain(f) {\n    return this;\n  }\n  function Just$prototype$chain(f) {\n    return f (this.value);\n  }\n\n  //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a\n  //.\n  //.   - `alt (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `alt (Just (x)) (Nothing)` is equivalent to `Just (x)`\n  //.   - `alt (Nothing) (Just (x))` is equivalent to `Just (x)`\n  //.   - `alt (Just (y)) (Just (x))` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.alt (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.alt (Just (1)) (Nothing)\n  //. Just (1)\n  //.\n  //. > S.alt (Nothing) (Just (2))\n  //. Just (2)\n  //.\n  //. > S.alt (Just (4)) (Just (3))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$alt(other) {\n    return other;\n  }\n  function Just$prototype$alt(other) {\n    return this;\n  }\n\n  //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b\n  //.\n  //.   - `reduce (f) (x) (Nothing)` is equivalent to `x`\n  //.   - `reduce (f) (x) (Just (y))` is equivalent to `f (x) (y)`\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ('abc') (Nothing)\n  //. 'abc'\n  //.\n  //. > S.reduce (S.concat) ('abc') (Just ('xyz'))\n  //. 'abcxyz'\n  //. ```\n  function Nothing$prototype$reduce(f, x) {\n    return x;\n  }\n  function Just$prototype$reduce(f, x) {\n    return f (x, this.value);\n  }\n\n  //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)\n  //.\n  //.   - `traverse (A) (f) (Nothing)` is equivalent to `of (A) (Nothing)`\n  //.   - `traverse (A) (f) (Just (x))` is equivalent to `map (Just) (f (x))`\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse (Array) (S.words) (Just ('foo bar baz'))\n  //. [Just ('foo'), Just ('bar'), Just ('baz')]\n  //. ```\n  function Nothing$prototype$traverse(typeRep, f) {\n    return Z.of (typeRep, this);\n  }\n  function Just$prototype$traverse(typeRep, f) {\n    return Z.map (Just, f (this.value));\n  }\n\n  //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b\n  //.\n  //.   - `extend (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `extend (f) (Just (x))` is equivalent to `Just (f (Just (x)))`\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Nothing)\n  //. Nothing\n  //.\n  //. > S.extend (S.reduce (S.add) (1)) (Just (99))\n  //. Just (100)\n  //. ```\n  function Nothing$prototype$extend(f) {\n    return this;\n  }\n  function Just$prototype$extend(f) {\n    return Just (f (this));\n  }\n\n  return Maybe;\n\n});\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n","       /*                   *\\\n      //                     \\\\\n     //   @@  @@     @@  @@   \\\\\n    //      @@       @@  @@    \\\\\n    \\\\      @@       @@  @@    //\n     \\\\   @@  @@  @    @@ @   //\n      \\\\          /       @  //\n       \\*             @@@@  */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-pair\n//.\n//. Pair is the canonical product type: a value of type `Pair a b` always\n//. contains exactly two values: one of type `a`; one of type `b`.\n\n(f => {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-show', 'sanctuary-type-classes'], f);\n  } else {\n    self.sanctuaryPair = f (self.sanctuaryShow,\n                            self.sanctuaryTypeClasses);\n  }\n\n}) ((show, Z) => {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars, no-var */\n    var S = __doctest.require ('sanctuary');\n    var $ = __doctest.require ('sanctuary-def');\n    /* eslint-enable no-unused-vars, no-var */\n  }\n\n  const pairTypeIdent = 'sanctuary-pair/Pair@1';\n\n  const prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Pair,\n    '@@type':                 pairTypeIdent,\n    '@@show':                 Pair$prototype$show,\n    'fantasy-land/compose':   Pair$prototype$compose,\n    'fantasy-land/map':       Pair$prototype$map,\n    'fantasy-land/bimap':     Pair$prototype$bimap,\n    'fantasy-land/reduce':    Pair$prototype$reduce,\n    'fantasy-land/traverse':  Pair$prototype$traverse,\n    'fantasy-land/extend':    Pair$prototype$extend,\n    'fantasy-land/extract':   Pair$prototype$extract,\n    /* eslint-enable key-spacing */\n  };\n\n  /* istanbul ignore else */\n  if (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  ) {\n    prototype[\n      Symbol.for ('nodejs.util.inspect.custom')  // added in Node.js v10.12.0\n    ] = Pair$prototype$show;\n  }\n  /* istanbul ignore if */\n  if (typeof Deno !== 'undefined') {\n    if (Deno != null && typeof Deno.customInspect === 'symbol') {\n      prototype[Deno.customInspect] = Pair$prototype$show;\n    }\n  }\n\n  /* istanbul ignore else */\n  if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n    prototype[Symbol.iterator] = function() {\n      return [this.fst, this.snd][Symbol.iterator] ();\n    };\n  }\n\n  //. `Pair a b` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Pair (Useless) (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Pair (['foo']) (['bar'])) ? '\\u2705 * ' :\n  //. .              /* otherwise */                        '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid           * ',  // if a and b satisfy Setoid\n  //. . 'Ord              * ',  // if a and b satisfy Ord\n  //. . 'Semigroupoid       ',\n  //. . 'Category           ',\n  //. . 'Semigroup        * ',  // if a and b satisfy Semigroup\n  //. . 'Monoid             ',\n  //. . 'Group              ',\n  //. . 'Filterable         ',\n  //. . 'Functor            ',\n  //. . 'Bifunctor          ',\n  //. . 'Profunctor         ',\n  //. . 'Apply            * ',  // if a satisfies Semigroup\n  //. . 'Applicative        ',\n  //. . 'Chain            * ',  // if a satisfies Semigroup\n  //. . 'ChainRec           ',\n  //. . 'Monad              ',\n  //. . 'Alt                ',\n  //. . 'Plus               ',\n  //. . 'Alternative        ',\n  //. . 'Foldable           ',\n  //. . 'Traversable        ',\n  //. . 'Extend             ',\n  //. . 'Comonad            ',\n  //. . 'Contravariant      ' ]\n  //. ```\n\n  //# Pair :: a -> b -> Pair a b\n  //.\n  //. Pair's sole data constructor. Additionally, it serves as the\n  //. Pair [type representative][].\n  //.\n  //. ```javascript\n  //. > Pair (1) (2)\n  //. Pair (1) (2)\n  //. ```\n  function Pair(fst) {\n    return snd => {\n      const pair = Object.create (prototype);\n      if (Z.Setoid.test (fst) && Z.Setoid.test (snd)) {\n        pair['fantasy-land/equals'] = Pair$prototype$equals;\n        if (Z.Ord.test (fst) && Z.Ord.test (snd)) {\n          pair['fantasy-land/lte'] = Pair$prototype$lte;\n        }\n      }\n      if (Z.Semigroup.test (fst)) {\n        if (Z.Semigroup.test (snd)) {\n          pair['fantasy-land/concat'] = Pair$prototype$concat;\n        }\n        pair['fantasy-land/ap'] = Pair$prototype$ap;\n        pair['fantasy-land/chain'] = Pair$prototype$chain;\n      }\n      pair.fst = fst;\n      pair.snd = snd;\n      return pair;\n    };\n  }\n\n  //# Pair.fst :: Pair a b -> a\n  //.\n  //. `fst (Pair (x) (y))` is equivalent to `x`.\n  //.\n  //. ```javascript\n  //. > Pair.fst (Pair ('abc') ([1, 2, 3]))\n  //. 'abc'\n  //. ```\n  Pair.fst = p => p.fst;\n\n  //# Pair.snd :: Pair a b -> b\n  //.\n  //. `snd (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > Pair.snd (Pair ('abc') ([1, 2, 3]))\n  //. [1, 2, 3]\n  //. ```\n  Pair.snd = p => p.snd;\n\n  //# Pair.swap :: Pair a b -> Pair b a\n  //.\n  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n  //.\n  //. ```javascript\n  //. > Pair.swap (Pair ('abc') ([1, 2, 3]))\n  //. Pair ([1, 2, 3]) ('abc')\n  //. ```\n  Pair.swap = p => Pair (p.snd) (p.fst);\n\n  //# Pair#@@show :: (Showable a, Showable b) => Pair a b ~> () -> String\n  //.\n  //. `show (Pair (x) (y))` is equivalent to\n  //. `'Pair (' + show (x) + ') (' + show (y) + ')'`.\n  //.\n  //. ```javascript\n  //. > S.show (Pair ('abc') ([1, 2, 3]))\n  //. 'Pair (\"abc\") ([1, 2, 3])'\n  //. ```\n  function Pair$prototype$show() {\n    return 'Pair (' + show (this.fst) + ') (' + show (this.snd) + ')';\n  }\n\n  //# Pair#fantasy-land/equals :: (Setoid a, Setoid b) => Pair a b ~> Pair a b -> Boolean\n  //.\n  //. `Pair (x) (y)` is equal to `Pair (v) (w)` [iff][] `x` is equal to `v`\n  //. and `y` is equal to `w` according to [`Z.equals`][].\n  //.\n  //. ```javascript\n  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([3, 2, 1]))\n  //. false\n  //. ```\n  function Pair$prototype$equals(other) {\n    return Z.equals (this.fst, other.fst) && Z.equals (this.snd, other.snd);\n  }\n\n  //# Pair#fantasy-land/lte :: (Ord a, Ord b) => Pair a b ~> Pair a b -> Boolean\n  //.\n  //. `Pair (x) (y)` is less than or equal to `Pair (v) (w)` [iff][] `x` is\n  //. less than `v` or `x` is equal to `v` and `y` is less than or equal to\n  //. `w` according to [`Z.lte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Pair ('b') (2)))\n  //. .          ([Pair ('a') (1), Pair ('a') (2), Pair ('a') (3),\n  //. .            Pair ('b') (1), Pair ('b') (2), Pair ('b') (3),\n  //. .            Pair ('c') (1), Pair ('c') (2), Pair ('c') (3)])\n  //. [ Pair ('a') (1),\n  //. . Pair ('a') (2),\n  //. . Pair ('a') (3),\n  //. . Pair ('b') (1),\n  //. . Pair ('b') (2) ]\n  //. ```\n  function Pair$prototype$lte(other) {\n    return Z.equals (this.fst, other.fst) ? Z.lte (this.snd, other.snd)\n                                          : Z.lte (this.fst, other.fst);\n  }\n\n  //# Pair#fantasy-land/compose :: Pair a b ~> Pair b c -> Pair a c\n  //.\n  //. `compose (Pair (x) (y)) (Pair (v) (w))` is equivalent to `Pair (v) (y)`.\n  //.\n  //. ```javascript\n  //. > S.compose (Pair ('a') (0)) (Pair ([1, 2, 3]) ('b'))\n  //. Pair ([1, 2, 3]) (0)\n  //. ```\n  function Pair$prototype$compose(other) {\n    return Pair (this.fst) (other.snd);\n  }\n\n  //# Pair#fantasy-land/concat :: (Semigroup a, Semigroup b) => Pair a b ~> Pair a b -> Pair a b\n  //.\n  //. `concat (Pair (x) (y)) (Pair (v) (w))` is equivalent to\n  //. `Pair (concat (x) (v)) (concat (y) (w))`.\n  //.\n  //. ```javascript\n  //. > S.concat (Pair ('abc') ([1, 2, 3])) (Pair ('xyz') ([4, 5, 6]))\n  //. Pair ('abcxyz') ([1, 2, 3, 4, 5, 6])\n  //. ```\n  function Pair$prototype$concat(other) {\n    return Pair (Z.concat (this.fst, other.fst))\n                (Z.concat (this.snd, other.snd));\n  }\n\n  //# Pair#fantasy-land/map :: Pair a b ~> (b -> c) -> Pair a c\n  //.\n  //. `map (f) (Pair (x) (y))` is equivalent to `Pair (x) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (Pair ('abc') (256))\n  //. Pair ('abc') (16)\n  //. ```\n  function Pair$prototype$map(f) {\n    return Pair (this.fst) (f (this.snd));\n  }\n\n  //# Pair#fantasy-land/bimap :: Pair a c ~> (a -> b, c -> d) -> Pair b d\n  //.\n  //. `bimap (f) (g) (Pair (x) (y))` is equivalent to `Pair (f (x)) (g (y))`.\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (Math.sqrt) (Pair ('abc') (256))\n  //. Pair ('ABC') (16)\n  //. ```\n  function Pair$prototype$bimap(f, g) {\n    return Pair (f (this.fst)) (g (this.snd));\n  }\n\n  //# Pair#fantasy-land/ap :: Semigroup a => Pair a b ~> Pair a (b -> c) -> Pair a c\n  //.\n  //. `ap (Pair (v) (f)) (Pair (x) (y))` is equivalent to\n  //. `Pair (concat (v) (x)) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.ap (Pair ('abc') (Math.sqrt)) (Pair ('xyz') (256))\n  //. Pair ('abcxyz') (16)\n  //. ```\n  function Pair$prototype$ap(other) {\n    return Pair (Z.concat (other.fst, this.fst)) (other.snd (this.snd));\n  }\n\n  //# Pair#fantasy-land/chain :: Semigroup a => Pair a b ~> (b -> Pair a c) -> Pair a c\n  //.\n  //. `chain (f) (Pair (x) (y))` is equivalent to\n  //. `Pair (concat (x) (fst (f (y)))) (snd (f (y)))`.\n  //.\n  //. ```javascript\n  //. > S.chain (n => Pair (S.show (n)) (Math.sqrt (n))) (Pair ('abc') (256))\n  //. Pair ('abc256') (16)\n  //. ```\n  function Pair$prototype$chain(f) {\n    const other = f (this.snd);\n    return Pair (Z.concat (this.fst, other.fst)) (other.snd);\n  }\n\n  //# Pair#fantasy-land/reduce :: Pair a b ~> ((c, b) -> c, c) -> c\n  //.\n  //. `reduce (f) (x) (Pair (v) (w))` is equivalent to `f (x) (w)`.\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ([1, 2, 3]) (Pair ('abc') ([4, 5, 6]))\n  //. [1, 2, 3, 4, 5, 6]\n  //. ```\n  function Pair$prototype$reduce(f, x) {\n    return f (x, this.snd);\n  }\n\n  //# Pair#fantasy-land/traverse :: Applicative f => Pair a b ~> (TypeRep f, b -> f c) -> f (Pair a c)\n  //.\n  //. `traverse (_) (f) (Pair (x) (y))` is equivalent to\n  //. `map (Pair (x)) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Pair (123) ('foo bar baz'))\n  //. [Pair (123) ('foo'), Pair (123) ('bar'), Pair (123) ('baz')]\n  //. ```\n  function Pair$prototype$traverse(typeRep, f) {\n    return Z.map (Pair (this.fst), f (this.snd));\n  }\n\n  //# Pair#fantasy-land/extend :: Pair a b ~> (Pair a b -> c) -> Pair a c\n  //.\n  //. `extend (f) (Pair (x) (y))` is equivalent to\n  //. `Pair (x) (f (Pair (x) (y)))`.\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Pair ('abc') (99))\n  //. Pair ('abc') (100)\n  //. ```\n  function Pair$prototype$extend(f) {\n    return Pair (this.fst) (f (this));\n  }\n\n  //# Pair#fantasy-land/extract :: Pair a b ~> () -> b\n  //.\n  //. `extract (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > S.extract (Pair ('abc') ([1, 2, 3]))\n  //. [1, 2, 3]\n  //. ```\n  function Pair$prototype$extract() {\n    return this.snd;\n  }\n\n  return Pair;\n\n});\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n","/*    #######\n   ####     ####\n ####   ###   ####\n#####   ###########   sanctuary\n########   ########   noun\n###########   #####   1 [ mass noun ] refuge from unsafe JavaScript\n ####   ###   ####\n   ####     ####\n      #######    */\n\n//. # Sanctuary\n//.\n//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)\n//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n//.\n//. Sanctuary is a JavaScript functional programming library inspired by\n//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\n//. provides a similar suite of functions.\n//.\n//. Sanctuary promotes programs composed of simple, pure functions. Such\n//. programs are easier to comprehend, test, and maintain &ndash; they are\n//. also a pleasure to write.\n//.\n//. Sanctuary provides two data types, [Maybe][] and [Either][], both of\n//. which are compatible with [Fantasy Land][]. Thanks to these data types\n//. even Sanctuary functions that may fail, such as [`head`](#head), are\n//. composable.\n//.\n//. Sanctuary makes it possible to write safe code without null checks.\n//. In JavaScript it's trivial to introduce a possible run-time type error:\n//.\n//.     words[0].toUpperCase()\n//.\n//. If `words` is `[]` we'll get a familiar error at run-time:\n//.\n//.     TypeError: Cannot read property 'toUpperCase' of undefined\n//.\n//. Sanctuary gives us a fighting chance of avoiding such errors. We might\n//. write:\n//.\n//.     S.map (S.toUpper) (S.head (words))\n//.\n//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.\n//.\n//. ## Folktale\n//.\n//. [Folktale][], like Sanctuary, is a standard library for functional\n//. programming in JavaScript. It is well designed and well documented.\n//. Whereas Sanctuary treats JavaScript as a member of the ML language\n//. family, Folktale embraces JavaScript's object-oriented programming\n//. model. Programming with Folktale resembles programming with Scala.\n//.\n//. ## Ramda\n//.\n//. [Ramda][] provides several functions that return problematic values\n//. such as `undefined`, `Infinity`, or `NaN` when applied to unsuitable\n//. inputs. These are known as [partial functions][]. Partial functions\n//. necessitate the use of guards or null checks. In order to safely use\n//. `R.head`, for example, one must ensure that the array is non-empty:\n//.\n//.     if (R.isEmpty (xs)) {\n//.       // ...\n//.     } else {\n//.       return f (R.head (xs));\n//.     }\n//.\n//. Using the Maybe type renders such guards (and null checks) unnecessary.\n//. Changing functions such as `R.head` to return Maybe values was proposed\n//. in [ramda/ramda#683][], but was considered too much of a stretch for\n//. JavaScript programmers. Sanctuary was released the following month,\n//. in January 2015, as a companion library to Ramda.\n//.\n//. In addition to broadening in scope in the years since its release,\n//. Sanctuary's philosophy has diverged from Ramda's in several respects.\n//.\n//. ### Totality\n//.\n//. Every Sanctuary function is defined for every value that is a member of\n//. the function's input type. Such functions are known as [total functions][].\n//. Ramda, on the other hand, contains a number of [partial functions][].\n//.\n//. ### Information preservation\n//.\n//. Certain Sanctuary functions preserve more information than their Ramda\n//. counterparts. Examples:\n//.\n//.     |> R.tail ([])                      |> S.tail ([])\n//.     []                                  Nothing\n//.\n//.     |> R.tail (['foo'])                 |> S.tail (['foo'])\n//.     []                                  Just ([])\n//.\n//.     |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')\n//.     'abc'                               Nothing\n//.\n//.     |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')\n//.     'abc'                               Just ('abc')\n//.\n//. ### Invariants\n//.\n//. Sanctuary performs rigorous [type checking][] of inputs and outputs, and\n//. throws a descriptive error if a type error is encountered. This allows bugs\n//. to be caught and fixed early in the development cycle.\n//.\n//. Ramda operates on the [garbage in, garbage out][GIGO] principle. Functions\n//. are documented to take arguments of particular types, but these invariants\n//. are not enforced. The problem with this approach in a language as\n//. permissive as JavaScript is that there's no guarantee that garbage input\n//. will produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc\n//. type checking in some such cases ([ramda/ramda#1419][]).\n//.\n//. Sanctuary can be configured to operate in garbage in, garbage out mode.\n//. Ramda cannot be configured to enforce its invariants.\n//.\n//. ### Currying\n//.\n//. Sanctuary functions are curried. There is, for example, exactly one way to\n//. apply `S.reduce` to `S.add`, `0`, and `xs`:\n//.\n//.   - `S.reduce (S.add) (0) (xs)`\n//.\n//. Ramda functions are also curried, but in a complex manner. There are four\n//. ways to apply `R.reduce` to `R.add`, `0`, and `xs`:\n//.\n//.   - `R.reduce (R.add) (0) (xs)`\n//.   - `R.reduce (R.add) (0, xs)`\n//.   - `R.reduce (R.add, 0) (xs)`\n//.   - `R.reduce (R.add, 0, xs)`\n//.\n//. Ramda supports all these forms because curried functions enable partial\n//. application, one of the library's tenets, but `f(x)(y)(z)` is considered\n//. too unfamiliar and too unattractive to appeal to JavaScript programmers.\n//.\n//. Sanctuary's developers prefer a simple, unfamiliar construct to a complex,\n//. familiar one. Familiarity can be acquired; complexity is intrinsic.\n//.\n//. The lack of breathing room in `f(x)(y)(z)` impairs readability. The simple\n//. solution to this problem, proposed in [#438][], is to include a space when\n//. applying a function: `f (x) (y) (z)`.\n//.\n//. Ramda also provides a special placeholder value, [`R.__`][], that removes\n//. the restriction that a function must be applied to its arguments in order.\n//. The following expressions are equivalent:\n//.\n//.   - `R.reduce (R.__, 0, xs) (R.add)`\n//.   - `R.reduce (R.add, R.__, xs) (0)`\n//.   - `R.reduce (R.__, 0) (R.add) (xs)`\n//.   - `R.reduce (R.__, 0) (R.add, xs)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add) (0)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add, 0)`\n//.\n//. ### Variadic functions\n//.\n//. Ramda provides several functions that take any number of arguments. These\n//. are known as [variadic functions][]. Additionally, Ramda provides several\n//. functions that take variadic functions as arguments. Although natural in\n//. a dynamically typed language, variadic functions are at odds with the type\n//. notation Ramda and Sanctuary both use, leading to some indecipherable type\n//. signatures such as this one:\n//.\n//.     R.lift :: (*... -> *...) -> ([*]... -> [*])\n//.\n//. Sanctuary has no variadic functions, nor any functions that take variadic\n//. functions as arguments. Sanctuary provides two \"lift\" functions, each with\n//. a helpful type signature:\n//.\n//.     S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n//.     S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n//.\n//. ### Implicit context\n//.\n//. Ramda provides [`R.bind`][] and [`R.invoker`][] for working with methods.\n//. Additionally, many Ramda functions use `Function#call` or `Function#apply`\n//. to preserve context. Sanctuary makes no allowances for `this`.\n//.\n//. ### Transducers\n//.\n//. Several Ramda functions act as transducers. Sanctuary provides no support\n//. for transducers.\n//.\n//. ### Modularity\n//.\n//. Whereas Ramda has no dependencies, Sanctuary has a modular design:\n//. [sanctuary-def][] provides type checking, [sanctuary-type-classes][]\n//. provides Fantasy Land functions and type classes, [sanctuary-show][]\n//. provides string representations, and algebraic data types are provided\n//. by [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].\n//. Not only does this approach reduce the complexity of Sanctuary itself,\n//. but it allows these components to be reused in other contexts.\n//.\n//. ## Types\n//.\n//. Sanctuary uses Haskell-like type signatures to describe the types of\n//. values, including functions. `'foo'`, for example, is a member of `String`;\n//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\n//. to mean \"is a member of\", so one could write:\n//.\n//.     'foo' :: String\n//.     [1, 2, 3] :: Array Number\n//.\n//. An identifier may appear to the left of the double colon:\n//.\n//.     Math.PI :: Number\n//.\n//. The arrow (`->`) is used to express a function's type:\n//.\n//.     Math.abs :: Number -> Number\n//.\n//. That states that `Math.abs` is a unary function that takes an argument\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Some functions are parametrically polymorphic: their types are not fixed.\n//. Type variables are used in the representations of such functions:\n//.\n//.     S.I :: a -> a\n//.\n//. `a` is a type variable. Type variables are not capitalized, so they\n//. are differentiable from type identifiers (which are always capitalized).\n//. By convention type variables have single-character names. The signature\n//. above states that `S.I` takes a value of any type and returns a value of\n//. the same type. Some signatures feature multiple type variables:\n//.\n//.     S.K :: a -> b -> a\n//.\n//. It must be possible to replace all occurrences of `a` with a concrete type.\n//. The same applies for each other type variable. For the function above, the\n//. types with which `a` and `b` are replaced may be different, but needn't be.\n//.\n//. Since all Sanctuary functions are curried (they accept their arguments\n//. one at a time), a binary function is represented as a unary function that\n//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\n//. which uses curried functions exclusively. In JavaScript, though, we may\n//. wish to represent the types of functions with arities less than or greater\n//. than one. The general form is `(<input-types>) -> <output-type>`, where\n//. `<input-types>` comprises zero or more commaspace (<code>, </code>)\n//. -separated type representations:\n//.\n//.   - `() -> String`\n//.   - `(a, b) -> a`\n//.   - `(a, b, c) -> d`\n//.\n//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n//.\n//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,\n//. but these can be simulated by providing a group of data constructors that\n//. return values with the same set of methods. A value of the Either type, for\n//. example, is created via the Left constructor or the Right constructor.\n//.\n//. It's necessary to extend Haskell's notation to describe implicit arguments\n//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\n//. the `map` method takes an implicit argument `x` in addition to the explicit\n//. argument `y`. The type of the value upon which a method is invoked appears\n//. at the beginning of the signature, separated from the arguments and return\n//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\n//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\n//. read this as:\n//.\n//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),\n//. it returns a value of type `Maybe b`._\n//.\n//. The squiggly arrow is also used when representing non-function properties.\n//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value\n//. of type `Maybe a`.\n//.\n//. Sanctuary supports type classes: constraints on type variables. Whereas\n//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\n//. f b` requires that `f` be a type that satisfies the requirements of the\n//. Functor type class. Type-class constraints appear at the beginning of a\n//. type signature, separated from the rest of the signature by a fat arrow\n//. (`=>`).\n//.\n//. ## Type checking\n//.\n//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time\n//. type checking. This is tremendously useful during development: type errors\n//. are reported immediately, avoiding circuitous stack traces (at best) and\n//. silent failures due to type coercion (at worst). For example:\n//.\n//. ```javascript\n//. S.add (2) (true);\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//. //                          ^^^^^^^^^^^^\n//. //                               1\n//. //\n//. //   1)  true :: Boolean\n//. //\n//. //   The value at position 1 is not a member of FiniteNumber.\n//. //\n//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the FiniteNumber type.\n//. ```\n//.\n//. Compare this to the behaviour of Ramda's unchecked equivalent:\n//.\n//. ```javascript\n//. R.add (2) (true);\n//. // => 3\n//. ```\n//.\n//. There is a performance cost to run-time type checking. Type checking is\n//. disabled by default if `process.env.NODE_ENV` is `'production'`. If this\n//. rule is unsuitable for a given program, one may use [`create`](#create)\n//. to create a Sanctuary module based on a different rule. For example:\n//.\n//. ```javascript\n//. const S = sanctuary.create ({\n//.   checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',\n//.   env: sanctuary.env,\n//. });\n//. ```\n//.\n//. Occasionally one may wish to perform an operation that is not type safe,\n//. such as mapping over an object with heterogeneous values. This is possible\n//. via selective use of [`unchecked`](#unchecked) functions.\n//.\n//. ## Installation\n//.\n//. `npm install sanctuary` will install Sanctuary for use in Node.js.\n//.\n//. To add Sanctuary to a website, add the following `<script>` element,\n//. replacing `X.Y.Z` with a version number greater than or equal to `2.0.2`:\n//.\n//. ```html\n//. <script src=\"https://cdn.jsdelivr.net/gh/sanctuary-js/sanctuary@X.Y.Z/dist/bundle.js\"></script>\n//. ```\n//.\n//. Optionally, define aliases for various modules:\n//.\n//. ```javascript\n//. const S = window.sanctuary;\n//. const $ = window.sanctuaryDef;\n//. // ...\n//. ```\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-def'),\n                        require ('sanctuary-either'),\n                        require ('sanctuary-maybe'),\n                        require ('sanctuary-pair'),\n                        require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'),\n                        require ('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-def',\n             'sanctuary-either',\n             'sanctuary-maybe',\n             'sanctuary-pair',\n             'sanctuary-show',\n             'sanctuary-type-classes',\n             'sanctuary-type-identifiers'],\n            f);\n  } else {\n    self.sanctuary = f (self.sanctuaryDef,\n                        self.sanctuaryEither,\n                        self.sanctuaryMaybe,\n                        self.sanctuaryPair,\n                        self.sanctuaryShow,\n                        self.sanctuaryTypeClasses,\n                        self.sanctuaryTypeIdentifiers);\n  }\n\n} (function($, Either, Maybe, Pair, show, Z, type) {\n\n  'use strict';\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars */\n    var Descending = __doctest.require ('sanctuary-descending');\n    var Nil = (__doctest.require ('./test/internal/List')).Nil;\n    var Cons = (__doctest.require ('./test/internal/List')).Cons;\n    var Sum = __doctest.require ('./test/internal/Sum');\n    var S = (function(S) {\n      var S_ = S.create ({\n        checkTypes: true,\n        env: S.env.concat ([\n          (__doctest.require ('./test/internal/List')).Type ($.Unknown),\n          Sum.Type\n        ])\n      });\n      S_.env = S.env;  // see S.env doctest\n      return S_;\n    } (require ('.')));\n    /* eslint-enable no-unused-vars */\n  }\n\n  //  Left :: a -> Either a b\n  var Left = Either.Left;\n\n  //  Right :: b -> Either a b\n  var Right = Either.Right;\n\n  //  Nothing :: Maybe a\n  var Nothing = Maybe.Nothing;\n\n  //  Just :: a -> Maybe a\n  var Just = Maybe.Just;\n\n  //  B :: (b -> c) -> (a -> b) -> a -> c\n  function B(f) {\n    return function(g) {\n      return function(x) {\n        return f (g (x));\n      };\n    };\n  }\n\n  //  C :: (a -> b -> c) -> b -> a -> c\n  function C(f) {\n    return function(y) {\n      return function(x) {\n        return f (x) (y);\n      };\n    };\n  }\n\n  //  curry2 :: ((a, b) -> c) -> a -> b -> c\n  function curry2(f) {\n    return function(x) {\n      return function(y) {\n        return f (x, y);\n      };\n    };\n  }\n\n  //  curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d\n  function curry3(f) {\n    return function(x) {\n      return function(y) {\n        return function(z) {\n          return f (x, y, z);\n        };\n      };\n    };\n  }\n\n  //  curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e\n  function curry4(f) {\n    return function(w) {\n      return function(x) {\n        return function(y) {\n          return function(z) {\n            return f (w, x, y, z);\n          };\n        };\n      };\n    };\n  }\n\n  //  get_ :: String -> a -> Maybe b\n  function get_(key) {\n    return B (function(obj) { return key in obj ? Just (obj[key]) : Nothing; })\n             (toObject);\n  }\n\n  //  invoke0 :: String -> a -> b\n  function invoke0(name) {\n    return function(target) {\n      return target[name] ();\n    };\n  }\n\n  //  invoke1 :: String -> a -> b -> c\n  function invoke1(name) {\n    return function(x) {\n      return function(target) {\n        return target[name] (x);\n      };\n    };\n  }\n\n  //  toObject :: a -> Object\n  function toObject(x) {\n    return x == null ? Object.create (null) : Object (x);\n  }\n\n  //  :: Type\n  var a = $.TypeVariable ('a');\n  var b = $.TypeVariable ('b');\n  var c = $.TypeVariable ('c');\n  var d = $.TypeVariable ('d');\n  var e = $.TypeVariable ('e');\n  var g = $.TypeVariable ('g');\n\n  //  :: Type -> Type\n  var f = $.UnaryTypeVariable ('f');\n  var m = $.UnaryTypeVariable ('m');\n  var t = $.UnaryTypeVariable ('t');\n  var w = $.UnaryTypeVariable ('w');\n\n  //  :: Type -> Type -> Type\n  var p = $.BinaryTypeVariable ('p');\n  var s = $.BinaryTypeVariable ('s');\n\n  //  Throwing :: Type -> Type -> Type -> Type\n  //\n  //  `Throwing e a b` is the type of functions from `a` to `b` that may\n  //  throw values of type `e`.\n  function Throwing(E) {\n    return function(A) {\n      return function(B) {\n        var T = $.Fn (A) (B);\n        T.format = function(outer, inner) {\n          return outer ('Throwing ' + show (E)) +\n                 outer (' ') + inner ('$1') (show (A)) +\n                 outer (' ') + inner ('$2') (show (B));\n        };\n        return T;\n      };\n    };\n  }\n\n  //  TypeRep :: Type -> Type\n  var TypeRep = $.UnaryType\n    ('TypeRep')\n    ('https://github.com/fantasyland/fantasy-land#type-representatives')\n    ([])\n    (K (true))\n    (K ([]));\n\n  //  Options :: Type\n  var Options = $.RecordType ({checkTypes: $.Boolean, env: $.Array ($.Any)});\n\n  var _ = {};\n\n  //. ### Configure\n\n  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module\n  //.\n  //. Takes an options record and returns a Sanctuary module. `checkTypes`\n  //. specifies whether to enable type checking. The module's polymorphic\n  //. functions (such as [`I`](#I)) require each value associated with a\n  //. type variable to be a member of at least one type in the environment.\n  //.\n  //. A well-typed application of a Sanctuary function will produce the same\n  //. result regardless of whether type checking is enabled. If type checking\n  //. is enabled, a badly typed application will produce an exception with a\n  //. descriptive error message.\n  //.\n  //. The following snippet demonstrates defining a custom type and using\n  //. `create` to produce a Sanctuary module that is aware of that type:\n  //.\n  //. ```javascript\n  //. const {create, env} = require ('sanctuary');\n  //. const $ = require ('sanctuary-def');\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    Identity :: a -> Identity a\n  //. const Identity = x => {\n  //.   const identity = Object.create (Identity$prototype);\n  //.   identity.value = x;\n  //.   return identity;\n  //. };\n  //.\n  //. //    identityTypeIdent :: String\n  //. const identityTypeIdent = 'my-package/Identity@1';\n  //.\n  //. const Identity$prototype = {\n  //.   '@@type': identityTypeIdent,\n  //.   '@@show': function() { return `Identity (${S.show (this.value)})`; },\n  //.   'fantasy-land/map': function(f) { return Identity (f (this.value)); },\n  //. };\n  //.\n  //. //    IdentityType :: Type -> Type\n  //. const IdentityType = $.UnaryType\n  //.   ('Identity')\n  //.   ('http://example.com/my-package#Identity')\n  //.   ([])\n  //.   (x => type (x) === identityTypeIdent)\n  //.   (identity => [identity.value]);\n  //.\n  //. const S = create ({\n  //.   checkTypes: process.env.NODE_ENV !== 'production',\n  //.   env: env.concat ([IdentityType ($.Unknown)]),\n  //. });\n  //.\n  //. S.map (S.sub (1)) (Identity (43));\n  //. // => Identity (42)\n  //. ```\n  //.\n  //. See also [`env`](#env).\n  function create(opts) {\n    var def = $.create (opts);\n    var S = {\n      env: opts.env,\n      is: def ('is') ({}) ([$.Type, $.Any, $.Boolean]) ($.test (opts.env)),\n      Maybe: Maybe,\n      Nothing: Nothing,\n      Either: Either\n    };\n    (Object.keys (_)).forEach (function(name) {\n      S[name] = def (name) (_[name].consts) (_[name].types) (_[name].impl);\n    });\n    S.unchecked = opts.checkTypes ? create ({checkTypes: false, env: opts.env})\n                                  : S;\n    return S;\n  }\n  _.create = {\n    consts: {},\n    types: [Options, $.Object],\n    impl: create\n  };\n\n  //# env :: Array Type\n  //.\n  //. The Sanctuary module's environment (`(S.create ({checkTypes, env})).env`\n  //. is a reference to `env`). Useful in conjunction with [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.env\n  //. [ $.AnyFunction,\n  //. . $.Arguments,\n  //. . $.Array ($.Unknown),\n  //. . $.Array2 ($.Unknown) ($.Unknown),\n  //. . $.Boolean,\n  //. . $.Buffer,\n  //. . $.Date,\n  //. . $.Descending ($.Unknown),\n  //. . $.Either ($.Unknown) ($.Unknown),\n  //. . $.Error,\n  //. . $.Fn ($.Unknown) ($.Unknown),\n  //. . $.HtmlElement,\n  //. . $.Identity ($.Unknown),\n  //. . $.JsMap ($.Unknown) ($.Unknown),\n  //. . $.JsSet ($.Unknown),\n  //. . $.Maybe ($.Unknown),\n  //. . $.Module,\n  //. . $.Null,\n  //. . $.Number,\n  //. . $.Object,\n  //. . $.Pair ($.Unknown) ($.Unknown),\n  //. . $.RegExp,\n  //. . $.StrMap ($.Unknown),\n  //. . $.String,\n  //. . $.Symbol,\n  //. . $.Type,\n  //. . $.TypeClass,\n  //. . $.Undefined ]\n  //. ```\n\n  //# unchecked :: Module\n  //.\n  //. A complete Sanctuary module that performs no type checking. This is\n  //. useful as it permits operations that Sanctuary's type checking would\n  //. disallow, such as mapping over an object with heterogeneous values.\n  //.\n  //. See also [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})\n  //. {x: '\"foo\"', y: 'true', z: '42'}\n  //. ```\n  //.\n  //. Opting out of type checking may cause type errors to go unnoticed.\n  //.\n  //. ```javascript\n  //. > S.unchecked.add (2) ('2')\n  //. '22'\n  //. ```\n\n  //. ### Classify\n\n  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }\n  //.\n  //. Returns the result of parsing the [type identifier][] of the given value.\n  //.\n  //. ```javascript\n  //. > S.type (S.Just (42))\n  //. {namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}\n  //.\n  //. > S.type ([1, 2, 3])\n  //. {namespace: Nothing, name: 'Array', version: 0}\n  //. ```\n  function type_(x) {\n    var r = type.parse (type (x));\n    r.namespace = Z.reject (equals (null), Just (r.namespace));\n    return r;\n  }\n  _.type = {\n    consts: {},\n    types: [$.Any,\n            $.RecordType ({namespace: $.Maybe ($.String),\n                           name: $.String,\n                           version: $.NonNegativeInteger})],\n    impl: type_\n  };\n\n  //# is :: Type -> Any -> Boolean\n  //.\n  //. Returns `true` [iff][] the given value is a member of the specified type.\n  //. See [`$.test`][] for details.\n  //.\n  //. ```javascript\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3])\n  //. true\n  //.\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3.14])\n  //. false\n  //. ```\n\n  //. ### Showable\n\n  //# show :: Any -> String\n  //.\n  //. Alias of [`show`][].\n  //.\n  //. ```javascript\n  //. > S.show (-0)\n  //. '-0'\n  //.\n  //. > S.show (['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > S.show ({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > S.show (S.Left (S.Right (S.Just (S.Nothing))))\n  //. 'Left (Right (Just (Nothing)))'\n  //. ```\n  _.show = {\n    consts: {},\n    types: [$.Any, $.String],\n    impl: show\n  };\n\n  //. ### Fantasy Land\n  //.\n  //. Sanctuary is compatible with the [Fantasy Land][] specification.\n\n  //# equals :: Setoid a => a -> a -> Boolean\n  //.\n  //. Curried version of [`Z.equals`][] that requires two arguments of the\n  //. same type.\n  //.\n  //. To compare values of different types first use [`create`](#create) to\n  //. create a Sanctuary module with type checking disabled, then use that\n  //. module's `equals` function.\n  //.\n  //. ```javascript\n  //. > S.equals (0) (-0)\n  //. true\n  //.\n  //. > S.equals (NaN) (NaN)\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))\n  //. false\n  //. ```\n  function equals(x) {\n    return function(y) {\n      return Z.equals (x, y);\n    };\n  }\n  _.equals = {\n    consts: {a: [Z.Setoid]},\n    types: [a, a, $.Boolean],\n    impl: equals\n  };\n\n  //# lt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than the first\n  //. according to [`Z.lt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lt (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2]\n  //. ```\n  function lt(y) {\n    return function(x) {\n      return Z.lt (x, y);\n    };\n  }\n  _.lt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lt\n  };\n\n  //# lte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than or equal to\n  //. the first according to [`Z.lte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2, 3]\n  //. ```\n  function lte(y) {\n    return function(x) {\n      return Z.lte (x, y);\n    };\n  }\n  _.lte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lte\n  };\n\n  //# gt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than the first\n  //. according to [`Z.gt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gt (3)) ([1, 2, 3, 4, 5])\n  //. [4, 5]\n  //. ```\n  function gt(y) {\n    return function(x) {\n      return Z.gt (x, y);\n    };\n  }\n  _.gt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gt\n  };\n\n  //# gte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than or equal\n  //. to the first according to [`Z.gte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gte (3)) ([1, 2, 3, 4, 5])\n  //. [3, 4, 5]\n  //. ```\n  function gte(y) {\n    return function(x) {\n      return Z.gte (x, y);\n    };\n  }\n  _.gte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gte\n  };\n\n  //# min :: Ord a => a -> a -> a\n  //.\n  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.min (10) (2)\n  //. 2\n  //.\n  //. > S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('1999-12-31')\n  //.\n  //. > S.min ('10') ('2')\n  //. '10'\n  //. ```\n  _.min = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.min)\n  };\n\n  //# max :: Ord a => a -> a -> a\n  //.\n  //. Returns the larger of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > S.max (10) (2)\n  //. 10\n  //.\n  //. > S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('2000-01-01')\n  //.\n  //. > S.max ('10') ('2')\n  //. '2'\n  //. ```\n  _.max = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.max)\n  };\n\n  //# clamp :: Ord a => a -> a -> a -> a\n  //.\n  //. Takes a lower bound, an upper bound, and a value of the same type.\n  //. Returns the value if it is within the bounds; the nearer bound otherwise.\n  //.\n  //. See also [`min`](#min) and [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.clamp (0) (100) (42)\n  //. 42\n  //.\n  //. > S.clamp (0) (100) (-1)\n  //. 0\n  //.\n  //. > S.clamp ('A') ('Z') ('~')\n  //. 'Z'\n  //. ```\n  _.clamp = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a, a],\n    impl: curry3 (Z.clamp)\n  };\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.id`][].\n  //.\n  //. ```javascript\n  //. > S.id (Function) (42)\n  //. 42\n  //. ```\n  _.id = {\n    consts: {c: [Z.Category]},\n    types: [TypeRep (c), c],\n    impl: Z.id\n  };\n\n  //# concat :: Semigroup a => a -> a -> a\n  //.\n  //. Curried version of [`Z.concat`][].\n  //.\n  //. ```javascript\n  //. > S.concat ('abc') ('def')\n  //. 'abcdef'\n  //.\n  //. > S.concat ([1, 2, 3]) ([4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > S.concat ({x: 1, y: 2}) ({y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))\n  //. Just ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Sum (18)) (Sum (24))\n  //. Sum (42)\n  //. ```\n  _.concat = {\n    consts: {a: [Z.Semigroup]},\n    types: [a, a, a],\n    impl: curry2 (Z.concat)\n  };\n\n  //# empty :: Monoid a => TypeRep a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].\n  //.\n  //. ```javascript\n  //. > S.empty (String)\n  //. ''\n  //.\n  //. > S.empty (Array)\n  //. []\n  //.\n  //. > S.empty (Object)\n  //. {}\n  //.\n  //. > S.empty (Sum)\n  //. Sum (0)\n  //. ```\n  _.empty = {\n    consts: {a: [Z.Monoid]},\n    types: [TypeRep (a), a],\n    impl: Z.empty\n  };\n\n  //# invert :: Group g => g -> g\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].\n  //.\n  //. ```javascript\n  //. > S.invert (Sum (5))\n  //. Sum (-5)\n  //. ```\n  _.invert = {\n    consts: {g: [Z.Group]},\n    types: [g, g],\n    impl: Z.invert\n  };\n\n  //# filter :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.filter`][]. Discards every element that does not\n  //. satisfy the predicate.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > S.filter (S.odd) ([1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > S.filter (S.odd) ({x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > S.filter (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (0))\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (1))\n  //. Just (1)\n  //. ```\n  function filter(pred) {\n    return function(filterable) {\n      return Z.filter (pred, filterable);\n    };\n  }\n  _.filter = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: filter\n  };\n\n  //# reject :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.reject`][]. Discards every element that satisfies\n  //. the predicate.\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > S.reject (S.odd) ([1, 2, 3])\n  //. [2]\n  //.\n  //. > S.reject (S.odd) ({x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > S.reject (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.reject (S.odd) (S.Just (0))\n  //. Just (0)\n  //.\n  //. > S.reject (S.odd) (S.Just (1))\n  //. Nothing\n  //. ```\n  function reject(pred) {\n    return function(filterable) {\n      return Z.reject (pred, filterable);\n    };\n  }\n  _.reject = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: reject\n  };\n\n  //# map :: Functor f => (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.map`][].\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) ([1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > S.map (Math.sqrt) ({x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > S.map (Math.sqrt) (S.Just (9))\n  //. Just (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Right (9))\n  //. Right (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Pair (99980001) (99980001))\n  //. Pair (99980001) (9999)\n  //. ```\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the B combinator\n  //. from combinatory logic (i.e. [`compose`](#compose)):\n  //.\n  //.     Functor f => (a -> b) -> f a -> f b\n  //.     (a -> b) -> Function x a -> Function x b\n  //.     (a -> b) -> (x -> a) -> (x -> b)\n  //.     (a -> b) -> (x -> a) -> x -> b\n  //.     (b -> c) -> (a -> b) -> a -> c\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  function map(f) {\n    return function(functor) {\n      return Z.map (f, functor);\n    };\n  }\n  _.map = {\n    consts: {f: [Z.Functor]},\n    types: [$.Fn (a) (b), f (a), f (b)],\n    impl: map\n  };\n\n  //# flip :: Functor f => f (a -> b) -> a -> f b\n  //.\n  //. Curried version of [`Z.flip`][]. Maps over the given functions, applying\n  //. each to the given value.\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the C combinator\n  //. from combinatory logic:\n  //.\n  //.     Functor f => f (a -> b) -> a -> f b\n  //.     Function x (a -> b) -> a -> Function x b\n  //.     (x -> (a -> b)) -> a -> (x -> b)\n  //.     (x -> a -> b) -> a -> x -> b\n  //.     (a -> b -> c) -> b -> a -> c\n  //.\n  //. ```javascript\n  //. > S.flip (S.concat) ('!') ('foo')\n  //. 'foo!'\n  //.\n  //. > S.flip ([Math.floor, Math.ceil]) (1.5)\n  //. [1, 2]\n  //.\n  //. > S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)\n  //. Cons (1) (Cons (2) (Nil))\n  //. ```\n  function flip(functor) {\n    return function(x) {\n      return Z.flip (functor, x);\n    };\n  }\n  _.flip = {\n    consts: {f: [Z.Functor]},\n    types: [f ($.Fn (a) (b)), a, f (b)],\n    impl: flip\n  };\n\n  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d\n  //.\n  //. Curried version of [`Z.bimap`][].\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (8)\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))\n  //. Right (8)\n  //. ```\n  _.bimap = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (a) (c), p (b) (d)],\n    impl: curry3 (Z.bimap)\n  };\n\n  //# mapLeft :: Bifunctor f => (a -> b) -> f a c -> f b c\n  //.\n  //. Curried version of [`Z.mapLeft`][]. Maps the given function over the left\n  //. side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > S.mapLeft (S.toUpper) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (64)\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Right (64))\n  //. Right (64)\n  //. ```\n  _.mapLeft = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), p (a) (c), p (b) (c)],\n    impl: curry2 (Z.mapLeft)\n  };\n\n  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d\n  //.\n  //. Curried version of [`Z.promap`][].\n  //.\n  //. ```javascript\n  //. > S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)\n  //. 11\n  //. ```\n  _.promap = {\n    consts: {p: [Z.Profunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (b) (c), p (a) (d)],\n    impl: curry3 (Z.promap)\n  };\n\n  //# alt :: Alt f => f a -> f a -> f a\n  //.\n  //. Curried version of [`Z.alt`][] with arguments flipped to facilitate\n  //. partial application.\n  //.\n  //. ```javascript\n  //. > S.alt (S.Just ('default')) (S.Nothing)\n  //. Just ('default')\n  //.\n  //. > S.alt (S.Just ('default')) (S.Just ('hello'))\n  //. Just ('hello')\n  //.\n  //. > S.alt (S.Right (0)) (S.Left ('X'))\n  //. Right (0)\n  //.\n  //. > S.alt (S.Right (0)) (S.Right (1))\n  //. Right (1)\n  //. ```\n  function alt(y) {\n    return function(x) {\n      return Z.alt (x, y);\n    };\n  }\n  _.alt = {\n    consts: {f: [Z.Alt]},\n    types: [f (a), f (a), f (a)],\n    impl: alt\n  };\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].\n  //.\n  //. ```javascript\n  //. > S.zero (Array)\n  //. []\n  //.\n  //. > S.zero (Object)\n  //. {}\n  //.\n  //. > S.zero (S.Maybe)\n  //. Nothing\n  //. ```\n  _.zero = {\n    consts: {f: [Z.Plus]},\n    types: [TypeRep (f (a)), f (a)],\n    impl: Z.zero\n  };\n\n  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b\n  //.\n  //. Takes a curried binary function, an initial value, and a [Foldable][],\n  //. and applies the function to the initial value and the Foldable's first\n  //. value, then applies the function to the result of the previous\n  //. application and the Foldable's second value. Repeats this process\n  //. until each of the Foldable's values has been used. Returns the initial\n  //. value if the Foldable is empty; the result of the final application\n  //. otherwise.\n  //.\n  //. See also [`reduce_`](#reduce_).\n  //.\n  //. ```javascript\n  //. > S.reduce (S.add) (0) ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])\n  //. [5, 4, 3, 2, 1]\n  //. ```\n  function reduce(f) {\n    return function(initial) {\n      return function(foldable) {\n        return Z.reduce (function(y, x) { return f (y) (x); },\n                         initial,\n                         foldable);\n      };\n    };\n  }\n  _.reduce = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (b) ($.Fn (a) (b)), b, f (a), b],\n    impl: reduce\n  };\n\n  //# reduce_ :: Foldable f => (a -> b -> b) -> b -> f a -> b\n  //.\n  //. Variant of [`reduce`](#reduce) that takes a reducing function with\n  //. arguments flipped.\n  //.\n  //. ```javascript\n  //. > S.reduce_ (S.append) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. [1, 2, 3]\n  //.\n  //. > S.reduce_ (S.prepend) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. [3, 2, 1]\n  //. ```\n  _.reduce_ = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (a) ($.Fn (b) (b)), b, f (a), b],\n    impl: B (reduce) (flip)\n  };\n\n  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)\n  //.\n  //. Curried version of [`Z.traverse`][].\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (S.Just ('foo bar baz'))\n  //. [Just ('foo'), Just ('bar'), Just ('baz')]\n  //.\n  //. > S.traverse (Array) (S.words) (S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])\n  //. Just ([10, 11, 12])\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])\n  //. Nothing\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})\n  //. Just ({a: 10, b: 11, c: 12})\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})\n  //. Nothing\n  //. ```\n  _.traverse = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (b)), $.Fn (a) (f (b)), t (a), f (t (b))],\n    impl: curry3 (Z.traverse)\n  };\n\n  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)\n  //.\n  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`\n  //. to produce an `f (t a)`.\n  //.\n  //. ```javascript\n  //. > S.sequence (Array) (S.Just ([1, 2, 3]))\n  //. [Just (1), Just (2), Just (3)]\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])\n  //. Nothing\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})\n  //. Just ({a: 1, b: 2, c: 3})\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})\n  //. Nothing\n  //. ```\n  _.sequence = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (a)), t (f (a)), f (t (a))],\n    impl: curry2 (Z.sequence)\n  };\n\n  //# ap :: Apply f => f (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.ap`][].\n  //.\n  //. ```javascript\n  //. > S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})\n  //. {x: 2, y: 5}\n  //.\n  //. > S.ap (S.Just (Math.sqrt)) (S.Just (64))\n  //. Just (8)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces the S combinator\n  //. from combinatory logic:\n  //.\n  //.     Apply f => f (a -> b) -> f a -> f b\n  //.     Function x (a -> b) -> Function x a -> Function x b\n  //.     (x -> (a -> b)) -> (x -> a) -> (x -> b)\n  //.     (x -> a -> b) -> (x -> a) -> x -> b\n  //.     (a -> b -> c) -> (a -> b) -> a -> c\n  //.\n  //. ```javascript\n  //. > S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')\n  //. 'Hask'\n  //. ```\n  _.ap = {\n    consts: {f: [Z.Apply]},\n    types: [f ($.Fn (a) (b)), f (a), f (b)],\n    impl: curry2 (Z.ap)\n  };\n\n  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.\n  //. Promotes a curried binary function to a function that operates on two\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Just (3))\n  //. Just (5)\n  //.\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (true))\n  //. Just (true)\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (false))\n  //. Just (false)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces a combinator known\n  //. by various names including [`apply2way`][] and [`converge`][]:\n  //.\n  //.     Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.     (a -> b -> c) -> Function x a -> Function x b -> Function x c\n  //.     (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)\n  //.     (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c\n  //.     (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\n  //.\n  //. ```javascript\n  //. > S.lift2 (x => y => ({x, y}))\n  //. .         (s => s + '.')\n  //. .         (s => s + '?')\n  //. .         ('Hello')\n  //. {x: 'Hello.', y: 'Hello?'}\n  //. ```\n  _.lift2 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) (c)), f (a), f (b), f (c)],\n    impl: curry3 (Z.lift2)\n  };\n\n  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.\n  //. Promotes a curried ternary function to a function that operates on three\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))\n  //. Just (6)\n  //.\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)\n  //. Nothing\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces a combinator that\n  //. applies the three given unary functions to the given input value, then\n  //. applies the given ternary function to the three intermediate results\n  //. to determine the final result:\n  //.\n  //.     Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.     (a -> b -> c -> d) -> Function x a -> Function x b -> Function x c -> Function x d\n  //.     (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> (x -> d)\n  //.     (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> x -> d\n  //.     (b -> c -> d -> e) -> (a -> b) -> (a -> c) -> (a -> d) -> a -> e\n  //.\n  //. ```javascript\n  //. > S.lift3 (x => y => z => ({x, y, z}))\n  //. .         (s => s + '.')\n  //. .         (s => s + '?')\n  //. .         (s => s + '!')\n  //. .         ('Hello')\n  //. {x: 'Hello.', y: 'Hello?', z: 'Hello!'}\n  //. ```\n  _.lift3 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) ($.Fn (c) (d))), f (a), f (b), f (c), f (d)],\n    impl: curry4 (Z.lift3)\n  };\n\n  //# apFirst :: Apply f => f a -> f b -> f a\n  //.\n  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,\n  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`\n  //. function.\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > S.apFirst ([1, 2]) ([3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > S.apFirst (S.Just (1)) (S.Just (2))\n  //. Just (1)\n  //. ```\n  _.apFirst = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (a)],\n    impl: curry2 (Z.apFirst)\n  };\n\n  //# apSecond :: Apply f => f a -> f b -> f b\n  //.\n  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,\n  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`\n  //. function.\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > S.apSecond ([1, 2]) ([3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > S.apSecond (S.Just (1)) (S.Just (2))\n  //. Just (2)\n  //. ```\n  _.apSecond = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (b)],\n    impl: curry2 (Z.apSecond)\n  };\n\n  //# of :: Applicative f => TypeRep f -> a -> f a\n  //.\n  //. Curried version of [`Z.of`][].\n  //.\n  //. ```javascript\n  //. > S.of (Array) (42)\n  //. [42]\n  //.\n  //. > S.of (Function) (42) (null)\n  //. 42\n  //.\n  //. > S.of (S.Maybe) (42)\n  //. Just (42)\n  //.\n  //. > S.of (S.Either) (42)\n  //. Right (42)\n  //. ```\n  function of(typeRep) {\n    return function(x) {\n      return Z.of (typeRep, x);\n    };\n  }\n  _.of = {\n    consts: {f: [Z.Applicative]},\n    types: [TypeRep (f (a)), a, f (a)],\n    impl: of\n  };\n\n  //# chain :: Chain m => (a -> m b) -> m a -> m b\n  //.\n  //. Curried version of [`Z.chain`][].\n  //.\n  //. ```javascript\n  //. > S.chain (x => [x, x]) ([1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')\n  //. 'sli'\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('123'))\n  //. Just (123)\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('XXX'))\n  //. Nothing\n  //. ```\n  _.chain = {\n    consts: {m: [Z.Chain]},\n    types: [$.Fn (a) (m (b)), m (a), m (b)],\n    impl: curry2 (Z.chain)\n  };\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.join`][].\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. ```javascript\n  //. > S.join ([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > S.join ([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > S.join (S.Just (S.Just (1)))\n  //. Just (1)\n  //.\n  //. > S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))\n  //. Pair ('foobar') ('baz')\n  //. ```\n  //.\n  //. Replacing `Chain m => m` with `Function x` produces the W combinator\n  //. from combinatory logic:\n  //.\n  //.     Chain m => m (m a) -> m a\n  //.     Function x (Function x a) -> Function x a\n  //.     (x -> (x -> a)) -> (x -> a)\n  //.     (x -> x -> a) -> x -> a\n  //.     (a -> a -> b) -> a -> b\n  //.\n  //. ```javascript\n  //. > S.join (S.concat) ('abc')\n  //. 'abcabc'\n  //. ```\n  _.join = {\n    consts: {m: [Z.Chain]},\n    types: [m (m (a)), m (a)],\n    impl: Z.join\n  };\n\n  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b\n  //.\n  //. Performs a [`chain`](#chain)-like computation with constant stack usage.\n  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the\n  //. use of the Either type to indicate completion (via a Right).\n  //.\n  //. ```javascript\n  //. > S.chainRec (Array)\n  //. .            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])\n  //. .                                 : S.map (S.Left) ([s + 'o', s + 'n']))\n  //. .            ('')\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep) {\n    return function(f) {\n      return function(x) {\n        return Z.chainRec (typeRep, step, x);\n      };\n      function step(next, done, x) {\n        return Z.map (either (next) (done), f (x));\n      }\n    };\n  }\n  _.chainRec = {\n    consts: {m: [Z.ChainRec]},\n    types: [TypeRep (m (b)), $.Fn (a) (m ($.Either (a) (b))), a, m (b)],\n    impl: chainRec\n  };\n\n  //# extend :: Extend w => (w a -> b) -> w a -> w b\n  //.\n  //. Curried version of [`Z.extend`][].\n  //.\n  //. ```javascript\n  //. > S.extend (S.joinWith ('')) (['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.extend = {\n    consts: {w: [Z.Extend]},\n    types: [$.Fn (w (a)) (b), w (a), w (b)],\n    impl: curry2 (Z.extend)\n  };\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.duplicate`][].\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. ```javascript\n  //. > S.duplicate (S.Just (1))\n  //. Just (Just (1))\n  //.\n  //. > S.duplicate ([1])\n  //. [[1]]\n  //.\n  //. > S.duplicate ([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > S.duplicate (S.reverse) ([1, 2]) ([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.duplicate = {\n    consts: {w: [Z.Extend]},\n    types: [w (a), w (w (a))],\n    impl: Z.duplicate\n  };\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].\n  //.\n  //. ```javascript\n  //. > S.extract (S.Pair ('foo') ('bar'))\n  //. 'bar'\n  //. ```\n  _.extract = {\n    consts: {w: [Z.Comonad]},\n    types: [w (a), a],\n    impl: Z.extract\n  };\n\n  //# contramap :: Contravariant f => (b -> a) -> f a -> f b\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].\n  //.\n  //. ```javascript\n  //. > S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')\n  //. 3\n  //. ```\n  _.contramap = {\n    consts: {f: [Z.Contravariant]},\n    types: [$.Fn (b) (a), f (a), f (b)],\n    impl: curry2 (Z.contramap)\n  };\n\n  //. ### Combinator\n\n  //# I :: a -> a\n  //.\n  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.I ('foo')\n  //. 'foo'\n  //. ```\n  function I(x) {\n    return x;\n  }\n  _.I = {\n    consts: {},\n    types: [a, a],\n    impl: I\n  };\n\n  //# K :: a -> b -> a\n  //.\n  //. The K combinator. Takes two values and returns the first. Equivalent to\n  //. Haskell's `const` function.\n  //.\n  //. ```javascript\n  //. > S.K ('foo') ('bar')\n  //. 'foo'\n  //.\n  //. > S.map (S.K (42)) (S.range (0) (5))\n  //. [42, 42, 42, 42, 42]\n  //. ```\n  function K(x) {\n    return function(y) {\n      return x;\n    };\n  }\n  _.K = {\n    consts: {},\n    types: [a, b, a],\n    impl: K\n  };\n\n  //# T :: a -> (a -> b) -> b\n  //.\n  //. The T ([thrush][]) combinator. Takes a value and a function, and returns\n  //. the result of applying the function to the value. Equivalent to Haskell's\n  //. `(&)` function.\n  //.\n  //. ```javascript\n  //. > S.T (42) (S.add (1))\n  //. 43\n  //.\n  //. > S.map (S.T (100)) ([S.add (1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function T(x) {\n    return function(f) {\n      return f (x);\n    };\n  }\n  _.T = {\n    consts: {},\n    types: [a, $.Fn (a) (b), b],\n    impl: T\n  };\n\n  //. ### Composition\n\n  //# compose :: Semigroupoid s => s b c -> s a b -> s a c\n  //.\n  //. Curried version of [`Z.compose`][].\n  //.\n  //. When specialized to Function, `compose` composes two unary functions,\n  //. from right to left (this is the B combinator from combinatory logic).\n  //.\n  //. The generalized type signature indicates that `compose` is compatible\n  //. with any [Semigroupoid][].\n  //.\n  //. See also [`pipe`](#pipe).\n  //.\n  //. ```javascript\n  //. > S.compose (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  _.compose = {\n    consts: {s: [Z.Semigroupoid]},\n    types: [s (b) (c), s (a) (b), s (a) (c)],\n    impl: curry2 (Z.compose)\n  };\n\n  //# pipe :: Foldable f => f (Any -> Any) -> a -> b\n  //.\n  //. Takes a sequence of functions assumed to be unary and a value of any\n  //. type, and returns the result of applying the sequence of transformations\n  //. to the initial value.\n  //.\n  //. In general terms, `pipe` performs left-to-right composition of a sequence\n  //. of functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)\n  //. 9\n  //. ```\n  function pipe(fs) {\n    return function(x) {\n      return reduce (T) (x) (fs);\n    };\n  }\n  _.pipe = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Fn ($.Any) ($.Any)), a, b],\n    impl: pipe\n  };\n\n  //# pipeK :: (Foldable f, Chain m) => f (Any -> m Any) -> m a -> m b\n  //.\n  //. Takes a sequence of functions assumed to be unary that return values\n  //. with a [Chain][], and a value of that Chain, and returns the result\n  //. of applying the sequence of transformations to the initial value.\n  //.\n  //. In general terms, `pipeK` performs left-to-right [Kleisli][] composition\n  //. of an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to\n  //. `chain (h) (chain (g) (chain (f) (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))\n  //. Just (3)\n  //. ```\n  function pipeK(fs) {\n    return function(x) {\n      return Z.reduce (function(x, f) { return Z.chain (f, x); }, x, fs);\n    };\n  }\n  _.pipeK = {\n    consts: {f: [Z.Foldable], m: [Z.Chain]},\n    types: [f ($.Fn ($.Any) (m ($.Any))), m (a), m (b)],\n    impl: pipeK\n  };\n\n  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n  //.\n  //. Takes a binary function `f`, a unary function `g`, and two\n  //. values `x` and `y`. Returns `f (g (x)) (g (y))`.\n  //.\n  //. This is the P combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])\n  //. [3, 2, 1, 6, 5, 4]\n  //. ```\n  function on(f) {\n    return function(g) {\n      return function(x) {\n        return function(y) {\n          return f (g (x)) (g (y));\n        };\n      };\n    };\n  }\n  _.on = {\n    consts: {},\n    types: [$.Fn (b) ($.Fn (b) (c)), $.Fn (a) (b), a, a, c],\n    impl: on\n  };\n\n  //. ### Pair\n  //.\n  //. Pair is the canonical product type: a value of type `Pair a b` always\n  //. contains exactly two values: one of type `a`; one of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-pair][].\n\n  //# Pair :: a -> b -> Pair a b\n  //.\n  //. Pair's sole data constructor. Additionally, it serves as the\n  //. Pair [type representative][].\n  //.\n  //. ```javascript\n  //. > S.Pair ('foo') (42)\n  //. Pair ('foo') (42)\n  //. ```\n  _.Pair = {\n    consts: {},\n    types: [a, b, $.Pair (a) (b)],\n    impl: Pair\n  };\n\n  //# pair :: (a -> b -> c) -> Pair a b -> c\n  //.\n  //. Case analysis for the `Pair a b` type.\n  //.\n  //. ```javascript\n  //. > S.pair (S.concat) (S.Pair ('foo') ('bar'))\n  //. 'foobar'\n  //. ```\n  function pair(f) {\n    return function(pair) {\n      return f (pair.fst) (pair.snd);\n    };\n  }\n  _.pair = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Pair (a) (b), c],\n    impl: pair\n  };\n\n  //# fst :: Pair a b -> a\n  //.\n  //. `fst (Pair (x) (y))` is equivalent to `x`.\n  //.\n  //. ```javascript\n  //. > S.fst (S.Pair ('foo') (42))\n  //. 'foo'\n  //. ```\n  _.fst = {\n    consts: {},\n    types: [$.Pair (a) (b), a],\n    impl: pair (K)\n  };\n\n  //# snd :: Pair a b -> b\n  //.\n  //. `snd (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > S.snd (S.Pair ('foo') (42))\n  //. 42\n  //. ```\n  _.snd = {\n    consts: {},\n    types: [$.Pair (a) (b), b],\n    impl: pair (C (K))\n  };\n\n  //# swap :: Pair a b -> Pair b a\n  //.\n  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n  //.\n  //. ```javascript\n  //. > S.swap (S.Pair ('foo') (42))\n  //. Pair (42) ('foo')\n  //. ```\n  _.swap = {\n    consts: {},\n    types: [$.Pair (a) (b), $.Pair (b) (a)],\n    impl: pair (C (Pair))\n  };\n\n  //. ### Maybe\n  //.\n  //. The Maybe type represents optional values: a value of type `Maybe a` is\n  //. either Nothing (the empty value) or a Just whose value is of type `a`.\n  //.\n  //. The implementation is provided by [sanctuary-maybe][].\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. Maybe [type representative][].\n\n  //# Nothing :: Maybe a\n  //.\n  //. The empty value of type `Maybe a`.\n  //.\n  //. ```javascript\n  //. > S.Nothing\n  //. Nothing\n  //. ```\n\n  //# Just :: a -> Maybe a\n  //.\n  //. Constructs a value of type `Maybe a` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Just (42)\n  //. Just (42)\n  //. ```\n  _.Just = {\n    consts: {},\n    types: [a, $.Maybe (a)],\n    impl: Just\n  };\n\n  //# isNothing :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.\n  //.\n  //. ```javascript\n  //. > S.isNothing (S.Nothing)\n  //. true\n  //.\n  //. > S.isNothing (S.Just (42))\n  //. false\n  //. ```\n  function isNothing(maybe) {\n    return maybe.isNothing;\n  }\n  _.isNothing = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isNothing\n  };\n\n  //# isJust :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.\n  //.\n  //. ```javascript\n  //. > S.isJust (S.Just (42))\n  //. true\n  //.\n  //. > S.isJust (S.Nothing)\n  //. false\n  //. ```\n  function isJust(maybe) {\n    return maybe.isJust;\n  }\n  _.isJust = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isJust\n  };\n\n  //# maybe :: b -> (a -> b) -> Maybe a -> b\n  //.\n  //. Takes a value of any type, a function, and a Maybe. If the Maybe is\n  //. a Just, the return value is the result of applying the function to\n  //. the Just's value. Otherwise, the first argument is returned.\n  //.\n  //. See also [`maybe_`](#maybe_) and [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))\n  //. 6\n  //.\n  //. > S.maybe (0) (S.prop ('length')) (S.Nothing)\n  //. 0\n  //. ```\n  function maybe(x) {\n    return function(f) {\n      return function(maybe) {\n        return maybe.isJust ? f (maybe.value) : x;\n      };\n    };\n  }\n  _.maybe = {\n    consts: {},\n    types: [b, $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe\n  };\n\n  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b\n  //.\n  //. Variant of [`maybe`](#maybe) that takes a thunk so the default value\n  //. is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))\n  //. 1000\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)\n  //. 832040\n  //. ```\n  function maybe_(thunk) {\n    return function(f) {\n      return function(maybe) {\n        return maybe.isJust ? f (maybe.value) : thunk ();\n      };\n    };\n  }\n  _.maybe_ = {\n    consts: {},\n    types: [$.Thunk (b), $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe_\n  };\n\n  //# fromMaybe :: a -> Maybe a -> a\n  //.\n  //. Takes a default value and a Maybe, and returns the Maybe's value\n  //. if the Maybe is a Just; the default value otherwise.\n  //.\n  //. See also [`maybe`](#maybe), [`fromMaybe_`](#fromMaybe_), and\n  //. [`maybeToNullable`](#maybeToNullable).\n  //.\n  //. ```javascript\n  //. > S.fromMaybe (0) (S.Just (42))\n  //. 42\n  //.\n  //. > S.fromMaybe (0) (S.Nothing)\n  //. 0\n  //. ```\n  _.fromMaybe = {\n    consts: {},\n    types: [a, $.Maybe (a), a],\n    impl: C (maybe) (I)\n  };\n\n  //# fromMaybe_ :: (() -> a) -> Maybe a -> a\n  //.\n  //. Variant of [`fromMaybe`](#fromMaybe) that takes a thunk so the default\n  //. value is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Just (1000000))\n  //. 1000000\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Nothing)\n  //. 832040\n  //. ```\n  _.fromMaybe_ = {\n    consts: {},\n    types: [$.Thunk (a), $.Maybe (a), a],\n    impl: C (maybe_) (I)\n  };\n\n  //# justs :: (Filterable f, Functor f) => f (Maybe a) -> f a\n  //.\n  //. Discards each element that is Nothing, and unwraps each element that is\n  //. a Just. Related to Haskell's `catMaybes` function.\n  //.\n  //. See also [`lefts`](#lefts) and [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])\n  //. ['foo', 'baz']\n  //. ```\n  function justs(maybes) {\n    return map (prop ('value')) (filter (isJust) (maybes));\n  }\n  _.justs = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Maybe (a)), f (a)],\n    impl: justs\n  };\n\n  //# mapMaybe :: (Filterable f, Functor f) => (a -> Maybe b) -> f a -> f b\n  //.\n  //. Takes a function and a structure, applies the function to each element\n  //. of the structure, and returns the \"successful\" results. If the result of\n  //. applying the function to an element is Nothing, the result is discarded;\n  //. if the result is a Just, the Just's value is included.\n  //.\n  //. ```javascript\n  //. > S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])\n  //. [1, 4]\n  //.\n  //. > S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})\n  //. {x: 1, z: 4}\n  //. ```\n  _.mapMaybe = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [$.Fn (a) ($.Maybe (b)), f (a), f (b)],\n    impl: B (B (justs)) (map)\n  };\n\n  //# maybeToNullable :: Maybe a -> Nullable a\n  //.\n  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n  //. [Nullable][] is defined in [sanctuary-def][].\n  //.\n  //. See also [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToNullable (S.Just (42))\n  //. 42\n  //.\n  //. > S.maybeToNullable (S.Nothing)\n  //. null\n  //. ```\n  function maybeToNullable(maybe) {\n    return maybe.isJust ? maybe.value : null;\n  }\n  _.maybeToNullable = {\n    consts: {},\n    types: [$.Maybe (a), $.Nullable (a)],\n    impl: maybeToNullable\n  };\n\n  //. ### Either\n  //.\n  //. The Either type represents values with two possibilities: a value of type\n  //. `Either a b` is either a Left whose value is of type `a` or a Right whose\n  //. value is of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-either][].\n\n  //# Either :: TypeRep Either\n  //.\n  //. Either [type representative][].\n\n  //# Left :: a -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Left ('Cannot divide by zero')\n  //. Left ('Cannot divide by zero')\n  //. ```\n  _.Left = {\n    consts: {},\n    types: [a, $.Either (a) (b)],\n    impl: Left\n  };\n\n  //# Right :: b -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `b`.\n  //.\n  //. ```javascript\n  //. > S.Right (42)\n  //. Right (42)\n  //. ```\n  _.Right = {\n    consts: {},\n    types: [b, $.Either (a) (b)],\n    impl: Right\n  };\n\n  //# isLeft :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Left; `false` if it is a Right.\n  //.\n  //. ```javascript\n  //. > S.isLeft (S.Left ('Cannot divide by zero'))\n  //. true\n  //.\n  //. > S.isLeft (S.Right (42))\n  //. false\n  //. ```\n  function isLeft(either) {\n    return either.isLeft;\n  }\n  _.isLeft = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isLeft\n  };\n\n  //# isRight :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Right; `false` if it is a Left.\n  //.\n  //. ```javascript\n  //. > S.isRight (S.Right (42))\n  //. true\n  //.\n  //. > S.isRight (S.Left ('Cannot divide by zero'))\n  //. false\n  //. ```\n  function isRight(either) {\n    return either.isRight;\n  }\n  _.isRight = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isRight\n  };\n\n  //# either :: (a -> c) -> (b -> c) -> Either a b -> c\n  //.\n  //. Takes two functions and an Either, and returns the result of\n  //. applying the first function to the Left's value, if the Either\n  //. is a Left, or the result of applying the second function to the\n  //. Right's value, if the Either is a Right.\n  //.\n  //. See also [`fromLeft`](#fromLeft) and [`fromRight`](#fromRight).\n  //.\n  //. ```javascript\n  //. > S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))\n  //. 'CANNOT DIVIDE BY ZERO'\n  //.\n  //. > S.either (S.toUpper) (S.show) (S.Right (42))\n  //. '42'\n  //. ```\n  function either(l) {\n    return function(r) {\n      return function(either) {\n        return (either.isLeft ? l : r) (either.value);\n      };\n    };\n  }\n  _.either = {\n    consts: {},\n    types: [$.Fn (a) (c), $.Fn (b) (c), $.Either (a) (b), c],\n    impl: either\n  };\n\n  //# fromLeft :: a -> Either a b -> a\n  //.\n  //. Takes a default value and an Either, and returns the Left value\n  //. if the Either is a Left; the default value otherwise.\n  //.\n  //. See also [`either`](#either) and [`fromRight`](#fromRight).\n  //.\n  //. ```javascript\n  //. > S.fromLeft ('abc') (S.Left ('xyz'))\n  //. 'xyz'\n  //.\n  //. > S.fromLeft ('abc') (S.Right (123))\n  //. 'abc'\n  //. ```\n  function fromLeft(x) {\n    return either (I) (K (x));\n  }\n  _.fromLeft = {\n    consts: {},\n    types: [a, $.Either (a) (b), a],\n    impl: fromLeft\n  };\n\n  //# fromRight :: b -> Either a b -> b\n  //.\n  //. Takes a default value and an Either, and returns the Right value\n  //. if the Either is a Right; the default value otherwise.\n  //.\n  //. See also [`either`](#either) and [`fromLeft`](#fromLeft).\n  //.\n  //. ```javascript\n  //. > S.fromRight (123) (S.Right (789))\n  //. 789\n  //.\n  //. > S.fromRight (123) (S.Left ('abc'))\n  //. 123\n  //. ```\n  function fromRight(x) {\n    return either (K (x)) (I);\n  }\n  _.fromRight = {\n    consts: {},\n    types: [b, $.Either (a) (b), b],\n    impl: fromRight\n  };\n\n  //# fromEither :: Either a a -> a\n  //.\n  //. Takes an Either with the same type on the Left and on the Right\n  //. and returns whichever value exists.\n  //.\n  //. The inverse of [`tagBy`](#tagBy).\n  //.\n  //. ```javascript\n  //. > S.fromEither (S.Left (42))\n  //. 42\n  //.\n  //. > S.fromEither (S.Right (42))\n  //. 42\n  //. ```\n  _.fromEither = {\n    consts: {},\n    types: [$.Either (a) (a), a],\n    impl: either (I) (I)\n  };\n\n  //# lefts :: (Filterable f, Functor f) => f (Either a b) -> f a\n  //.\n  //. Discards each element that is a Right, and unwraps each element that is\n  //. a Left.\n  //.\n  //. See also [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. ['foo', 'bar']\n  //. ```\n  _.lefts = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (a)],\n    impl: B (map (prop ('value'))) (filter (isLeft))\n  };\n\n  //# rights :: (Filterable f, Functor f) => f (Either a b) -> f b\n  //.\n  //. Discards each element that is a Left, and unwraps each element that is\n  //. a Right.\n  //.\n  //. See also [`lefts`](#lefts).\n  //.\n  //. ```javascript\n  //. > S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. [20, 10]\n  //. ```\n  _.rights = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (b)],\n    impl: B (map (prop ('value'))) (filter (isRight))\n  };\n\n  //# tagBy :: (a -> Boolean) -> a -> Either a a\n  //.\n  //. Takes a predicate and a value, and returns a Right of the value if it\n  //. satisfies the predicate; a Left of the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.tagBy (S.odd) (0)\n  //. Left (0)\n  //\n  //. > S.tagBy (S.odd) (1)\n  //. Right (1)\n  //. ```\n  function tagBy(pred) {\n    return ifElse (pred) (Right) (Left);\n  }\n  _.tagBy = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Either (a) (a)],\n    impl: tagBy\n  };\n\n  //# encase :: Throwing e a b -> a -> Either e b\n  //.\n  //. Takes a function that may throw and returns a pure function.\n  //.\n  //. ```javascript\n  //. > S.encase (JSON.parse) ('[\"foo\",\"bar\",\"baz\"]')\n  //. Right (['foo', 'bar', 'baz'])\n  //.\n  //. > S.encase (JSON.parse) ('[')\n  //. Left (new SyntaxError ('Unexpected end of JSON input'))\n  //. ```\n  function encase(f) {\n    return function(x) {\n      try {\n        return Right (f (x));\n      } catch (err) {\n        return Left (err);\n      }\n    };\n  }\n  _.encase = {\n    consts: {},\n    types: [Throwing (e) (a) (b), a, $.Either (e) (b)],\n    impl: encase\n  };\n\n  //. ### Logic\n\n  //# and :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"and\".\n  //.\n  //. ```javascript\n  //. > S.and (false) (false)\n  //. false\n  //.\n  //. > S.and (false) (true)\n  //. false\n  //.\n  //. > S.and (true) (false)\n  //. false\n  //.\n  //. > S.and (true) (true)\n  //. true\n  //. ```\n  function and(x) {\n    return function(y) {\n      return x && y;\n    };\n  }\n  _.and = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: and\n  };\n\n  //# or :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"or\".\n  //.\n  //. ```javascript\n  //. > S.or (false) (false)\n  //. false\n  //.\n  //. > S.or (false) (true)\n  //. true\n  //.\n  //. > S.or (true) (false)\n  //. true\n  //.\n  //. > S.or (true) (true)\n  //. true\n  //. ```\n  function or(x) {\n    return function(y) {\n      return x || y;\n    };\n  }\n  _.or = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: or\n  };\n\n  //# not :: Boolean -> Boolean\n  //.\n  //. Boolean \"not\".\n  //.\n  //. See also [`complement`](#complement).\n  //.\n  //. ```javascript\n  //. > S.not (false)\n  //. true\n  //.\n  //. > S.not (true)\n  //. false\n  //. ```\n  function not(x) {\n    return !x;\n  }\n  _.not = {\n    consts: {},\n    types: [$.Boolean, $.Boolean],\n    impl: not\n  };\n\n  //# complement :: (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a unary predicate and a value of any type, and returns the logical\n  //. negation of applying the predicate to the value.\n  //.\n  //. See also [`not`](#not).\n  //.\n  //. ```javascript\n  //. > Number.isInteger (42)\n  //. true\n  //.\n  //. > S.complement (Number.isInteger) (42)\n  //. false\n  //. ```\n  _.complement = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Boolean],\n    impl: B (not)\n  };\n\n  //# boolean :: a -> a -> Boolean -> a\n  //.\n  //. Case analysis for the `Boolean` type. `boolean (x) (y) (b)` evaluates\n  //. to `x` if `b` is `false`; to `y` if `b` is `true`.\n  //.\n  //. ```javascript\n  //. > S.boolean ('no') ('yes') (false)\n  //. 'no'\n  //.\n  //. > S.boolean ('no') ('yes') (true)\n  //. 'yes'\n  //. ```\n  function boolean(x) {\n    return function(y) {\n      return function(b) {\n        return b ? y : x;\n      };\n    };\n  }\n  _.boolean = {\n    consts: {},\n    types: [a, a, $.Boolean, a],\n    impl: boolean\n  };\n\n  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\n  //.\n  //. Takes a unary predicate, a unary \"if\" function, a unary \"else\"\n  //. function, and a value of any type, and returns the result of\n  //. applying the \"if\" function to the value if the value satisfies\n  //. the predicate; the result of applying the \"else\" function to the\n  //. value otherwise.\n  //.\n  //. See also [`when`](#when) and [`unless`](#unless).\n  //.\n  //. ```javascript\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)\n  //. 1\n  //.\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)\n  //. 4\n  //. ```\n  function ifElse(pred) {\n    return function(f) {\n      return function(g) {\n        return function(x) {\n          return (pred (x) ? f : g) (x);\n        };\n      };\n    };\n  }\n  _.ifElse = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (b), $.Fn (a) (b), a, b],\n    impl: ifElse\n  };\n\n  //# when :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. satisfies the predicate; the value otherwise.\n  //.\n  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.when (x => x >= 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.when (x => x >= 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  function when(pred) {\n    return C (ifElse (pred)) (I);\n  }\n  _.when = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: when\n  };\n\n  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. does not satisfy the predicate; the value otherwise.\n  //.\n  //. See also [`when`](#when) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.unless (x => x < 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.unless (x => x < 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  function unless(pred) {\n    return ifElse (pred) (I);\n  }\n  _.unless = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: unless\n  };\n\n  //. ### Array\n\n  //# array :: b -> (a -> Array a -> b) -> Array a -> b\n  //.\n  //. Case analysis for the `Array a` type.\n  //.\n  //. ```javascript\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([1, 2, 3])\n  //. Just ([2, 3])\n  //. ```\n  function array(y) {\n    return function(f) {\n      return function(xs) {\n        return xs.length === 0 ? y : f (xs[0]) (xs.slice (1));\n      };\n    };\n  }\n  _.array = {\n    consts: {},\n    types: [b, $.Fn (a) ($.Fn ($.Array (a)) (b)), $.Array (a), b],\n    impl: array\n  };\n\n  //# head :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the first element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.head ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.head ([])\n  //. Nothing\n  //.\n  //. > S.head (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (1)\n  //.\n  //. > S.head (Nil)\n  //. Nothing\n  //. ```\n  function head(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[0]) : Nothing;\n    }\n    return Z.reduce (function(m, x) { return m.isJust ? m : Just (x); },\n                     Nothing,\n                     foldable);\n  }\n  _.head = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: head\n  };\n\n  //# last :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the last element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.last ([1, 2, 3])\n  //. Just (3)\n  //.\n  //. > S.last ([])\n  //. Nothing\n  //.\n  //. > S.last (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (3)\n  //.\n  //. > S.last (Nil)\n  //. Nothing\n  //. ```\n  function last(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[foldable.length - 1])\n                                 : Nothing;\n    }\n    return Z.reduce (function(_, x) { return Just (x); }, Nothing, foldable);\n  }\n  _.last = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: last\n  };\n\n  //# tail :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.tail ([1, 2, 3])\n  //. Just ([2, 3])\n  //.\n  //. > S.tail ([])\n  //. Nothing\n  //.\n  //. > S.tail (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (2) (Cons (3) (Nil)))\n  //\n  //. > S.tail (Nil)\n  //. Nothing\n  //. ```\n  function tail(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (1)) : Nothing;\n    }\n    var empty = Z.empty (foldable.constructor);\n    return Z.reduce (function(m, x) {\n      return Just (maybe (empty) (append (x)) (m));\n    }, Nothing, foldable);\n  }\n  _.tail = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: tail\n  };\n\n  //# init :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.init ([1, 2, 3])\n  //. Just ([1, 2])\n  //.\n  //. > S.init ([])\n  //. Nothing\n  //.\n  //. > S.init (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (1) (Cons (2) (Nil)))\n  //.\n  //. > S.init (Nil)\n  //. Nothing\n  //. ```\n  function init(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (0, -1)) : Nothing;\n    }\n    var empty = Z.empty (foldable.constructor);\n    return Z.map (Pair.snd, Z.reduce (function(m, x) {\n      return Just (Pair (x) (maybe (empty) (pair (append)) (m)));\n    }, Nothing, foldable));\n  }\n  _.init = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: init\n  };\n\n  //# take :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the first N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.take (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.take (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.take (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.take (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.take (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. ```\n  function _takeDrop(arrayCase, generalCase) {\n    return function(n) {\n      return function(xs) {\n        if (n < 0) return Nothing;\n\n        //  Fast path for arrays.\n        if (Array.isArray (xs)) {\n          return n <= xs.length ? Just (arrayCase (n, xs)) : Nothing;\n        }\n\n        //  m :: Maybe (Pair Integer (f a))\n        var m = Z.reduce (function(m, x) {\n          return Z.map (function(pair) {\n            var n = pair.fst;\n            var xs = pair.snd;\n            return Pair (n - 1) (generalCase (n, xs, x));\n          }, m);\n        }, Just (Pair (n) (Z.empty (xs.constructor))), xs);\n\n        return Z.map (Pair.snd, Z.reject (B (gt (0)) (Pair.fst), m));\n      };\n    };\n  }\n  var take = _takeDrop (\n    function(n, xs) { return xs.slice (0, n); },\n    function(n, xs, x) { return n > 0 ? Z.append (x, xs) : xs; }\n  );\n  _.take = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: take\n  };\n\n  //# drop :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.drop (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.drop (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.drop (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.drop (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.drop (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (4) (Cons (5) (Nil)))\n  //. ```\n  var drop = _takeDrop (\n    function(n, xs) { return xs.slice (n); },\n    function(n, xs, x) { return n > 0 ? xs : Z.append (x, xs); }\n  );\n  _.drop = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: drop\n  };\n\n  //# takeLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the last N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.takeLast (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.takeLast (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.takeLast (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.takeLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.takeLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (2) (Cons (3) (Cons (4) (Nil))))\n  //. ```\n  function takeLast(n) {\n    return function(xs) {\n      return Z.map (Z.reverse, take (n) (Z.reverse (xs)));\n    };\n  }\n  _.takeLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: takeLast\n  };\n\n  //# dropLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.dropLast (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.dropLast (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.dropLast (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.dropLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.dropLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (1) (Nil))\n  //. ```\n  function dropLast(n) {\n    return function(xs) {\n      return Z.map (Z.reverse, drop (n) (Z.reverse (xs)));\n    };\n  }\n  _.dropLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: dropLast\n  };\n\n  //# takeWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Discards the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7]\n  //.\n  //. > S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. []\n  //. ```\n  function takeWhile(pred) {\n    return function(xs) {\n      var idx = 0;\n      while (idx < xs.length && pred (xs[idx])) idx += 1;\n      return xs.slice (0, idx);\n    };\n  }\n  _.takeWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: takeWhile\n  };\n\n  //# dropWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Retains the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [6, 3, 5, 4]\n  //.\n  //. > S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7, 6, 3, 5, 4]\n  //. ```\n  function dropWhile(pred) {\n    return function(xs) {\n      var idx = 0;\n      while (idx < xs.length && pred (xs[idx])) idx += 1;\n      return xs.slice (idx);\n    };\n  }\n  _.dropWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: dropWhile\n  };\n\n  //# size :: Foldable f => f a -> NonNegativeInteger\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.size ([])\n  //. 0\n  //.\n  //. > S.size (['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > S.size (Nil)\n  //. 0\n  //.\n  //. > S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n  //. 3\n  //.\n  //. > S.size (S.Nothing)\n  //. 0\n  //.\n  //. > S.size (S.Just ('quux'))\n  //. 1\n  //.\n  //. > S.size (S.Pair ('ignored!') ('counted!'))\n  //. 1\n  //. ```\n  _.size = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.NonNegativeInteger],\n    impl: Z.size\n  };\n\n  //# all :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] all the elements of the structure satisfy the\n  //. predicate.\n  //.\n  //. See also [`any`](#any) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.all (S.odd) ([])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 3, 5])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.all = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.all)\n  };\n\n  //# any :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] any element of the structure satisfies the\n  //. predicate.\n  //.\n  //. See also [`all`](#all) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.any (S.odd) ([])\n  //. false\n  //.\n  //. > S.any (S.odd) ([2, 4, 6])\n  //. false\n  //.\n  //. > S.any (S.odd) ([1, 2, 3])\n  //. true\n  //. ```\n  _.any = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.any)\n  };\n\n  //# none :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] none of the elements of the structure satisfies\n  //. the predicate.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.not (S.any (p) (xs))`\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.all (S.complement (p)) (xs)`\n  //.\n  //. See also [`all`](#all) and [`any`](#any).\n  //.\n  //. ```javascript\n  //. > S.none (S.odd) ([])\n  //. true\n  //.\n  //. > S.none (S.odd) ([2, 4, 6])\n  //. true\n  //.\n  //. > S.none (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.none = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.none)\n  };\n\n  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > S.append (3) ([1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > S.append (3) (Cons (1) (Cons (2) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.append ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.append ([3]) (S.Just ([1, 2]))\n  //. Just ([1, 2, 3])\n  //. ```\n  function append(x) {\n    return function(xs) {\n      return Z.append (x, xs);\n    };\n  }\n  _.append = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: append\n  };\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > S.prepend (1) ([2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > S.prepend (1) (Cons (2) (Cons (3) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.prepend ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.prepend ([1]) (S.Just ([2, 3]))\n  //. Just ([1, 2, 3])\n  //. ```\n  _.prepend = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: curry2 (Z.prepend)\n  };\n\n  //# joinWith :: String -> Array String -> String\n  //.\n  //. Joins the strings of the second argument separated by the first argument.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s) (S.splitOn (s) (t)) = t`\n  //.\n  //. See also [`splitOn`](#splitOn) and [`intercalate`](#intercalate).\n  //.\n  //. ```javascript\n  //. > S.joinWith (':') (['foo', 'bar', 'baz'])\n  //. 'foo:bar:baz'\n  //. ```\n  _.joinWith = {\n    consts: {},\n    types: [$.String, $.Array ($.String), $.String],\n    impl: invoke1 ('join')\n  };\n\n  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` [iff][] the value is an\n  //. element of the structure.\n  //.\n  //. See also [`elem_`](#elem_) and [`find`](#find).\n  //.\n  //. ```javascript\n  //. > S.elem ('c') (['a', 'b', 'c'])\n  //. true\n  //.\n  //. > S.elem ('x') (['a', 'b', 'c'])\n  //. false\n  //.\n  //. > S.elem (3) ({x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > S.elem (8) ({x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > S.elem (0) (S.Just (0))\n  //. true\n  //.\n  //. > S.elem (0) (S.Just (1))\n  //. false\n  //.\n  //. > S.elem (0) (S.Nothing)\n  //. false\n  //. ```\n  var elem = (\n    curry2 (Z.elem)\n  );\n  _.elem = {\n    consts: {a: [Z.Setoid], f: [Z.Foldable]},\n    types: [a, f (a), $.Boolean],\n    impl: elem\n  };\n\n  //# elem_ :: (Setoid a, Foldable f) => f a -> a -> Boolean\n  //.\n  //. Variant of [`elem`](#elem) with arguments flipped.\n  //.\n  //. ```javascript\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['yes', 'no'])\n  //. ['yes']\n  //.\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['oui', 'non'])\n  //. ['oui']\n  //.\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['ja', 'nein'])\n  //. ['ja']\n  //. ```\n  _.elem_ = {\n    consts: {a: [Z.Setoid], f: [Z.Foldable]},\n    types: [f (a), a, $.Boolean],\n    impl: C (elem)\n  };\n\n  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a\n  //.\n  //. Takes a predicate and a structure and returns Just the leftmost element\n  //. of the structure that satisfies the predicate; Nothing if there is no\n  //. such element.\n  //.\n  //. See also [`findMap`](#findMap) and [`elem`](#elem).\n  //.\n  //. ```javascript\n  //. > S.find (S.lt (0)) ([1, -2, 3, -4, 5])\n  //. Just (-2)\n  //.\n  //. > S.find (S.lt (0)) ([1, 2, 3, 4, 5])\n  //. Nothing\n  //. ```\n  function find(pred) {\n    return findMap (function(x) { return pred (x) ? Just (x) : Nothing; });\n  }\n  _.find = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Maybe (a)],\n    impl: find\n  };\n\n  //# findMap :: Foldable f => (a -> Maybe b) -> f a -> Maybe b\n  //.\n  //. Finds the leftmost element of the given structure for which the given\n  //. function returns a Just, and returns that Just (or Nothing if none of\n  //. the elements matches).\n  //.\n  //. More flexible than [`find`](#find), and more convenient in situations\n  //. in which the result of a successful computation can be reused.\n  //.\n  //. ```javascript\n  //. > S.findMap (S.parseInt (16)) ([])\n  //. Nothing\n  //.\n  //. > S.findMap (S.parseInt (16)) (['X', 'Y', 'Z'])\n  //. Nothing\n  //.\n  //. > S.findMap (S.parseInt (16)) (['A', 'B', 'C'])\n  //. Just (10)\n  //. ```\n  function findMap(f) {\n    return function(xs) {\n      return Z.reduce (\n        function(m, x) { return m.isJust ? m : f (x); },\n        Nothing,\n        xs\n      );\n    };\n  }\n  _.findMap = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (a) ($.Maybe (b)), f (a), $.Maybe (b)],\n    impl: findMap\n  };\n\n  //# intercalate :: (Monoid m, Foldable f) => m -> f m -> m\n  //.\n  //. Curried version of [`Z.intercalate`][]. Concatenates the elements of\n  //. the given structure, separating each pair of adjacent elements with\n  //. the given separator.\n  //.\n  //. See also [`joinWith`](#joinWith).\n  //.\n  //. ```javascript\n  //. > S.intercalate (', ') ([])\n  //. ''\n  //.\n  //. > S.intercalate (', ') (['foo', 'bar', 'baz'])\n  //. 'foo, bar, baz'\n  //.\n  //. > S.intercalate (', ') (Nil)\n  //. ''\n  //.\n  //. > S.intercalate (', ') (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n  //. 'foo, bar, baz'\n  //.\n  //. > S.intercalate ([0, 0, 0]) ([])\n  //. []\n  //.\n  //. > S.intercalate ([0, 0, 0]) ([[1], [2, 3], [4, 5, 6], [7, 8], [9]])\n  //. [1, 0, 0, 0, 2, 3, 0, 0, 0, 4, 5, 6, 0, 0, 0, 7, 8, 0, 0, 0, 9]\n  //. ```\n  _.intercalate = {\n    consts: {a: [Z.Monoid], f: [Z.Foldable]},\n    types: [a, f (a), a],\n    impl: curry2 (Z.intercalate)\n  };\n\n  //# foldMap :: (Monoid m, Foldable f) => TypeRep m -> (a -> m) -> f a -> m\n  //.\n  //. Curried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping\n  //. every element to a monoid and concatenating the results.\n  //.\n  //. ```javascript\n  //. > S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //.\n  //. > S.foldMap (Array) (x => [x + 1, x + 2]) ([10, 20, 30])\n  //. [11, 12, 21, 22, 31, 32]\n  //. ```\n  _.foldMap = {\n    consts: {b: [Z.Monoid], f: [Z.Foldable]},\n    types: [TypeRep (b), $.Fn (a) (b), f (a), b],\n    impl: curry3 (Z.foldMap)\n  };\n\n  //# unfold :: (b -> Maybe (Pair a b)) -> b -> Array a\n  //.\n  //. Takes a function and a seed value, and returns an array generated by\n  //. applying the function repeatedly. The array is initially empty. The\n  //. function is initially applied to the seed value. Each application\n  //. of the function should result in either:\n  //.\n  //.   - Nothing, in which case the array is returned; or\n  //.\n  //.   - Just a pair, in which case the first element is appended to\n  //.     the array and the function is applied to the second element.\n  //.\n  //. ```javascript\n  //. > S.unfold (n => n < 1000 ? S.Just (S.Pair (n) (2 * n)) : S.Nothing) (1)\n  //. [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n  //. ```\n  function unfold(f) {\n    return function(x) {\n      var result = [];\n      for (var m = f (x); m.isJust; m = f (m.value.snd)) {\n        result.push (m.value.fst);\n      }\n      return result;\n    };\n  }\n  _.unfold = {\n    consts: {},\n    types: [$.Fn (b) ($.Maybe ($.Pair (a) (b))), b, $.Array (a)],\n    impl: unfold\n  };\n\n  //# range :: Integer -> Integer -> Array Integer\n  //.\n  //. Returns an array of consecutive integers starting with the first argument\n  //. and ending with the second argument minus one. Returns `[]` if the second\n  //. argument is less than or equal to the first argument.\n  //.\n  //. ```javascript\n  //. > S.range (0) (10)\n  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  //.\n  //. > S.range (-5) (0)\n  //. [-5, -4, -3, -2, -1]\n  //.\n  //. > S.range (0) (-5)\n  //. []\n  //. ```\n  function range(from) {\n    return function(to) {\n      var result = [];\n      for (var n = from; n < to; n += 1) result.push (n);\n      return result;\n    };\n  }\n  _.range = {\n    consts: {},\n    types: [$.Integer, $.Integer, $.Array ($.Integer)],\n    impl: range\n  };\n\n  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)\n  //.\n  //. Splits its array argument into an array of arrays of equal,\n  //. adjacent elements. Equality is determined by the function\n  //. provided as the first argument. Its behaviour can be surprising\n  //. for functions that aren't reflexive, transitive, and symmetric\n  //. (see [equivalence][] relation).\n  //.\n  //. Properties:\n  //.\n  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.\n  //.      S.join (S.groupBy (f) (xs)) = xs`\n  //.\n  //. ```javascript\n  //. > S.groupBy (S.equals) ([1, 1, 2, 1, 1])\n  //. [[1, 1], [2], [1, 1]]\n  //.\n  //. > S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])\n  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]\n  //. ```\n  function groupBy(f) {\n    return function(xs) {\n      if (xs.length === 0) return [];\n      var x0 = xs[0];         // :: a\n      var active = [x0];      // :: Array a\n      var result = [active];  // :: Array (Array a)\n      for (var idx = 1; idx < xs.length; idx += 1) {\n        var x = xs[idx];\n        if (f (x0) (x)) active.push (x); else result.push (active = [x0 = x]);\n      }\n      return result;\n    };\n  }\n  _.groupBy = {\n    consts: {},\n    types: [$.Fn (a) ($.Predicate (a)), $.Array (a), $.Array ($.Array (a))],\n    impl: groupBy\n  };\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.reverse ([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Cons (3) (Cons (2) (Cons (1) (Nil)))\n  //.\n  //. > S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')\n  //. 'cba'\n  //. ```\n  _.reverse = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), f (a)],\n    impl: Z.reverse\n  };\n\n  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] for comparisons.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > S.sort (['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])\n  //. [Left (2), Left (4), Right (1), Right (3)]\n  //. ```\n  _.sort = {\n    consts: {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [m (a), m (a)],\n    impl: Z.sort\n  };\n\n  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] to compare the values produced by applying the given function\n  //. to each element of the structure.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > S.sortBy (S.prop ('rank')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 2, suit: 'hearts'},\n  //. . {rank: 5, suit: 'hearts'},\n  //. . {rank: 5, suit: 'spades'},\n  //. . {rank: 7, suit: 'spades'} ]\n  //.\n  //. > S.sortBy (S.prop ('suit')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 5, suit: 'hearts'},\n  //. . {rank: 2, suit: 'hearts'},\n  //. . {rank: 7, suit: 'spades'},\n  //. . {rank: 5, suit: 'spades'} ]\n  //. ```\n  //.\n  //. If descending order is desired, one may use [`Descending`][]:\n  //.\n  //. ```javascript\n  //. > S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])\n  //. [121, 117, 116, 114, 110, 99, 97, 97, 83]\n  //. ```\n  _.sortBy = {\n    consts: {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Fn (a) (b), m (a), m (a)],\n    impl: curry2 (Z.sortBy)\n  };\n\n  //# zip :: Array a -> Array b -> Array (Pair a b)\n  //.\n  //. Returns an array of pairs of corresponding elements from the given\n  //. arrays. The length of the resulting array is equal to the length of\n  //. the shorter input array.\n  //.\n  //. See also [`zipWith`](#zipWith).\n  //.\n  //. ```javascript\n  //. > S.zip (['a', 'b']) (['x', 'y', 'z'])\n  //. [Pair ('a') ('x'), Pair ('b') ('y')]\n  //.\n  //. > S.zip ([1, 3, 5]) ([2, 4])\n  //. [Pair (1) (2), Pair (3) (4)]\n  //. ```\n  _.zip = {\n    consts: {},\n    types: [$.Array (a), $.Array (b), $.Array ($.Pair (a) (b))],\n    impl: zipWith (Pair)\n  };\n\n  //# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c\n  //.\n  //. Returns the result of combining, pairwise, the given arrays using the\n  //. given binary function. The length of the resulting array is equal to the\n  //. length of the shorter input array.\n  //.\n  //. See also [`zip`](#zip).\n  //.\n  //. ```javascript\n  //. > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])\n  //. ['ax', 'by']\n  //.\n  //. > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])\n  //. [[1, 2], [3, 4]]\n  //. ```\n  function zipWith(f) {\n    return function(xs) {\n      return function(ys) {\n        var result = [];\n        var len = Math.min (xs.length, ys.length);\n        for (var idx = 0; idx < len; idx += 1) {\n          result.push (f (xs[idx]) (ys[idx]));\n        }\n        return result;\n      };\n    };\n  }\n  _.zipWith = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Array (a), $.Array (b), $.Array (c)],\n    impl: zipWith\n  };\n\n  //. ### Object\n\n  //# prop :: String -> a -> b\n  //.\n  //. Takes a property name and an object with known properties and returns\n  //. the value of the specified property. If for some reason the object\n  //. lacks the specified property, a type error is thrown.\n  //.\n  //. For accessing properties of uncertain objects, use [`get`](#get) instead.\n  //. For accessing string map values by key, use [`value`](#value) instead.\n  //.\n  //. ```javascript\n  //. > S.prop ('a') ({a: 1, b: 2})\n  //. 1\n  //. ```\n  function prop(key) {\n    return function(x) {\n      var obj = toObject (x);\n      if (key in obj) return obj[key];\n      throw new TypeError ('prop expected object to have a property named ' +\n                           '' + key + '; ' + show (x) + ' does not');\n    };\n  }\n  _.prop = {\n    consts: {},\n    types: [$.String, a, b],\n    impl: prop\n  };\n\n  //# props :: Array String -> a -> b\n  //.\n  //. Takes a property path (an array of property names) and an object with\n  //. known structure and returns the value at the given path. If for some\n  //. reason the path does not exist, a type error is thrown.\n  //.\n  //. For accessing property paths of uncertain objects, use [`gets`](#gets)\n  //. instead.\n  //.\n  //. ```javascript\n  //. > S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})\n  //. 1\n  //. ```\n  function props(path) {\n    return function(x) {\n      return path.reduce (function(x, key) {\n        var obj = toObject (x);\n        if (key in obj) return obj[key];\n        throw new TypeError ('props expected object to have a property at ' +\n                             show (path) + '; ' + show (x) + ' does not');\n      }, x);\n    };\n  }\n  _.props = {\n    consts: {},\n    types: [$.Array ($.String), a, b],\n    impl: props\n  };\n\n  //# get :: (Any -> Boolean) -> String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property name, and an object and returns Just the\n  //. value of the specified object property if it exists and the value\n  //. satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`gets`](#gets), [`prop`](#prop), and [`value`](#value).\n  //.\n  //. ```javascript\n  //. > S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})\n  //. Just (1)\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})\n  //. Nothing\n  //. ```\n  function get(pred) {\n    return B (B (filter (pred))) (get_);\n  }\n  _.get = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, a, $.Maybe (b)],\n    impl: get\n  };\n\n  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property path (an array of property names), and\n  //. an object and returns Just the value at the given path if such a path\n  //. exists and the value satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})\n  //. Just (42)\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})\n  //. Nothing\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})\n  //. Nothing\n  //. ```\n  function gets(pred) {\n    return function(keys) {\n      return function(x) {\n        return Z.filter (pred, keys.reduce (function(maybe, key) {\n          return Z.chain (get_ (key), maybe);\n        }, Just (x)));\n      };\n    };\n  }\n  _.gets = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.Array ($.String), a, $.Maybe (b)],\n    impl: gets\n  };\n\n  //. ### StrMap\n  //.\n  //. StrMap is an abbreviation of _string map_. A string map is an object,\n  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\n  //. the same type. Formally, a value is a member of type `StrMap a` if its\n  //. [type identifier][] is `'Object'` and the values of its enumerable own\n  //. properties are all members of type `a`.\n\n  //# value :: String -> StrMap a -> Maybe a\n  //.\n  //. Retrieve the value associated with the given key in the given string map.\n  //.\n  //. Formally, `value (k) (m)` evaluates to `Just (m[k])` if `k` is an\n  //. enumerable own property of `m`; `Nothing` otherwise.\n  //.\n  //. See also [`prop`](#prop) and [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.value ('foo') ({foo: 1, bar: 2})\n  //. Just (1)\n  //.\n  //. > S.value ('bar') ({foo: 1, bar: 2})\n  //. Just (2)\n  //.\n  //. > S.value ('baz') ({foo: 1, bar: 2})\n  //. Nothing\n  //. ```\n  function value(key) {\n    return function(strMap) {\n      return Object.prototype.propertyIsEnumerable.call (strMap, key) ?\n             Just (strMap[key]) :\n             Nothing;\n    };\n  }\n  _.value = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.Maybe (a)],\n    impl: value\n  };\n\n  //# singleton :: String -> a -> StrMap a\n  //.\n  //. Takes a string and a value of any type, and returns a string map with\n  //. a single entry (mapping the key to the value).\n  //.\n  //. ```javascript\n  //. > S.singleton ('foo') (42)\n  //. {foo: 42}\n  //. ```\n  function singleton(key) {\n    return function(val) {\n      var strMap = {};\n      strMap[key] = val;\n      return strMap;\n    };\n  }\n  _.singleton = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a)],\n    impl: singleton\n  };\n\n  //# insert :: String -> a -> StrMap a -> StrMap a\n  //.\n  //. Takes a string, a value of any type, and a string map, and returns a\n  //. string map comprising all the entries of the given string map plus the\n  //. entry specified by the first two arguments (which takes precedence).\n  //.\n  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.insert ('c') (3) ({a: 1, b: 2})\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.insert ('a') (4) ({a: 1, b: 2})\n  //. {a: 4, b: 2}\n  //. ```\n  function insert(key) {\n    return function(val) {\n      return function(strMap) {\n        return Z.concat (strMap, singleton (key) (val));\n      };\n    };\n  }\n  _.insert = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a), $.StrMap (a)],\n    impl: insert\n  };\n\n  //# remove :: String -> StrMap a -> StrMap a\n  //.\n  //. Takes a string and a string map, and returns a string map comprising all\n  //. the entries of the given string map except the one whose key matches the\n  //. given string (if such a key exists).\n  //.\n  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.remove ('c') ({a: 1, b: 2, c: 3})\n  //. {a: 1, b: 2}\n  //.\n  //. > S.remove ('c') ({})\n  //. {}\n  //. ```\n  function remove(key) {\n    return function(strMap) {\n      var result = Z.concat (strMap, {});\n      delete result[key];\n      return result;\n    };\n  }\n  _.remove = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.StrMap (a)],\n    impl: remove\n  };\n\n  //# keys :: StrMap a -> Array String\n  //.\n  //. Returns the keys of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.keys ({b: 2, c: 3, a: 1}))\n  //. ['a', 'b', 'c']\n  //. ```\n  _.keys = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.String)],\n    impl: Object.keys\n  };\n\n  //# values :: StrMap a -> Array a\n  //.\n  //. Returns the values of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.values ({a: 1, c: 3, b: 2}))\n  //. [1, 2, 3]\n  //. ```\n  function values(strMap) {\n    return Z.map (function(k) { return strMap[k]; }, Object.keys (strMap));\n  }\n  _.values = {\n    consts: {},\n    types: [$.StrMap (a), $.Array (a)],\n    impl: values\n  };\n\n  //# pairs :: StrMap a -> Array (Pair String a)\n  //.\n  //. Returns the keyvalue pairs of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.pairs ({b: 2, a: 1, c: 3}))\n  //. [Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]\n  //. ```\n  function pairs(strMap) {\n    return Z.map (function(k) { return Pair (k) (strMap[k]); },\n                  Object.keys (strMap));\n  }\n  _.pairs = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.Pair ($.String) (a))],\n    impl: pairs\n  };\n\n  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a\n  //.\n  //. Returns a string map containing the keyvalue pairs specified by the\n  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost\n  //. pair takes precedence.\n  //.\n  //. ```javascript\n  //. > S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])\n  //. {x: 2}\n  //. ```\n  function fromPairs(pairs) {\n    return Z.reduce (function(strMap, pair) {\n      strMap[pair.fst] = pair.snd;\n      return strMap;\n    }, {}, pairs);\n  }\n  _.fromPairs = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Pair ($.String) (a)), $.StrMap (a)],\n    impl: fromPairs\n  };\n\n  //. ### Number\n\n  //# negate :: ValidNumber -> ValidNumber\n  //.\n  //. Negates its argument.\n  //.\n  //. ```javascript\n  //. > S.negate (12.5)\n  //. -12.5\n  //.\n  //. > S.negate (-42)\n  //. 42\n  //. ```\n  function negate(n) {\n    return -n;\n  }\n  _.negate = {\n    consts: {},\n    types: [$.ValidNumber, $.ValidNumber],\n    impl: negate\n  };\n\n  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.add (1) (1)\n  //. 2\n  //. ```\n  function add(x) {\n    return function(y) {\n      return x + y;\n    };\n  }\n  _.add = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: add\n  };\n\n  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.sum ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.sum ([])\n  //. 0\n  //.\n  //. > S.sum (S.Just (42))\n  //. 42\n  //.\n  //. > S.sum (S.Nothing)\n  //. 0\n  //. ```\n  _.sum = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (add) (0)\n  };\n\n  //# sub :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _subtract `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.sub (1)) ([1, 2, 3])\n  //. [0, 1, 2]\n  //. ```\n  function sub(y) {\n    return function(x) {\n      return x - y;\n    };\n  }\n  _.sub = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: sub\n  };\n\n  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mult (4) (2)\n  //. 8\n  //. ```\n  function mult(x) {\n    return function(y) {\n      return x * y;\n    };\n  }\n  _.mult = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: mult\n  };\n\n  //# product :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.product ([1, 2, 3, 4, 5])\n  //. 120\n  //.\n  //. > S.product ([])\n  //. 1\n  //.\n  //. > S.product (S.Just (42))\n  //. 42\n  //.\n  //. > S.product (S.Nothing)\n  //. 1\n  //. ```\n  _.product = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (mult) (1)\n  };\n\n  //# div :: NonZeroFiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a non-zero finite number `n` and returns the _divide by `n`_\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.map (S.div (2)) ([0, 1, 2, 3])\n  //. [0, 0.5, 1, 1.5]\n  //. ```\n  function div(y) {\n    return function(x) {\n      return x / y;\n    };\n  }\n  _.div = {\n    consts: {},\n    types: [$.NonZeroFiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: div\n  };\n\n  //# pow :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _power of `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])\n  //. [9, 4, 1, 0, 1, 4, 9]\n  //.\n  //. > S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5]\n  //. ```\n  function pow(exp) {\n    return function(base) {\n      return Math.pow (base, exp);\n    };\n  }\n  _.pow = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: pow\n  };\n\n  //. ### Integer\n\n  //# even :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is even; `false` if it is odd.\n  //.\n  //. ```javascript\n  //. > S.even (42)\n  //. true\n  //.\n  //. > S.even (99)\n  //. false\n  //. ```\n  function even(n) {\n    return n % 2 === 0;\n  }\n  _.even = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: even\n  };\n\n  //# odd :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is odd; `false` if it is even.\n  //.\n  //. ```javascript\n  //. > S.odd (99)\n  //. true\n  //.\n  //. > S.odd (42)\n  //. false\n  //. ```\n  function odd(n) {\n    return n % 2 !== 0;\n  }\n  _.odd = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: odd\n  };\n\n  //. ### Parse\n\n  //# parseDate :: String -> Maybe ValidDate\n  //.\n  //. Takes a string `s` and returns `Just (new Date (s))` if `new Date (s)`\n  //. evaluates to a [`ValidDate`][ValidDate] value; Nothing otherwise.\n  //.\n  //. As noted in [#488][], this function's behaviour is unspecified for some\n  //. inputs! [MDN][date parsing] warns against using the `Date` constructor\n  //. to parse date strings:\n  //.\n  //. > __Note:__ parsing of date strings with the `Date` constructor [] is\n  //. > strongly discouraged due to browser differences and inconsistencies.\n  //. > Support for RFC 2822 format strings is by convention only. Support for\n  //. > ISO 8601 formats differs in that date-only strings (e.g. \"1970-01-01\")\n  //. > are treated as UTC, not local.\n  //.\n  //. ```javascript\n  //. > S.parseDate ('2011-01-19T17:40:00Z')\n  //. Just (new Date ('2011-01-19T17:40:00.000Z'))\n  //.\n  //. > S.parseDate ('today')\n  //. Nothing\n  //. ```\n  function parseDate(s) {\n    var date = new Date (s);\n    return isNaN (date.valueOf ()) ? Nothing : Just (date);\n  }\n  _.parseDate = {\n    consts: {},\n    types: [$.String, $.Maybe ($.ValidDate)],\n    impl: parseDate\n  };\n\n  //  requiredNonCapturingGroup :: Array String -> String\n  function requiredNonCapturingGroup(xs) {\n    return '(?:' + xs.join ('|') + ')';\n  }\n\n  //  optionalNonCapturingGroup :: Array String -> String\n  function optionalNonCapturingGroup(xs) {\n    return requiredNonCapturingGroup (xs) + '?';\n  }\n\n  //  validFloatRepr :: RegExp\n  var validFloatRepr = new RegExp (\n    '^' +                     // start-of-string anchor\n    '\\\\s*' +                  // any number of leading whitespace characters\n    '[+-]?' +                 // optional sign\n    requiredNonCapturingGroup ([\n      'Infinity',             // \"Infinity\"\n      'NaN',                  // \"NaN\"\n      requiredNonCapturingGroup ([\n        '[0-9]+',             // number\n        '[0-9]+[.][0-9]+',    // number with interior decimal point\n        '[0-9]+[.]',          // number with trailing decimal point\n        '[.][0-9]+'           // number with leading decimal point\n      ]) +\n      optionalNonCapturingGroup ([\n        '[Ee]' +              // \"E\" or \"e\"\n        '[+-]?' +             // optional sign\n        '[0-9]+'              // exponent\n      ])\n    ]) +\n    '\\\\s*' +                  // any number of trailing whitespace characters\n    '$'                       // end-of-string anchor\n  );\n\n  //# parseFloat :: String -> Maybe Number\n  //.\n  //. Takes a string and returns Just the number represented by the string\n  //. if it does in fact represent a number; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseFloat ('-123.45')\n  //. Just (-123.45)\n  //.\n  //. > S.parseFloat ('foo.bar')\n  //. Nothing\n  //. ```\n  function parseFloat_(s) {\n    return validFloatRepr.test (s) ? Just (parseFloat (s)) : Nothing;\n  }\n  _.parseFloat = {\n    consts: {},\n    types: [$.String, $.Maybe ($.Number)],\n    impl: parseFloat_\n  };\n\n  //  Radix :: Type\n  var Radix = $.NullaryType\n    ('Radix')\n    ('')\n    ([$.Integer])\n    (function(x) { return x >= 2 && x <= 36; });\n\n  //# parseInt :: Radix -> String -> Maybe Integer\n  //.\n  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,\n  //. and returns Just the number represented by the string if it does in\n  //. fact represent a number in the base specified by the radix; Nothing\n  //. otherwise.\n  //.\n  //. This function is stricter than [`parseInt`][parseInt]: a string\n  //. is considered to represent an integer only if all its non-prefix\n  //. characters are members of the character set specified by the radix.\n  //.\n  //. ```javascript\n  //. > S.parseInt (10) ('-42')\n  //. Just (-42)\n  //.\n  //. > S.parseInt (16) ('0xFF')\n  //. Just (255)\n  //.\n  //. > S.parseInt (16) ('0xGG')\n  //. Nothing\n  //. ```\n  function parseInt_(radix) {\n    return function(s) {\n      var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice (0, radix);\n      var pattern = new RegExp ('^[' + charset + ']+$', 'i');\n\n      var t = s.replace (/^[+-]/, '');\n      if (pattern.test (radix === 16 ? t.replace (/^0x/i, '') : t)) {\n        var n = parseInt (s, radix);\n        if ($.test ([]) ($.Integer) (n)) return Just (n);\n      }\n      return Nothing;\n    };\n  }\n  _.parseInt = {\n    consts: {},\n    types: [Radix, $.String, $.Maybe ($.Integer)],\n    impl: parseInt_\n  };\n\n  //# parseJson :: (Any -> Boolean) -> String -> Maybe a\n  //.\n  //. Takes a predicate and a string that may or may not be valid JSON, and\n  //. returns Just the result of applying `JSON.parse` to the string *if* the\n  //. result satisfies the predicate; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[\"1\",\"2\",\"3\"]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')\n  //. Just ([1, 2, 3])\n  //. ```\n  function parseJson(pred) {\n    return B (filter (pred))\n             (B (either (K (Nothing)) (Just))\n                (encase (JSON.parse)));\n  }\n  _.parseJson = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, $.Maybe (a)],\n    impl: parseJson\n  };\n\n  //. ### RegExp\n\n  //  withRegex :: (RegExp, () -> a) -> a\n  function withRegex(pattern, thunk) {\n    var lastIndex = pattern.lastIndex;\n    var result = thunk ();\n    pattern.lastIndex = lastIndex;\n    return result;\n  }\n\n  //# regex :: RegexFlags -> String -> RegExp\n  //.\n  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.\n  //.\n  //. ```javascript\n  //. > S.regex ('g') (':\\\\d+:')\n  //. /:\\d+:/g\n  //. ```\n  function regex(flags) {\n    return function(source) {\n      return new RegExp (source, flags);\n    };\n  }\n  _.regex = {\n    consts: {},\n    types: [$.RegexFlags, $.String, $.RegExp],\n    impl: regex\n  };\n\n  //# regexEscape :: String -> String\n  //.\n  //. Takes a string that may contain regular expression metacharacters,\n  //. and returns a string with those metacharacters escaped.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String.\n  //.      S.test (S.regex ('') (S.regexEscape (s))) (s) = true`\n  //.\n  //. ```javascript\n  //. > S.regexEscape ('-=*{XYZ}*=-')\n  //. '\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n  //. ```\n  function regexEscape(s) {\n    return s.replace (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  _.regexEscape = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: regexEscape\n  };\n\n  //# test :: RegExp -> String -> Boolean\n  //.\n  //. Takes a pattern and a string, and returns `true` [iff][] the pattern\n  //. matches the string.\n  //.\n  //. ```javascript\n  //. > S.test (/^a/) ('abacus')\n  //. true\n  //.\n  //. > S.test (/^a/) ('banana')\n  //. false\n  //. ```\n  function test(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() { return pattern.test (s); });\n    };\n  }\n  _.test = {\n    consts: {},\n    types: [$.RegExp, $.String, $.Boolean],\n    impl: test\n  };\n\n  //# match :: NonGlobalRegExp -> String -> Maybe (Array (Maybe String))\n  //.\n  //. Takes a pattern and a string, and returns Just an array of captured\n  //. values if the pattern matches the string; Nothing otherwise.\n  //.\n  //. `Maybe String` acknowledges the existence of optional capturing groups.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: Pattern, s :: String.\n  //.      S.head (S.matchAll (S.regex ('g') (p)) (s))\n  //.      = S.match (S.regex ('') (p)) (s)`\n  //.\n  //. See also [`matchAll`](#matchAll).\n  //.\n  //. ```javascript\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('XXX')\n  //. Nothing\n  //.\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('example.com')\n  //. Just ([Just ('example.com'), Nothing])\n  //.\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('example.com:8888')\n  //. Just ([Just ('example.com'), Just ('8888')])\n  //. ```\n  function match(pattern) {\n    return function(s) {\n      return Z.map (function(m) { return Z.map (toMaybe, m.slice (1)); },\n                    toMaybe (s.match (pattern)));\n    };\n    function toMaybe(x) { return x == null ? Nothing : Just (x); }\n  }\n  _.match = {\n    consts: {},\n    types: [$.NonGlobalRegExp,\n            $.String,\n            $.Maybe ($.Array ($.Maybe ($.String)))],\n    impl: match\n  };\n\n  //# matchAll :: GlobalRegExp -> String -> Array (Array (Maybe String))\n  //.\n  //. Takes a pattern and a string, and returns an array of arrays of captured\n  //. values.\n  //.\n  //. `Maybe String` acknowledges the existence of optional capturing groups.\n  //.\n  //. See also [`match`](#match).\n  //.\n  //. ```javascript\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, world!')\n  //. []\n  //.\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')\n  //. [[Just ('foo')], [Just ('bar')], [Just ('baz')]]\n  //. ```\n  function matchAll(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() {\n        return unfold (function(_) {\n          return Z.map (function(m) {\n            return Pair (Z.map (toMaybe, m.slice (1))) (null);\n          }, Z.reject (equals (null), Just (pattern.exec (s))));\n        }) ([]);\n      });\n    };\n    function toMaybe(x) { return x == null ? Nothing : Just (x); }\n  }\n  _.matchAll = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array ($.Array ($.Maybe ($.String)))],\n    impl: matchAll\n  };\n\n  //# replace :: (Array (Maybe String) -> String) -> RegExp -> String -> String\n  //.\n  //. Replaces occurrences of the given pattern within the given string\n  //. in accordance with the given replacement function, which receives an\n  //. array of captured values. Replaces all occurrences of the pattern if\n  //. its `g` flag is set; just the first occurrence otherwise.\n  //.\n  //. ```javascript\n  //. > S.replace (([$1]) => S.maybe ('') (S.toUpper) ($1)) (/(\\w)/) ('foo')\n  //. 'Foo'\n  //.\n  //. > S.replace (([$1]) => S.maybe ('') (S.toUpper) ($1)) (/(\\w)/g) ('foo')\n  //. 'FOO'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<>')\n  //. '<>'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<foo>')\n  //. '<[Just (\"foo\"), Nothing]>'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<foobar>')\n  //. '<[Just (\"foo\"), Just (\"bar\")]>'\n  //. ```\n  function replace(substitute) {\n    return function(pattern) {\n      return function(text) {\n        return text.replace (pattern, function() {\n          var groups = [];\n          var group, idx = 1;\n          //  eslint-disable-next-line no-plusplus\n          while (typeof (group = arguments[idx++]) !== 'number') {\n            groups.push (group == null ? Nothing : Just (group));\n          }\n          return substitute (groups);\n        });\n      };\n    };\n  }\n  _.replace = {\n    consts: {},\n    types: [$.Fn ($.Array ($.Maybe ($.String))) ($.String),\n            $.RegExp,\n            $.String,\n            $.String],\n    impl: replace\n  };\n\n  //. ### String\n\n  //# toUpper :: String -> String\n  //.\n  //. Returns the upper-case equivalent of its argument.\n  //.\n  //. See also [`toLower`](#toLower).\n  //.\n  //. ```javascript\n  //. > S.toUpper ('ABC def 123')\n  //. 'ABC DEF 123'\n  //. ```\n  _.toUpper = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toUpperCase')\n  };\n\n  //# toLower :: String -> String\n  //.\n  //. Returns the lower-case equivalent of its argument.\n  //.\n  //. See also [`toUpper`](#toUpper).\n  //.\n  //. ```javascript\n  //. > S.toLower ('ABC def 123')\n  //. 'abc def 123'\n  //. ```\n  _.toLower = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toLowerCase')\n  };\n\n  //# trim :: String -> String\n  //.\n  //. Strips leading and trailing whitespace characters.\n  //.\n  //. ```javascript\n  //. > S.trim ('\\t\\t foo bar \\n')\n  //. 'foo bar'\n  //. ```\n  _.trim = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('trim')\n  };\n\n  //# stripPrefix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given prefix (the first argument) if the string starts\n  //. with the prefix; Nothing otherwise.\n  //.\n  //. See also [`stripSuffix`](#stripSuffix).\n  //.\n  //. ```javascript\n  //. > S.stripPrefix ('https://') ('https://sanctuary.js.org')\n  //. Just ('sanctuary.js.org')\n  //.\n  //. > S.stripPrefix ('https://') ('http://sanctuary.js.org')\n  //. Nothing\n  //. ```\n  function stripPrefix(prefix) {\n    return function(s) {\n      var idx = prefix.length;\n      return s.slice (0, idx) === prefix ? Just (s.slice (idx)) : Nothing;\n    };\n  }\n  _.stripPrefix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripPrefix\n  };\n\n  //# stripSuffix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given suffix (the first argument) if the string ends\n  //. with the suffix; Nothing otherwise.\n  //.\n  //. See also [`stripPrefix`](#stripPrefix).\n  //.\n  //. ```javascript\n  //. > S.stripSuffix ('.md') ('README.md')\n  //. Just ('README')\n  //.\n  //. > S.stripSuffix ('.md') ('README')\n  //. Nothing\n  //. ```\n  function stripSuffix(suffix) {\n    return function(s) {\n      var idx = s.length - suffix.length;  // value may be negative\n      return s.slice (idx) === suffix ? Just (s.slice (0, idx)) : Nothing;\n    };\n  }\n  _.stripSuffix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripSuffix\n  };\n\n  //# words :: String -> Array String\n  //.\n  //. Takes a string and returns the array of words the string contains\n  //. (words are delimited by whitespace characters).\n  //.\n  //. See also [`unwords`](#unwords).\n  //.\n  //. ```javascript\n  //. > S.words (' foo bar baz ')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function words(s) {\n    var words = s.split (/\\s+/);\n    var len = words.length;\n    return words.slice (words[0] === '' ? 1 : 0,\n                        words[len - 1] === '' ? len - 1 : len);\n  }\n  _.words = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: words\n  };\n\n  //# unwords :: Array String -> String\n  //.\n  //. Takes an array of words and returns the result of joining the words\n  //. with separating spaces.\n  //.\n  //. See also [`words`](#words).\n  //.\n  //. ```javascript\n  //. > S.unwords (['foo', 'bar', 'baz'])\n  //. 'foo bar baz'\n  //. ```\n  _.unwords = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: invoke1 ('join') (' ')\n  };\n\n  //# lines :: String -> Array String\n  //.\n  //. Takes a string and returns the array of lines the string contains\n  //. (lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\n  //. The resulting strings do not contain newlines.\n  //.\n  //. See also [`unlines`](#unlines).\n  //.\n  //. ```javascript\n  //. > S.lines ('foo\\nbar\\nbaz\\n')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function lines(s) {\n    return s === '' ? []\n                    : (s.replace (/\\r\\n?/g, '\\n')).match (/^(?=[\\s\\S]).*/gm);\n  }\n  _.lines = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: lines\n  };\n\n  //# unlines :: Array String -> String\n  //.\n  //. Takes an array of lines and returns the result of joining the lines\n  //. after appending a terminating line feed (`'\\n'`) to each.\n  //.\n  //. See also [`lines`](#lines).\n  //.\n  //. ```javascript\n  //. > S.unlines (['foo', 'bar', 'baz'])\n  //. 'foo\\nbar\\nbaz\\n'\n  //. ```\n  function unlines(xs) {\n    return xs.reduce (function(s, x) { return s + x + '\\n'; }, '');\n  }\n  _.unlines = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: unlines\n  };\n\n  //# splitOn :: String -> String -> Array String\n  //.\n  //. Returns the substrings of its second argument separated by occurrences\n  //. of its first argument.\n  //.\n  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n  //.\n  //. ```javascript\n  //. > S.splitOn ('::') ('foo::bar::baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  _.splitOn = {\n    consts: {},\n    types: [$.String, $.String, $.Array ($.String)],\n    impl: invoke1 ('split')\n  };\n\n  //# splitOnRegex :: GlobalRegExp -> String -> Array String\n  //.\n  //. Takes a pattern and a string, and returns the result of splitting the\n  //. string at every non-overlapping occurrence of the pattern.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s)\n  //.                 (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))\n  //.      = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')\n  //. ['foo', 'bar', 'baz']\n  //.\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOnRegex(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() {\n        var result = [];\n        var lastIndex = 0;\n        var match;\n        while ((match = pattern.exec (s)) != null) {\n          if (pattern.lastIndex === lastIndex && match[0] === '') {\n            if (pattern.lastIndex === s.length) return result;\n            pattern.lastIndex += 1;\n          } else {\n            result.push (s.slice (lastIndex, match.index));\n            lastIndex = match.index + match[0].length;\n          }\n        }\n        result.push (s.slice (lastIndex));\n        return result;\n      });\n    };\n  }\n  _.splitOnRegex = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array ($.String)],\n    impl: splitOnRegex\n  };\n\n  return create ({\n    checkTypes: typeof process === 'undefined'\n                || process == null\n                || process.env == null\n                || process.env.NODE_ENV !== 'production',\n    env: $.env\n  });\n\n}));\n\n//. [#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438\n//. [#488]:                     https://github.com/sanctuary-js/sanctuary/issues/488\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [Either]:                   #section:either\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Folktale]:                 https://folktale.origamitower.com/\n//. [GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out\n//. [Haskell]:                  https://www.haskell.org/\n//. [Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category\n//. [Maybe]:                    #section:maybe\n//. [Nullable]:                 v:sanctuary-js/sanctuary-def#Nullable\n//. [PureScript]:               http://www.purescript.org/\n//. [Ramda]:                    https://ramdajs.com/\n//. [RegexFlags]:               v:sanctuary-js/sanctuary-def#RegexFlags\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [ValidDate]:                v:sanctuary-js/sanctuary-def#ValidDate\n//. [`$.test`]:                 v:sanctuary-js/sanctuary-def#test\n//. [`Descending`]:             v:sanctuary-js/sanctuary-descending#Descending\n//. [`R.__`]:                   https://ramdajs.com/docs/#__\n//. [`R.bind`]:                 https://ramdajs.com/docs/#bind\n//. [`R.invoker`]:              https://ramdajs.com/docs/#invoker\n//. [`Z.alt`]:                  v:sanctuary-js/sanctuary-type-classes#alt\n//. [`Z.ap`]:                   v:sanctuary-js/sanctuary-type-classes#ap\n//. [`Z.apFirst`]:              v:sanctuary-js/sanctuary-type-classes#apFirst\n//. [`Z.apSecond`]:             v:sanctuary-js/sanctuary-type-classes#apSecond\n//. [`Z.bimap`]:                v:sanctuary-js/sanctuary-type-classes#bimap\n//. [`Z.chain`]:                v:sanctuary-js/sanctuary-type-classes#chain\n//. [`Z.chainRec`]:             v:sanctuary-js/sanctuary-type-classes#chainRec\n//. [`Z.compose`]:              v:sanctuary-js/sanctuary-type-classes#compose\n//. [`Z.concat`]:               v:sanctuary-js/sanctuary-type-classes#concat\n//. [`Z.contramap`]:            v:sanctuary-js/sanctuary-type-classes#contramap\n//. [`Z.duplicate`]:            v:sanctuary-js/sanctuary-type-classes#duplicate\n//. [`Z.empty`]:                v:sanctuary-js/sanctuary-type-classes#empty\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.extend`]:               v:sanctuary-js/sanctuary-type-classes#extend\n//. [`Z.extract`]:              v:sanctuary-js/sanctuary-type-classes#extract\n//. [`Z.filter`]:               v:sanctuary-js/sanctuary-type-classes#filter\n//. [`Z.flip`]:                 v:sanctuary-js/sanctuary-type-classes#flip\n//. [`Z.foldMap`]:              v:sanctuary-js/sanctuary-type-classes#foldMap\n//. [`Z.gt`]:                   v:sanctuary-js/sanctuary-type-classes#gt\n//. [`Z.gte`]:                  v:sanctuary-js/sanctuary-type-classes#gte\n//. [`Z.id`]:                   v:sanctuary-js/sanctuary-type-classes#id\n//. [`Z.intercalate`]:          v:sanctuary-js/sanctuary-type-classes#intercalate\n//. [`Z.invert`]:               v:sanctuary-js/sanctuary-type-classes#invert\n//. [`Z.join`]:                 v:sanctuary-js/sanctuary-type-classes#join\n//. [`Z.lt`]:                   v:sanctuary-js/sanctuary-type-classes#lt\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [`Z.map`]:                  v:sanctuary-js/sanctuary-type-classes#map\n//. [`Z.mapLeft`]:              v:sanctuary-js/sanctuary-type-classes#mapLeft\n//. [`Z.of`]:                   v:sanctuary-js/sanctuary-type-classes#of\n//. [`Z.promap`]:               v:sanctuary-js/sanctuary-type-classes#promap\n//. [`Z.reject`]:               v:sanctuary-js/sanctuary-type-classes#reject\n//. [`Z.sequence`]:             v:sanctuary-js/sanctuary-type-classes#sequence\n//. [`Z.traverse`]:             v:sanctuary-js/sanctuary-type-classes#traverse\n//. [`Z.zero`]:                 v:sanctuary-js/sanctuary-type-classes#zero\n//. [`apply2way`]:              https://hackage.haskell.org/package/yjtools-0.9.18/docs/Data-Function-Tools.html#v:apply2way\n//. [`converge`]:               https://ramdajs.com/docs/#converge\n//. [`show`]:                   v:sanctuary-js/sanctuary-show#show\n//. [date parsing]:             https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n//. [equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n//. [partial functions]:        https://en.wikipedia.org/wiki/Partial_function\n//. [ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683\n//. [ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413\n//. [ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419\n//. [sanctuary-def]:            v:sanctuary-js/sanctuary-def\n//. [sanctuary-either]:         v:sanctuary-js/sanctuary-either\n//. [sanctuary-maybe]:          v:sanctuary-js/sanctuary-maybe\n//. [sanctuary-pair]:           v:sanctuary-js/sanctuary-pair\n//. [sanctuary-show]:           v:sanctuary-js/sanctuary-show\n//. [sanctuary-type-classes]:   v:sanctuary-js/sanctuary-type-classes\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n//. [total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function\n//. [type checking]:            #section:type-checking\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n//. [variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function\n","export var FL = {\n  alt: 'fantasy-land/alt',\n  ap: 'fantasy-land/ap',\n  bimap: 'fantasy-land/bimap',\n  chain: 'fantasy-land/chain',\n  chainRec: 'fantasy-land/chainRec',\n  map: 'fantasy-land/map',\n  of: 'fantasy-land/of',\n  zero: 'fantasy-land/zero'\n};\n\nexport var ordinal = ['first', 'second', 'third', 'fourth', 'fifth'];\n\nexport var namespace = 'fluture';\nexport var name = 'Future';\nexport var version = 5;\n\nexport var $$type = namespace + '/' + name + '@' + version;\n","export function List(head, tail){\n  this.head = head;\n  this.tail = tail;\n}\n\nList.prototype.toJSON = function(){\n  return toArray(this);\n};\n\nexport var nil = new List(null, null);\nnil.tail = nil;\n\nexport function isNil(list){\n  return list.tail === list;\n}\n\n// cons :: (a, List a) -> List a\n//      -- O(1) append operation\nexport function cons(head, tail){\n  return new List(head, tail);\n}\n\n// reverse :: List a -> List a\n//         -- O(n) list reversal\nexport function reverse(xs){\n  var ys = nil, tail = xs;\n  while(!isNil(tail)){\n    ys = cons(tail.head, ys);\n    tail = tail.tail;\n  }\n  return ys;\n}\n\n// cat :: (List a, List a) -> List a\n//     -- O(n) list concatenation\nexport function cat(xs, ys){\n  var zs = ys, tail = reverse(xs);\n  while(!isNil(tail)){\n    zs = cons(tail.head, zs);\n    tail = tail.tail;\n  }\n  return zs;\n}\n\n// toArray :: List a -> Array a\n//         -- O(n) list to Array\nexport function toArray(xs){\n  var tail = xs, arr = [];\n  while(!isNil(tail)){\n    arr.push(tail.head);\n    tail = tail.tail;\n  }\n  return arr;\n}\n","import {ordinal} from './const.js';\nimport {cons} from './list.js';\n\n/* c8 ignore next */\nvar captureStackTrace = Error.captureStackTrace || captureStackTraceFallback;\nvar _debug = debugHandleNone;\n\nexport {captureStackTrace};\n\nexport function debugMode(debug){\n  _debug = debug ? debugHandleAll : debugHandleNone;\n}\n\nexport function debugHandleNone(x){\n  return x;\n}\n\nexport function debugHandleAll(x, fn, a, b, c){\n  return fn(a, b, c);\n}\n\nexport function debug(x, fn, a, b, c){\n  return _debug(x, fn, a, b, c);\n}\n\nexport function captureContext(previous, tag, fn){\n  return debug(previous, debugCaptureContext, previous, tag, fn);\n}\n\nexport function debugCaptureContext(previous, tag, fn){\n  var context = {tag: tag, name: ' from ' + tag + ':'};\n  captureStackTrace(context, fn);\n  return cons(context, previous);\n}\n\nexport function captureApplicationContext(context, n, f){\n  return debug(context, debugCaptureApplicationContext, context, n, f);\n}\n\nexport function debugCaptureApplicationContext(context, n, f){\n  return debugCaptureContext(context, ordinal[n - 1] + ' application of ' + f.name, f);\n}\n\nexport function captureStackTraceFallback(x){\n  var e = new Error;\n  if(typeof e.stack === 'string'){\n    x.stack = x.name + '\\n' + e.stack.split('\\n').slice(1).join('\\n');\n  /* c8 ignore next 3 */\n  }else{\n    x.stack = x.name;\n  }\n}\n","export {default as show} from 'sanctuary-show';\n\n/* c8 ignore next */\nvar setImmediate = typeof setImmediate === 'undefined' ? setImmediateFallback : setImmediate;\n\nexport function noop(){}\nexport function moop(){ return this }\nexport function call(f, x){ return f(x) }\n\nexport function setImmediateFallback(f, x){\n  return setTimeout(f, 0, x);\n}\n\nexport function raise(x){\n  setImmediate(function rethrowErrorDelayedToEscapePromiseCatch(){\n    throw x;\n  });\n}\n","import {show} from './utils.js';\nimport {ordinal, namespace, name, version} from './const.js';\nimport type from 'sanctuary-type-identifiers';\nimport {nil, cat} from './list.js';\nimport {captureStackTrace} from './debug.js';\n\nfunction showArg(x){\n  return show(x) + ' :: ' + type.parse(type(x)).name;\n}\n\nexport function error(message){\n  return new Error(message);\n}\n\nexport function typeError(message){\n  return new TypeError(message);\n}\n\nexport function invalidArgument(it, at, expected, actual){\n  return typeError(\n    it + '() expects its ' + ordinal[at] + ' argument to ' + expected + '.' +\n    '\\n  Actual: ' + showArg(actual)\n  );\n}\n\nexport function invalidArgumentOf(expected){\n  return function(it, at, actual){\n    return invalidArgument(it, at, expected, actual);\n  };\n}\n\nexport function invalidContext(it, actual){\n  return typeError(\n    it + '() was invoked outside the context of a Future. You might want to use'\n  + ' a dispatcher instead\\n  Called on: ' + show(actual)\n  );\n}\n\nexport function invalidArity(f, args){\n  return new TypeError(\n    f.name + '() expects to be called with a single argument per invocation\\n' +\n    '  Saw: ' + args.length + ' arguments' +\n    Array.prototype.slice.call(args).map(function(arg, i){\n      return '\\n  ' + (\n        ordinal[i] ?\n        ordinal[i].charAt(0).toUpperCase() + ordinal[i].slice(1) :\n        'Argument ' + String(i + 1)\n      ) + ': ' + showArg(arg);\n    }).join('')\n  );\n}\n\nfunction invalidNamespace(m, x){\n  return (\n    'The Future was not created by ' + namespace + '. '\n  + 'Make sure you transform other Futures to ' + namespace + ' Futures. '\n  + 'Got ' + (x ? ('a Future from ' + x) : 'an unscoped Future') + '.'\n  + '\\n  See: https://github.com/fluture-js/Fluture#casting-futures'\n  );\n}\n\nfunction invalidVersion(m, x){\n  return (\n    'The Future was created by ' + (x < version ? 'an older' : 'a newer')\n  + ' version of ' + namespace + '. '\n  + 'This means that one of the sources which creates Futures is outdated. '\n  + 'Update this source, or transform its created Futures to be compatible.'\n  + '\\n  See: https://github.com/fluture-js/Fluture#casting-futures'\n  );\n}\n\nexport function invalidFuture(desc, m, s){\n  var id = type.parse(type(m));\n  var info = id.name === name ? '\\n' + (\n    id.namespace !== namespace ? invalidNamespace(m, id.namespace)\n  : id.version !== version ? invalidVersion(m, id.version)\n  : 'Nothing seems wrong. Contact the Fluture maintainers.') : '';\n  return typeError(\n    desc + ' to be a valid Future.' + info + '\\n' +\n    '  Actual: ' + show(m) + ' :: ' + id.name + (s || '')\n  );\n}\n\nexport function invalidFutureArgument(it, at, m, s){\n  return invalidFuture(it + '() expects its ' + ordinal[at] + ' argument', m, s);\n}\n\nexport function ensureError(value, fn){\n  var message;\n  try{\n    if(value instanceof Error) return value;\n    message = 'A Non-Error was thrown from a Future: ' + show(value);\n  }catch (_){\n    message = 'Something was thrown from a Future, but it could not be converted to String';\n  }\n  var e = error(message);\n  captureStackTrace(e, fn);\n  return e;\n}\n\nexport function assignUnenumerable(o, prop, value){\n  Object.defineProperty(o, prop, {value: value, writable: true, configurable: true});\n}\n\nexport function wrapException(caught, callingFuture){\n  var origin = ensureError(caught, wrapException);\n  var context = cat(origin.context || nil, callingFuture.context);\n  var e = error(origin.message);\n  assignUnenumerable(e, 'future', origin.future || callingFuture);\n  assignUnenumerable(e, 'reason', origin.reason || origin);\n  assignUnenumerable(e, 'stack', e.reason.stack);\n  return withExtraContext(e, context);\n}\n\nexport function withExtraContext(e, context){\n  assignUnenumerable(e, 'context', context);\n  assignUnenumerable(e, 'stack', e.stack + contextToStackTrace(context));\n  return e;\n}\n\nexport function contextToStackTrace(context){\n  var stack = '', tail = context;\n  while(tail !== nil){\n    stack = stack + '\\n' + tail.head.stack;\n    tail = tail.tail;\n  }\n  return stack;\n}\n","import {FL} from './const.js';\n\nexport function isFunction(f){\n  return typeof f === 'function';\n}\n\nexport function isThenable(m){\n  return m instanceof Promise || m != null && isFunction(m.then);\n}\n\nexport function isBoolean(f){\n  return typeof f === 'boolean';\n}\n\nexport function isNumber(f){\n  return typeof f === 'number';\n}\n\nexport function isUnsigned(n){\n  return (n === Infinity || isNumber(n) && n > 0 && n % 1 === 0);\n}\n\nexport function isObject(o){\n  return o !== null && typeof o === 'object';\n}\n\nexport function isIterator(i){\n  return isObject(i) && isFunction(i.next);\n}\n\nexport function isArray(x){\n  return Array.isArray(x);\n}\n\nexport function hasMethod(method, x){\n  return x != null && isFunction(x[method]);\n}\n\nexport function isFunctor(x){\n  return hasMethod(FL.map, x);\n}\n\nexport function isAlt(x){\n  return isFunctor(x) && hasMethod(FL.alt, x);\n}\n\nexport function isApply(x){\n  return isFunctor(x) && hasMethod(FL.ap, x);\n}\n\nexport function isBifunctor(x){\n  return isFunctor(x) && hasMethod(FL.bimap, x);\n}\n\nexport function isChain(x){\n  return isApply(x) && hasMethod(FL.chain, x);\n}\n","import {isObject, isBoolean} from './predicates.js';\n\nexport function Next(x){\n  return {done: false, value: x};\n}\n\nexport function Done(x){\n  return {done: true, value: x};\n}\n\nexport function isIteration(x){\n  return isObject(x) && isBoolean(x.done);\n}\n","/*eslint no-cond-assign:0, no-constant-condition:0 */\nimport type from 'sanctuary-type-identifiers';\n\nimport {FL, $$type} from './internal/const.js';\nimport {captureContext, captureApplicationContext, captureStackTrace} from './internal/debug.js';\nimport {\n  invalidArgument,\n  invalidArgumentOf,\n  invalidArity,\n  invalidFuture,\n  invalidFutureArgument,\n  typeError,\n  withExtraContext,\n  wrapException\n} from './internal/error.js';\nimport {Next, Done} from './internal/iteration.js';\nimport {nil, cons, isNil, reverse, toArray} from './internal/list.js';\nimport {isFunction, isUnsigned} from './internal/predicates.js';\nimport {show, noop, call, moop} from './internal/utils.js';\n\nfunction alwaysTrue(){\n  return true;\n}\n\nfunction getArgs(it){\n  var args = new Array(it.arity);\n  for(var i = 1; i <= it.arity; i++){\n    args[i - 1] = it['$' + String(i)];\n  }\n  return args;\n}\n\nfunction showArg(arg){\n  return ' (' + show(arg) + ')';\n}\n\nexport var any = {pred: alwaysTrue, error: invalidArgumentOf('be anything')};\nexport var func = {pred: isFunction, error: invalidArgumentOf('be a Function')};\nexport var future = {pred: isFuture, error: invalidFutureArgument};\nexport var positiveInteger = {pred: isUnsigned, error: invalidArgumentOf('be a positive Integer')};\n\nexport function application(n, f, type, args, prev){\n  if(args.length < 2 && type.pred(args[0])) return captureApplicationContext(prev, n, f);\n  var e = args.length > 1 ? invalidArity(f, args) : type.error(f.name, n - 1, args[0]);\n  captureStackTrace(e, f);\n  throw withExtraContext(e, prev);\n}\n\nexport function application1(f, type, args){\n  return application(1, f, type, args, nil);\n}\n\nexport function Future(computation){\n  var context = application1(Future, func, arguments);\n  return new Computation(context, computation);\n}\n\nexport function isFuture(x){\n  return x instanceof Future || type(x) === $$type;\n}\n\n// Compliance with sanctuary-type-identifiers versions 1 and 2.\n// To prevent sanctuary-type-identifiers version 3 from identifying 'Future'\n// as being of the type denoted by $$type, we ensure that\n// Future.constructor.prototype is equal to Future.\nFuture['@@type'] = $$type;\nFuture.constructor = {prototype: Future};\n\nFuture[FL.of] = resolve;\nFuture[FL.chainRec] = chainRec;\n\nFuture.prototype['@@type'] = $$type;\n\nFuture.prototype['@@show'] = function Future$show(){\n  return this.toString();\n};\n\nFuture.prototype.pipe = function Future$pipe(f){\n  if(!isFunction(f)) throw invalidArgument('Future#pipe', 0, 'be a Function', f);\n  return f(this);\n};\n\nFuture.prototype[FL.ap] = function Future$FL$ap(other){\n  var context = captureContext(nil, 'a Fantasy Land dispatch to ap', Future$FL$ap);\n  return other._transform(new ApTransformation(context, this));\n};\n\nFuture.prototype[FL.map] = function Future$FL$map(mapper){\n  var context = captureContext(nil, 'a Fantasy Land dispatch to map', Future$FL$map);\n  return this._transform(new MapTransformation(context, mapper));\n};\n\nFuture.prototype[FL.bimap] = function Future$FL$bimap(lmapper, rmapper){\n  var context = captureContext(nil, 'a Fantasy Land dispatch to bimap', Future$FL$bimap);\n  return this._transform(new BimapTransformation(context, lmapper, rmapper));\n};\n\nFuture.prototype[FL.chain] = function Future$FL$chain(mapper){\n  var context = captureContext(nil, 'a Fantasy Land dispatch to chain', Future$FL$chain);\n  return this._transform(new ChainTransformation(context, mapper));\n};\n\nFuture.prototype[FL.alt] = function Future$FL$alt(other){\n  var context = captureContext(nil, 'a Fantasy Land dispatch to alt', Future$FL$alt);\n  return this._transform(new AltTransformation(context, other));\n};\n\nFuture.prototype.extractLeft = function Future$extractLeft(){\n  return [];\n};\n\nFuture.prototype.extractRight = function Future$extractRight(){\n  return [];\n};\n\nFuture.prototype._transform = function Future$transform(transformation){\n  return new Transformer(transformation.context, this, cons(transformation, nil));\n};\n\nFuture.prototype.isTransformer = false;\nFuture.prototype.context = nil;\nFuture.prototype.arity = 0;\nFuture.prototype.name = 'future';\n\nFuture.prototype.toString = function Future$toString(){\n  return this.name + getArgs(this).map(showArg).join('');\n};\n\nFuture.prototype.toJSON = function Future$toJSON(){\n  return {$: $$type, kind: 'interpreter', type: this.name, args: getArgs(this)};\n};\n\nexport function createInterpreter(arity, name, interpret){\n  var Interpreter = function(context, $1, $2, $3){\n    this.context = context;\n    this.$1 = $1;\n    this.$2 = $2;\n    this.$3 = $3;\n  };\n\n  Interpreter.prototype = Object.create(Future.prototype);\n  Interpreter.prototype.arity = arity;\n  Interpreter.prototype.name = name;\n  Interpreter.prototype._interpret = interpret;\n\n  return Interpreter;\n}\n\nexport var Computation =\ncreateInterpreter(1, 'Future', function Computation$interpret(rec, rej, res){\n  var computation = this.$1, open = false, cancel = noop, cont = function(){ open = true };\n  try{\n    cancel = computation(function Computation$rej(x){\n      cont = function Computation$rej$cont(){\n        open = false;\n        rej(x);\n      };\n      if(open){\n        cont();\n      }\n    }, function Computation$res(x){\n      cont = function Computation$res$cont(){\n        open = false;\n        res(x);\n      };\n      if(open){\n        cont();\n      }\n    });\n  }catch(e){\n    rec(wrapException(e, this));\n    return noop;\n  }\n  if(!(isFunction(cancel) && cancel.length === 0)){\n    rec(wrapException(typeError(\n      'The computation was expected to return a nullary cancellation function\\n' +\n      '  Actual: ' + show(cancel)\n    ), this));\n    return noop;\n  }\n  cont();\n  return function Computation$cancel(){\n    if(open){\n      open = false;\n      cancel && cancel();\n    }\n  };\n});\n\nexport var Never = createInterpreter(0, 'never', function Never$interpret(){\n  return noop;\n});\n\nNever.prototype._isNever = true;\n\nexport var never = new Never(nil);\n\nexport function isNever(x){\n  return isFuture(x) && x._isNever === true;\n}\n\nexport var Crash = createInterpreter(1, 'crash', function Crash$interpret(rec){\n  rec(this.$1);\n  return noop;\n});\n\nexport function crash(x){\n  return new Crash(application1(crash, any, arguments), x);\n}\n\nexport var Reject = createInterpreter(1, 'reject', function Reject$interpret(rec, rej){\n  rej(this.$1);\n  return noop;\n});\n\nReject.prototype.extractLeft = function Reject$extractLeft(){\n  return [this.$1];\n};\n\nexport function reject(x){\n  return new Reject(application1(reject, any, arguments), x);\n}\n\nexport var Resolve = createInterpreter(1, 'resolve', function Resolve$interpret(rec, rej, res){\n  res(this.$1);\n  return noop;\n});\n\nResolve.prototype.extractRight = function Resolve$extractRight(){\n  return [this.$1];\n};\n\nexport function resolve(x){\n  return new Resolve(application1(resolve, any, arguments), x);\n}\n\n//Note: This function is not curried because it's only used to satisfy the\n//      Fantasy Land ChainRec specification.\nexport function chainRec(step, init){\n  return resolve(Next(init))._transform(new ChainTransformation(nil, function chainRec$recur(o){\n    return o.done ?\n           resolve(o.value) :\n           step(Next, Done, o.value)._transform(new ChainTransformation(nil, chainRec$recur));\n  }));\n}\n\nexport var Transformer =\ncreateInterpreter(2, 'transform', function Transformer$interpret(rec, rej, res){\n\n  //These are the cold, and hot, transformation stacks. The cold actions are those that\n  //have yet to run parallel computations, and hot are those that have.\n  var cold = nil, hot = nil;\n\n  //These combined variables define our current state.\n  // future         = the future we are currently forking\n  // transformation = the transformation to be informed when the future settles\n  // cancel         = the cancel function of the current future\n  // settled        = a boolean indicating whether a new tick should start\n  // async          = a boolean indicating whether we are awaiting a result asynchronously\n  var future, transformation, cancel = noop, settled, async = true, it;\n\n  //Takes a transformation from the top of the hot stack and returns it.\n  function nextHot(){\n    var x = hot.head;\n    hot = hot.tail;\n    return x;\n  }\n\n  //Takes a transformation from the top of the cold stack and returns it.\n  function nextCold(){\n    var x = cold.head;\n    cold = cold.tail;\n    return x;\n  }\n\n  //This function is called with a future to use in the next tick.\n  //Here we \"flatten\" the actions of another Sequence into our own actions,\n  //this is the magic that allows for infinitely stack safe recursion because\n  //actions like ChainAction will return a new Sequence.\n  //If we settled asynchronously, we call drain() directly to run the next tick.\n  function settle(m){\n    settled = true;\n    future = m;\n    if(future.isTransformer){\n      var tail = future.$2;\n      while(!isNil(tail)){\n        cold = cons(tail.head, cold);\n        tail = tail.tail;\n      }\n      future = future.$1;\n    }\n    if(async) drain();\n  }\n\n  //This function serves as a rejection handler for our current future.\n  //It will tell the current transformation that the future rejected, and it will\n  //settle the current tick with the transformation's answer to that.\n  function rejected(x){\n    settle(transformation.rejected(x));\n  }\n\n  //This function serves as a resolution handler for our current future.\n  //It will tell the current transformation that the future resolved, and it will\n  //settle the current tick with the transformation's answer to that.\n  function resolved(x){\n    settle(transformation.resolved(x));\n  }\n\n  //This function is passed into actions when they are \"warmed up\".\n  //If the transformation decides that it has its result, without the need to await\n  //anything else, then it can call this function to force \"early termination\".\n  //When early termination occurs, all actions which were stacked prior to the\n  //terminator will be skipped. If they were already hot, they will also be\n  //sent a cancel signal so they can cancel their own concurrent computations,\n  //as their results are no longer needed.\n  function early(m, terminator){\n    cancel();\n    cold = nil;\n    if(async && transformation !== terminator){\n      transformation.cancel();\n      while((it = nextHot()) && it !== terminator) it.cancel();\n    }\n    settle(m);\n  }\n\n  //This will cancel the current Future, the current transformation, and all stacked hot actions.\n  function Sequence$cancel(){\n    cancel();\n    transformation && transformation.cancel();\n    while(it = nextHot()) it.cancel();\n  }\n\n  //This function is called when an exception is caught.\n  function exception(e){\n    Sequence$cancel();\n    settled = true;\n    cold = hot = nil;\n    var error = wrapException(e, future);\n    future = never;\n    rec(error);\n  }\n\n  //This function serves to kickstart concurrent computations.\n  //Takes all actions from the cold stack in reverse order, and calls run() on\n  //each of them, passing them the \"early\" function. If any of them settles (by\n  //calling early()), we abort. After warming up all actions in the cold queue,\n  //we warm up the current transformation as well.\n  function warmupActions(){\n    cold = reverse(cold);\n    while(cold !== nil){\n      it = cold.head.run(early);\n      if(settled) return;\n      hot = cons(it, hot);\n      cold = cold.tail;\n    }\n    transformation = transformation.run(early);\n  }\n\n  //This function represents our main execution loop. By \"tick\", we've been\n  //referring to the execution of one iteration in the while-loop below.\n  function drain(){\n    async = false;\n    while(true){\n      settled = false;\n      if(transformation = nextCold()){\n        cancel = future._interpret(exception, rejected, resolved);\n        if(!settled) warmupActions();\n      }else if(transformation = nextHot()){\n        cancel = future._interpret(exception, rejected, resolved);\n      }else break;\n      if(settled) continue;\n      async = true;\n      return;\n    }\n    cancel = future._interpret(exception, rej, res);\n  }\n\n  //Start the execution loop.\n  settle(this);\n\n  //Return the cancellation function.\n  return Sequence$cancel;\n\n});\n\nTransformer.prototype.isTransformer = true;\n\nTransformer.prototype._transform = function Transformer$_transform(transformation){\n  return new Transformer(transformation.context, this.$1, cons(transformation, this.$2));\n};\n\nTransformer.prototype.toString = function Transformer$toString(){\n  return toArray(reverse(this.$2)).reduce(function(str, action){\n    return action.name + getArgs(action).map(showArg).join('') + ' (' + str + ')';\n  }, this.$1.toString());\n};\n\nfunction BaseTransformation$rejected(x){\n  this.cancel();\n  return new Reject(this.context, x);\n}\n\nfunction BaseTransformation$resolved(x){\n  this.cancel();\n  return new Resolve(this.context, x);\n}\n\nfunction BaseTransformation$toJSON(){\n  return {$: $$type, kind: 'transformation', type: this.name, args: getArgs(this)};\n}\n\nexport var BaseTransformation = {\n  rejected: BaseTransformation$rejected,\n  resolved: BaseTransformation$resolved,\n  run: moop,\n  cancel: noop,\n  context: nil,\n  arity: 0,\n  name: 'transform',\n  toJSON: BaseTransformation$toJSON\n};\n\nfunction wrapHandler(handler){\n  return function transformationHandler(x){\n    var m;\n    try{\n      m = handler.call(this, x);\n    }catch(e){\n      return new Crash(this.context, e);\n    }\n    if(isFuture(m)){\n      return m;\n    }\n    return new Crash(this.context, invalidFuture(\n      this.name + ' expects the return value from the function it\\'s given', m,\n      '\\n  When called with: ' + show(x)\n    ));\n  };\n}\n\nexport function createTransformation(arity, name, prototype){\n  var Transformation = function(context, $1, $2){\n    this.context = context;\n    this.$1 = $1;\n    this.$2 = $2;\n  };\n\n  Transformation.prototype = Object.create(BaseTransformation);\n  Transformation.prototype.arity = arity;\n  Transformation.prototype.name = name;\n\n  if(typeof prototype.rejected === 'function'){\n    Transformation.prototype.rejected = wrapHandler(prototype.rejected);\n  }\n\n  if(typeof prototype.resolved === 'function'){\n    Transformation.prototype.resolved = wrapHandler(prototype.resolved);\n  }\n\n  if(typeof prototype.run === 'function'){\n    Transformation.prototype.run = prototype.run;\n  }\n\n  return Transformation;\n}\n\nexport var ApTransformation = createTransformation(1, 'ap', {\n  resolved: function ApTransformation$resolved(f){\n    if(isFunction(f)) return this.$1._transform(new MapTransformation(this.context, f));\n    throw typeError(\n      'ap expects the second Future to resolve to a Function\\n' +\n      '  Actual: ' + show(f)\n    );\n  }\n});\n\nexport var AltTransformation = createTransformation(1, 'alt', {\n  rejected: function AltTransformation$rejected(){ return this.$1 }\n});\n\nexport var MapTransformation = createTransformation(1, 'map', {\n  resolved: function MapTransformation$resolved(x){\n    return new Resolve(this.context, call(this.$1, x));\n  }\n});\n\nexport var BimapTransformation = createTransformation(2, 'bimap', {\n  rejected: function BimapTransformation$rejected(x){\n    return new Reject(this.context, call(this.$1, x));\n  },\n  resolved: function BimapTransformation$resolved(x){\n    return new Resolve(this.context, call(this.$2, x));\n  }\n});\n\nexport var ChainTransformation = createTransformation(1, 'chain', {\n  resolved: function ChainTransformation$resolved(x){ return call(this.$1, x) }\n});\n","import {\n  any,\n  application,\n  application1,\n  createInterpreter,\n  never,\n  positiveInteger\n} from './future.js';\n\nexport var After = createInterpreter(2, 'after', function After$interpret(rec, rej, res){\n  var id = setTimeout(res, this.$1, this.$2);\n  return function After$cancel(){ clearTimeout(id) };\n});\n\nAfter.prototype.extractRight = function After$extractRight(){\n  return [this.$2];\n};\n\nfunction alwaysNever(_){\n  return never;\n}\n\nexport function after(time){\n  var context1 = application1(after, positiveInteger, arguments);\n  return time === Infinity ? alwaysNever : (function after(value){\n    var context2 = application(2, after, any, arguments, context1);\n    return new After(context2, time, value);\n  });\n}\n","import {createTransformation, application1, application, future} from './future.js';\n\nexport var AndTransformation = createTransformation(1, 'and', {\n  resolved: function AndTransformation$resolved(){ return this.$1 }\n});\n\nexport function and(left){\n  var context1 = application1(and, future, arguments);\n  return function and(right){\n    var context2 = application(2, and, future, arguments, context1);\n    return right._transform(new AndTransformation(context2, left));\n  };\n}\n","import {wrapException, typeError} from './internal/error.js';\nimport {isThenable} from './internal/predicates.js';\nimport {noop, show} from './internal/utils.js';\nimport {createInterpreter, application1, application, func, any} from './future.js';\n\nfunction invalidPromise(p, f, a){\n  return typeError(\n    'encaseP() expects the function it\\'s given to return a Promise/Thenable'\n    + '\\n  Actual: ' + show(p) + '\\n  From calling: ' + show(f)\n    + '\\n  With: ' + show(a)\n  );\n}\n\nexport var EncaseP = createInterpreter(2, 'encaseP', function EncaseP$interpret(rec, rej, res){\n  var open = true, fn = this.$1, arg = this.$2, p;\n  try{\n    p = fn(arg);\n  }catch(e){\n    rec(wrapException(e, this));\n    return noop;\n  }\n  if(!isThenable(p)){\n    rec(wrapException(invalidPromise(p, fn, arg), this));\n    return noop;\n  }\n  p.then(function EncaseP$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  }, function EncaseP$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  });\n  return function EncaseP$cancel(){ open = false };\n});\n\nexport function encaseP(f){\n  var context1 = application1(encaseP, func, arguments);\n  return function encaseP(x){\n    var context2 = application(2, encaseP, any, arguments, context1);\n    return new EncaseP(context2, f, x);\n  };\n}\n","import {noop} from './internal/utils.js';\nimport {createInterpreter, application1, application, func, any} from './future.js';\n\nexport var Encase = createInterpreter(2, 'encase', function Encase$interpret(rec, rej, res){\n  var fn = this.$1, r;\n  try{ r = fn(this.$2) }catch(e){ rej(e); return noop }\n  res(r);\n  return noop;\n});\n\nexport function encase(f){\n  var context1 = application1(encase, func, arguments);\n  return function encase(x){\n    var context2 = application(2, encase, any, arguments, context1);\n    return new Encase(context2, f, x);\n  };\n}\n","import {createTransformation, future, application1, application, func} from './future.js';\nimport {call} from './internal/utils.js';\n\nexport var BichainTransformation = createTransformation(2, 'bichain', {\n  rejected: function BichainTransformation$rejected(x){ return call(this.$1, x) },\n  resolved: function BichainTransformation$resolved(x){ return call(this.$2, x) }\n});\n\nexport function bichain(f){\n  var context1 = application1(bichain, func, arguments);\n  return function bichain(g){\n    var context2 = application(2, bichain, func, arguments, context1);\n    return function bichain(m){\n      var context3 = application(3, bichain, future, arguments, context2);\n      return m._transform(new BichainTransformation(context3, f, g));\n    };\n  };\n}\n","import {noop} from './utils.js';\nimport {createTransformation, Future, crash, reject, resolve} from '../future.js';\n\nfunction Eager(future){\n  var _this = this;\n  _this.rec = noop;\n  _this.rej = noop;\n  _this.res = noop;\n  _this.crashed = false;\n  _this.rejected = false;\n  _this.resolved = false;\n  _this.value = null;\n  _this.cancel = future._interpret(function Eager$crash(x){\n    _this.value = x;\n    _this.crashed = true;\n    _this.cancel = noop;\n    _this.rec(x);\n  }, function Eager$reject(x){\n    _this.value = x;\n    _this.rejected = true;\n    _this.cancel = noop;\n    _this.rej(x);\n  }, function Eager$resolve(x){\n    _this.value = x;\n    _this.resolved = true;\n    _this.cancel = noop;\n    _this.res(x);\n  });\n}\n\nEager.prototype = Object.create(Future.prototype);\n\nEager.prototype._interpret = function Eager$interpret(rec, rej, res){\n  if(this.crashed) rec(this.value);\n  else if(this.rejected) rej(this.value);\n  else if(this.resolved) res(this.value);\n  else{\n    this.rec = rec;\n    this.rej = rej;\n    this.res = res;\n  }\n  return this.cancel;\n};\n\nexport function earlyCrash(early, x){\n  early(crash(x));\n}\n\nexport function earlyReject(early, x){\n  early(reject(x));\n}\n\nexport function earlyResolve(early, x){\n  early(resolve(x));\n}\n\nexport function createParallelTransformation(name, rec, rej, res, prototype){\n  var ParallelTransformation = createTransformation(1, name, Object.assign({\n    run: function Parallel$run(early){\n      var eager = new Eager(this.$1);\n      var transformation = new ParallelTransformation(this.context, eager);\n      function Parallel$early(m){ early(m, transformation) }\n      transformation.cancel = eager._interpret(\n        function Parallel$rec(x){ rec(Parallel$early, x) },\n        function Parallel$rej(x){ rej(Parallel$early, x) },\n        function Parallel$res(x){ res(Parallel$early, x) }\n      );\n      return transformation;\n    }\n  }, prototype));\n  return ParallelTransformation;\n}\n","import {createParallelTransformation, earlyCrash, earlyReject} from './internal/parallel.js';\nimport {noop} from './internal/utils.js';\nimport {createTransformation, Resolve, application1, application, future} from './future.js';\n\nexport var PairTransformation = createTransformation(1, 'pair', {\n  resolved: function PairTransformation$resolved(x){\n    return new Resolve(this.context, [x, this.$1]);\n  }\n});\n\nexport var BothTransformation =\ncreateParallelTransformation('both', earlyCrash, earlyReject, noop, {\n  resolved: function BothTransformation$resolved(x){\n    return this.$1._transform(new PairTransformation(this.context, x));\n  }\n});\n\nexport function both(left){\n  var context1 = application1(both, future, arguments);\n  return function both(right){\n    var context2 = application(2, both, future, arguments, context1);\n    return right._transform(new BothTransformation(context2, left));\n  };\n}\n","import {noop} from './internal/utils.js';\nimport {createInterpreter, application1, future} from './future.js';\n\nexport var Cold = 0;\nexport var Pending = 1;\nexport var Crashed = 2;\nexport var Rejected = 3;\nexport var Resolved = 4;\n\nexport function Queued(rec, rej, res){\n  this[Crashed] = rec;\n  this[Rejected] = rej;\n  this[Resolved] = res;\n}\n\nexport var Cache = createInterpreter(1, 'cache', function Cache$interpret(rec, rej, res){\n  var cancel = noop;\n\n  switch(this._state){\n    /* c8 ignore next 4 */\n    case Pending: cancel = this._addToQueue(rec, rej, res); break;\n    case Crashed: rec(this._value); break;\n    case Rejected: rej(this._value); break;\n    case Resolved: res(this._value); break;\n    default:\n      this._queue = [];\n      cancel = this._addToQueue(rec, rej, res);\n      this.run();\n  }\n\n  return cancel;\n});\n\nCache.prototype._cancel = noop;\nCache.prototype._queue = null;\nCache.prototype._queued = 0;\nCache.prototype._value = undefined;\nCache.prototype._state = Cold;\n\nCache.prototype.extractLeft = function Cache$extractLeft(){\n  return this._state === Rejected ? [this._value] : [];\n};\n\nCache.prototype.extractRight = function Cache$extractRight(){\n  return this._state === Resolved ? [this._value] : [];\n};\n\nCache.prototype._addToQueue = function Cache$addToQueue(rec, rej, res){\n  var _this = this;\n  if(_this._state > Pending) return noop;\n  var i = _this._queue.push(new Queued(rec, rej, res)) - 1;\n  _this._queued = _this._queued + 1;\n\n  return function Cache$removeFromQueue(){\n    if(_this._state > Pending) return;\n    _this._queue[i] = undefined;\n    _this._queued = _this._queued - 1;\n    if(_this._queued === 0) _this.reset();\n  };\n};\n\nCache.prototype._drainQueue = function Cache$drainQueue(){\n  if(this._state <= Pending) return;\n  if(this._queued === 0) return;\n  var queue = this._queue;\n  var length = queue.length;\n  var state = this._state;\n  var value = this._value;\n\n  for(var i = 0; i < length; i++){\n    queue[i] && queue[i][state](value);\n    queue[i] = undefined;\n  }\n\n  this._queue = undefined;\n  this._queued = 0;\n};\n\nCache.prototype.crash = function Cache$crash(error){\n  if(this._state > Pending) return;\n  this._value = error;\n  this._state = Crashed;\n  this._drainQueue();\n};\n\nCache.prototype.reject = function Cache$reject(reason){\n  if(this._state > Pending) return;\n  this._value = reason;\n  this._state = Rejected;\n  this._drainQueue();\n};\n\nCache.prototype.resolve = function Cache$resolve(value){\n  if(this._state > Pending) return;\n  this._value = value;\n  this._state = Resolved;\n  this._drainQueue();\n};\n\nCache.prototype.run = function Cache$run(){\n  var _this = this;\n  if(_this._state > Cold) return;\n  _this._state = Pending;\n  _this._cancel = _this.$1._interpret(\n    function Cache$fork$rec(x){ _this.crash(x) },\n    function Cache$fork$rej(x){ _this.reject(x) },\n    function Cache$fork$res(x){ _this.resolve(x) }\n  );\n};\n\nCache.prototype.reset = function Cache$reset(){\n  if(this._state === Cold) return;\n  if(this._state === Pending) this._cancel();\n  this._cancel = noop;\n  this._queue = [];\n  this._queued = 0;\n  this._value = undefined;\n  this._state = Cold;\n};\n\nexport function cache(m){\n  return new Cache(application1(cache, future, arguments), m);\n}\n","import {call} from './internal/utils.js';\nimport {createTransformation, application1, application, future, func} from './future.js';\n\nexport var ChainRejTransformation = createTransformation(1, 'chainRej', {\n  rejected: function ChainRejTransformation$rejected(x){ return call(this.$1, x) }\n});\n\nexport function chainRej(f){\n  var context1 = application1(chainRej, func, arguments);\n  return function chainRej(m){\n    var context2 = application(2, chainRej, future, arguments, context1);\n    return m._transform(new ChainRejTransformation(context2, f));\n  };\n}\n","import {FL} from './internal/const.js';\nimport {invalidArgumentOf} from './internal/error.js';\nimport {isChain} from './internal/predicates.js';\nimport {isFuture, application1, application, func, ChainTransformation} from './future.js';\n\nexport var monad = {pred: isChain, error: invalidArgumentOf('have Chain implemented')};\n\nexport function chain(f){\n  var context1 = application1(chain, func, arguments);\n  return function chain(m){\n    var context2 = application(2, chain, monad, arguments, context1);\n    return isFuture(m) ?\n           m._transform(new ChainTransformation(context2, f)) :\n           m[FL.chain](f);\n  };\n}\n","import {application1, future} from './future.js';\n\nexport function extractLeft(m){\n  application1(extractLeft, future, arguments);\n  return m.extractLeft();\n}\n","import {application1, future} from './future.js';\n\nexport function extractRight(m){\n  application1(extractRight, future, arguments);\n  return m.extractRight();\n}\n","import {call} from './internal/utils.js';\nimport {createTransformation, Resolve, application1, application, func, future} from './future.js';\n\nexport var CoalesceTransformation = createTransformation(2, 'coalesce', {\n  rejected: function CoalesceTransformation$rejected(x){\n    return new Resolve(this.context, call(this.$1, x));\n  },\n  resolved: function CoalesceTransformation$resolved(x){\n    return new Resolve(this.context, call(this.$2, x));\n  }\n});\n\nexport function coalesce(f){\n  var context1 = application1(coalesce, func, arguments);\n  return function coalesce(g){\n    var context2 = application(2, coalesce, func, arguments, context1);\n    return function coalesce(m){\n      var context3 = application(3, coalesce, future, arguments, context2);\n      return m._transform(new CoalesceTransformation(context3, f, g));\n    };\n  };\n}\n","import {raise} from './internal/utils.js';\nimport {application, application1, func, future} from './future.js';\n\nexport function fork(f){\n  var context1 = application1(fork, func, arguments);\n  return function fork(g){\n    var context2 = application(2, fork, func, arguments, context1);\n    return function fork(m){\n      application(3, fork, future, arguments, context2);\n      return m._interpret(raise, f, g);\n    };\n  };\n}\n","export var Undetermined = 0;\nexport var Synchronous = 1;\nexport var Asynchronous = 2;\n","/*eslint consistent-return: 0 */\n\nimport {typeError, invalidFuture, invalidArgument, wrapException} from './internal/error.js';\nimport {isIteration} from './internal/iteration.js';\nimport {isIterator} from './internal/predicates.js';\nimport {Undetermined, Synchronous, Asynchronous} from './internal/timing.js';\nimport {show, noop} from './internal/utils.js';\nimport {createInterpreter, isFuture, application1, func} from './future.js';\n\nexport function invalidIteration(o){\n  return typeError(\n    'The iterator did not return a valid iteration from iterator.next()\\n' +\n    '  Actual: ' + show(o)\n  );\n}\n\nexport function invalidState(x){\n  return invalidFuture(\n    'go() expects the value produced by the iterator', x,\n    '\\n  Tip: If you\\'re using a generator, make sure you always yield a Future'\n  );\n}\n\nexport var Go = createInterpreter(1, 'go', function Go$interpret(rec, rej, res){\n\n  var _this = this, timing = Undetermined, cancel = noop, state, value, iterator;\n\n  function crash(e){\n    rec(wrapException(e, _this));\n  }\n\n  try{\n    iterator = _this.$1();\n  }catch(e){\n    crash(e);\n    return noop;\n  }\n\n  if(!isIterator(iterator)){\n    crash(invalidArgument('go', 0, 'return an iterator, maybe you forgot the \"*\"', iterator));\n    return noop;\n  }\n\n  function resolved(x){\n    value = x;\n    if(timing === Asynchronous) return drain();\n    timing = Synchronous;\n  }\n\n  function drain(){\n    //eslint-disable-next-line no-constant-condition\n    while(true){\n      try{\n        state = iterator.next(value);\n      }catch(e){\n        return crash(e);\n      }\n      if(!isIteration(state)) return crash(invalidIteration(state));\n      if(state.done) break;\n      if(!isFuture(state.value)){\n        return crash(invalidState(state.value));\n      }\n      timing = Undetermined;\n      cancel = state.value._interpret(crash, rej, resolved);\n      if(timing === Undetermined) return timing = Asynchronous;\n    }\n    res(state.value);\n  }\n\n  drain();\n\n  return function Go$cancel(){ cancel() };\n\n});\n\nexport function go(generator){\n  return new Go(application1(go, func, arguments), generator);\n}\n","import {noop, show, raise} from './internal/utils.js';\nimport {invalidFuture, wrapException} from './internal/error.js';\nimport {createInterpreter, isFuture, application1, application, func, future} from './future.js';\n\nfunction invalidDisposal(m, f, x){\n  return invalidFuture(\n    'hook() expects the return value from the first function it\\'s given', m,\n    '\\n  From calling: ' + show(f) + '\\n  With: ' + show(x)\n  );\n}\n\nfunction invalidConsumption(m, f, x){\n  return invalidFuture(\n    'hook() expects the return value from the second function it\\'s given', m,\n    '\\n  From calling: ' + show(f) + '\\n  With: ' + show(x)\n  );\n}\n\nexport var Hook = createInterpreter(3, 'hook', function Hook$interpret(rec, rej, res){\n\n  var _this = this, _acquire = this.$1, _dispose = this.$2, _consume = this.$3;\n  var cancel, cancelConsume = noop, resource, value, cont = noop;\n\n  function Hook$done(){\n    cont(value);\n  }\n\n  function Hook$rec(x){\n    rec(wrapException(x, _this));\n  }\n\n  function Hook$dispose(){\n    var disposal;\n    try{\n      disposal = _dispose(resource);\n    }catch(e){\n      return Hook$rec(e);\n    }\n    if(!isFuture(disposal)){\n      return Hook$rec(invalidDisposal(disposal, _dispose, resource));\n    }\n    cancel = Hook$cancelDisposal;\n    disposal._interpret(Hook$rec, Hook$disposalRejected, Hook$done);\n  }\n\n  function Hook$cancelConsumption(){\n    cancelConsume();\n    Hook$dispose();\n    Hook$cancelDisposal();\n  }\n\n  function Hook$cancelDisposal(){\n    cont = noop;\n  }\n\n  function Hook$disposalRejected(x){\n    Hook$rec(new Error('The disposal Future rejected with ' + show(x)));\n  }\n\n  function Hook$consumptionException(x){\n    cont = Hook$rec;\n    value = x;\n    Hook$dispose();\n  }\n\n  function Hook$consumptionRejected(x){\n    cont = rej;\n    value = x;\n    Hook$dispose();\n  }\n\n  function Hook$consumptionResolved(x){\n    cont = res;\n    value = x;\n    Hook$dispose();\n  }\n\n  function Hook$consume(x){\n    resource = x;\n    var consumption;\n    try{\n      consumption = _consume(resource);\n    }catch(e){\n      return Hook$consumptionException(e);\n    }\n    if(!isFuture(consumption)){\n      return Hook$consumptionException(invalidConsumption(consumption, _consume, resource));\n    }\n    cancel = Hook$cancelConsumption;\n    cancelConsume = consumption._interpret(\n      Hook$consumptionException,\n      Hook$consumptionRejected,\n      Hook$consumptionResolved\n    );\n  }\n\n  var cancelAcquire = _acquire._interpret(Hook$rec, rej, Hook$consume);\n  cancel = cancel || cancelAcquire;\n\n  return function Hook$fork$cancel(){\n    rec = raise;\n    cancel();\n  };\n\n});\n\nexport function hook(acquire){\n  var context1 = application1(hook, future, arguments);\n  return function hook(dispose){\n    var context2 = application(2, hook, func, arguments, context1);\n    return function hook(consume){\n      var context3 = application(3, hook, func, arguments, context2);\n      return new Hook(context3, acquire, dispose, consume);\n    };\n  };\n}\n","import {AndTransformation} from './and.js';\nimport {\n  application,\n  application1,\n  createTransformation,\n  future,\n  Reject,\n  Resolve\n} from './future.js';\n\nexport var LastlyTransformation = createTransformation(1, 'lastly', {\n  rejected: function LastlyAction$rejected(x){\n    return this.$1._transform(new AndTransformation(this.context, new Reject(this.context, x)));\n  },\n  resolved: function LastlyAction$resolved(x){\n    return this.$1._transform(new AndTransformation(this.context, new Resolve(this.context, x)));\n  }\n});\n\nexport function lastly(cleanup){\n  var context1 = application1(lastly, future, arguments);\n  return function lastly(program){\n    var context2 = application(2, lastly, future, arguments, context1);\n    return program._transform(new LastlyTransformation(context2, cleanup));\n  };\n}\n","import {call} from './internal/utils.js';\nimport {createTransformation, Reject, application1, application, future, func} from './future.js';\n\nexport var MapRejTransformation = createTransformation(1, 'mapRej', {\n  rejected: function MapRejTransformation$rejected(x){\n    return new Reject(this.context, call(this.$1, x));\n  }\n});\n\nexport function mapRej(f){\n  var context1 = application1(mapRej, func, arguments);\n  return function mapRej(m){\n    var context2 = application(2, mapRej, future, arguments, context1);\n    return m._transform(new MapRejTransformation(context2, f));\n  };\n}\n","import {wrapException} from './internal/error.js';\nimport {noop, call} from './internal/utils.js';\nimport {createInterpreter, application1, func} from './future.js';\n\nexport var Node = createInterpreter(1, 'node', function Node$interpret(rec, rej, res){\n  function Node$done(err, val){\n    cont = err ? function EncaseN3$rej(){\n      open = false;\n      rej(err);\n    } : function EncaseN3$res(){\n      open = false;\n      res(val);\n    };\n    if(open){\n      cont();\n    }\n  }\n  var open = false, cont = function(){ open = true };\n  try{\n    call(this.$1, Node$done);\n  }catch(e){\n    rec(wrapException(e, this));\n    open = false;\n    return noop;\n  }\n  cont();\n  return function Node$cancel(){ open = false };\n});\n\nexport function node(f){\n  return new Node(application1(node, func, arguments), f);\n}\n","import {createParallelTransformation, earlyCrash, earlyReject} from './internal/parallel.js';\nimport {noop} from './internal/utils.js';\nimport {typeError} from './internal/error.js';\nimport {isFunction} from './internal/predicates.js';\nimport {show} from './internal/utils.js';\nimport {MapTransformation, application1, application, future} from './future.js';\n\nexport var ParallelApTransformation =\ncreateParallelTransformation('pap', earlyCrash, earlyReject, noop, {\n  resolved: function ParallelApTransformation$resolved(f){\n    if(isFunction(f)) return this.$1._transform(new MapTransformation(this.context, f));\n    throw typeError(\n      'pap expects the second Future to resolve to a Function\\n' +\n      '  Actual: ' + show(f)\n    );\n  }\n});\n\nexport function pap(mx){\n  var context1 = application1(pap, future, arguments);\n  return function pap(mf){\n    var context2 = application(2, pap, future, arguments, context1);\n    return mf._transform(new ParallelApTransformation(context2, mx));\n  };\n}\n","import {wrapException, invalidArgumentOf} from './internal/error.js';\nimport {isArray} from './internal/predicates.js';\nimport {noop} from './internal/utils.js';\nimport {\n  createInterpreter,\n  isFuture,\n  resolve,\n  application1,\n  positiveInteger,\n  application\n} from './future.js';\n\nfunction isFutureArray(xs){\n  if(!isArray(xs)) return false;\n  for(var i = 0; i < xs.length; i++){\n    if(!isFuture(xs[i])) return false;\n  }\n  return true;\n}\n\nexport var futureArray = {\n  pred: isFutureArray,\n  error: invalidArgumentOf('be an Array of valid Futures')\n};\n\nexport var Parallel = createInterpreter(2, 'parallel', function Parallel$interpret(rec, rej, res){\n\n  var _this = this, futures = this.$2, length = futures.length;\n  var max = Math.min(this.$1, length), cancels = new Array(length), out = new Array(length);\n  var cursor = 0, running = 0, blocked = false, cont = noop;\n\n  function Parallel$cancel(){\n    rec = noop;\n    rej = noop;\n    res = noop;\n    cursor = length;\n    for(var n = 0; n < length; n++) cancels[n] && cancels[n]();\n  }\n\n  function Parallel$run(idx){\n    running++;\n    cancels[idx] = futures[idx]._interpret(function Parallel$rec(e){\n      cont = rec;\n      cancels[idx] = noop;\n      Parallel$cancel();\n      cont(wrapException(e, _this));\n    }, function Parallel$rej(reason){\n      cont = rej;\n      cancels[idx] = noop;\n      Parallel$cancel();\n      cont(reason);\n    }, function Parallel$res(value){\n      cancels[idx] = noop;\n      out[idx] = value;\n      running--;\n      if(cursor === length && running === 0) res(out);\n      else if(blocked) Parallel$drain();\n    });\n  }\n\n  function Parallel$drain(){\n    blocked = false;\n    while(cursor < length && running < max) Parallel$run(cursor++);\n    blocked = true;\n  }\n\n  Parallel$drain();\n\n  return Parallel$cancel;\n\n});\n\nvar emptyArray = resolve([]);\n\nexport function parallel(max){\n  var context1 = application1(parallel, positiveInteger, arguments);\n  return function parallel(ms){\n    var context2 = application(2, parallel, futureArray, arguments, context1);\n    return ms.length === 0 ? emptyArray : new Parallel(context2, max, ms);\n  };\n}\n","import {\n  createParallelTransformation,\n  earlyCrash,\n  earlyReject,\n  earlyResolve\n} from './internal/parallel.js';\nimport {application1, application, future} from './future.js';\n\nexport var RaceTransformation =\ncreateParallelTransformation('race', earlyCrash, earlyReject, earlyResolve, {});\n\nexport function race(left){\n  var context1 = application1(race, future, arguments);\n  return function race(right){\n    var context2 = application(2, race, future, arguments, context1);\n    return right._transform(new RaceTransformation(context2, left));\n  };\n}\n","import type from 'sanctuary-type-identifiers';\n\nimport {FL, namespace, version} from './internal/const.js';\nimport {invalidFutureArgument} from './internal/error.js';\nimport {captureContext} from './internal/debug.js';\nimport {nil} from './internal/list.js';\n\nimport {never, resolve, isFuture, MapTransformation} from './future.js';\nimport {ParallelApTransformation} from './pap.js';\nimport {RaceTransformation} from './race.js';\n\nexport function ConcurrentFuture (sequential){\n  this.sequential = sequential;\n}\n\nConcurrentFuture.prototype = Object.create(Par.prototype);\n\nexport function Par (sequential){\n  if(!isFuture(sequential)) throw invalidFutureArgument(Par.name, 0, sequential);\n  return new ConcurrentFuture(sequential);\n}\n\nvar $$type = namespace + '/ConcurrentFuture@' + version;\nvar zeroInstance = new ConcurrentFuture(never);\n\n// Compliance with sanctuary-type-identifiers versions 1 and 2.\n// To prevent sanctuary-type-identifiers version 3 from identifying\n// 'Par' as being of the type denoted by $$type, we ensure that\n// Par.constructor.prototype is equal to Par.\nPar['@@type'] = $$type;\nPar.constructor = {prototype: Par};\n\nPar[FL.of] = function Par$of(x){\n  return new ConcurrentFuture(resolve(x));\n};\n\nPar[FL.zero] = function Par$zero(){\n  return zeroInstance;\n};\n\nPar.prototype['@@type'] = $$type;\n\nPar.prototype['@@show'] = function Par$show(){\n  return this.toString();\n};\n\nPar.prototype.toString = function Par$toString(){\n  return 'Par (' + this.sequential.toString() + ')';\n};\n\nPar.prototype[FL.map] = function Par$FL$map(f){\n  var context = captureContext(\n    nil,\n    'a Fantasy Land dispatch to map via ConcurrentFuture',\n    Par$FL$map\n  );\n  return new ConcurrentFuture(this.sequential._transform(new MapTransformation(context, f)));\n};\n\nPar.prototype[FL.ap] = function Par$FL$ap(other){\n  var context = captureContext(\n    nil,\n    'a Fantasy Land dispatch to ap via ConcurrentFuture',\n    Par$FL$ap\n  );\n  return new ConcurrentFuture(other.sequential._transform(\n    new ParallelApTransformation(context, this.sequential)\n  ));\n};\n\nPar.prototype[FL.alt] = function Par$FL$alt(other){\n  var context = captureContext(\n    nil,\n    'a Fantasy Land dispatch to alt via ConcurrentFuture',\n    Par$FL$alt\n  );\n  return new ConcurrentFuture(other.sequential._transform(\n    new RaceTransformation(context, this.sequential)\n  ));\n};\n\nexport function isParallel(x){\n  return x instanceof ConcurrentFuture || type(x) === $$type;\n}\n","import {\n  any,\n  application,\n  application1,\n  createInterpreter,\n  never,\n  positiveInteger\n} from './future.js';\n\nexport var RejectAfter =\ncreateInterpreter(2, 'rejectAfter', function RejectAfter$interpret(rec, rej){\n  var id = setTimeout(rej, this.$1, this.$2);\n  return function RejectAfter$cancel(){ clearTimeout(id) };\n});\n\nRejectAfter.prototype.extractLeft = function RejectAfter$extractLeft(){\n  return [this.$2];\n};\n\nfunction alwaysNever(_){\n  return never;\n}\n\nexport function rejectAfter(time){\n  var context1 = application1(rejectAfter, positiveInteger, arguments);\n  return time === Infinity ? alwaysNever : (function rejectAfter(value){\n    var context2 = application(2, rejectAfter, any, arguments, context1);\n    return new RejectAfter(context2, time, value);\n  });\n}\n","import {invalidArgumentOf} from './internal/error.js';\nimport {application1} from './future.js';\nimport {isParallel} from './par.js';\n\nvar parallel = {pred: isParallel, error: invalidArgumentOf('be a ConcurrentFuture')};\n\nexport function seq(par){\n  application1(seq, parallel, arguments);\n  return par.sequential;\n}\n","import {createTransformation, Reject, Resolve, application1, future} from './future.js';\n\nexport var SwapTransformation = createTransformation(0, 'swap', {\n  resolved: function SwapTransformation$resolved(x){\n    return new Reject(this.context, x);\n  },\n  rejected: function SwapTransformation$rejected(x){\n    return new Resolve(this.context, x);\n  }\n});\n\nexport function swap(m){\n  var context = application1(swap, future, arguments);\n  return m._transform(new SwapTransformation(context));\n}\n","//. # fluture-sanctuary-types\n//.\n//. [Fluture][] type definitions for [Sanctuary][].\n//.\n//. ## Usage\n//.\n//. ### Node\n//.\n//. ```console\n//. $ npm install --save fluture-sanctuary-types\n//. ```\n//.\n//. Note that you also need [Fluture][] and [sanctuary-def][] installed.\n//. Sanctuary-def comes preinstalled with Sanctuary, so you could install\n//. either one. Fluture has to be installed separately. See `package.json`\n//. for compatible versions (defined in `peerDependencies`).\n//.\n//. On Node 12 and up, this module can be loaded directly with `import` or\n//. `require`. On Node versions below 12, `require` or the [esm][]-loader can\n//. be used.\n//.\n//. ```js\n//. import $ from 'sanctuary-def';\n//. import sanctuary from 'sanctuary';\n//. import {env, FutureType} from 'fluture-sanctuary-types/index.js';\n//. import {resolve} from 'fluture/index.js';\n//.\n//. const S = sanctuary.create ({\n//.   checkTypes: process.env.NODE_ENV !== 'production',\n//.   env: sanctuary.env.concat (env)\n//. });\n//.\n//. S.is (FutureType ($.String) ($.Number)) (resolve (42));\n//. ```\n//.\n//. ### Deno and Modern Browsers\n//.\n//. You can load the EcmaScript module from various content delivery networks:\n//.\n//. - [Skypack](https://cdn.skypack.dev/fluture-sanctuary-types@7.1.0)\n//. - [JSPM](https://jspm.dev/fluture-sanctuary-types@7.1.0)\n//. - [jsDelivr](https://cdn.jsdelivr.net/npm/fluture-sanctuary-types@7.1.0/+esm)\n//.\n//. ### Old Browsers and Code Pens\n//.\n//. There's a [UMD][] file included in the NPM package, also available via\n//. jsDelivr: https://cdn.jsdelivr.net/npm/fluture-sanctuary-types@7.1.0/dist/umd.js\n//.\n//. This file adds `flutureSanctuaryTypes` to the global scope, or use\n//. CommonJS/AMD when available.\n//.\n//. ```js\n//. const $ = require ('sanctuary-def');\n//. const sanctuary = require ('sanctuary');\n//. const {env, FutureType} = require ('fluture-sanctuary-types');\n//. const {resolve} = require ('fluture');\n//.\n//. const S = sanctuary.create ({\n//.   checkTypes: process.env.NODE_ENV !== 'production',\n//.   env: sanctuary.env.concat (env)\n//. });\n//.\n//. S.is (FutureType ($.String) ($.Number)) (resolve (42));\n//. ```\n\nimport $ from 'sanctuary-def';\nimport type from 'sanctuary-type-identifiers';\nimport {\n  Future,\n  isFuture,\n  extractLeft,\n  extractRight,\n  Par,\n  seq\n} from 'fluture/index.js';\n\n//  $$type :: String\nvar $$type = '@@type';\n\n//# FutureType :: Type -> Type -> Type\n//.\n//. The binary type constructor for members of Future.\n//.\n//. ```js\n//. > $.test (env)\n//. .        (FutureType ($.String) ($.Number))\n//. .        (Future['fantasy-land/of'] (1));\n//. true\n//. ```\nexport var FutureType = $.BinaryType\n  (type.parse (Future[$$type]).name)\n  ('https://github.com/fluture-js/Fluture#readme')\n  ([])\n  (isFuture)\n  (extractLeft)\n  (extractRight);\n\n//# ConcurrentFutureType :: Type -> Type -> Type\n//.\n//. The binary type constructor for members of ConcurrentFuture.\n//.\n//. ```js\n//. > $.test (env)\n//. .        (ConcurrentFutureType ($.String) ($.Number))\n//. .        (Par['fantasy-land/of'] (1));\n//. true\n//. ```\nexport var ConcurrentFutureType = $.BinaryType\n  (type.parse (Par[$$type]).name)\n  ('https://github.com/fluture-js/Fluture#concurrentfuture')\n  ([])\n  (function(x) { return type (x) === Par[$$type] && x !== Par; })\n  (function(f) { return (seq (f)).extractLeft (); })\n  (function(f) { return (seq (f)).extractRight (); });\n\n//# env :: Array Type\n//.\n//. An Array containing all types applied to [`$.Unknown`][Unknown] for\n//. direct use as a Sanctuary environment, as shown in [Usage](#usage).\nexport var env = [\n  FutureType ($.Unknown) ($.Unknown),\n  ConcurrentFutureType ($.Unknown) ($.Unknown)\n];\n\n//. [Fluture]:       https://github.com/fluture-js/Fluture\n//. [Sanctuary]:     https://sanctuary.js.org/\n//. [sanctuary-def]: https://github.com/sanctuary-js/sanctuary-def\n//. [Unknown]:       https://github.com/sanctuary-js/sanctuary-def#Unknown\n//. [esm]:           https://github.com/standard-things/esm\n//. [UMD]:           https://github.com/umdjs/umd\n"],"names":["require$$0","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","$$type","showArg"],"mappings":"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"}